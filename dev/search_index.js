var documenterSearchIndex = {"docs":
[{"location":"man/tensors/#s_tensors","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"using TensorLabXD\nusing LinearAlgebra","category":"page"},{"location":"man/tensors/#Types","page":"Tensors and the TensorMap type","title":"Types","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"abstract type AbstractTensorMap{S<:IndexSpace, N₁, N₂} end\nconst AbstractTensor{S<:IndexSpace, N} = AbstractTensorMap{S, N, 0}\n\nstruct TensorMap{S<:IndexSpace, N₁, N₂, I<:Sector, A<:Union{<:DenseMatrix,SectorDict{I,<:DenseMatrix}}, F₁, F₂} <: AbstractTensorMap{S, N₁, N₂}\n    data::A\n    codom::ProductSpace{S,N₁}\n    dom::ProductSpace{S,N₂}\n    rowr::SectorDict{I,FusionTreeDict{F₁,UnitRange{Int}}}\n    colr::SectorDict{I,FusionTreeDict{F₂,UnitRange{Int}}}\n    function TensorMap{S, N₁, N₂, I, A, F₁, F₂}(data::A,\n                codom::ProductSpace{S,N₁}, dom::ProductSpace{S,N₂},\n                rowr::SectorDict{I,FusionTreeDict{F₁,UnitRange{Int}}},\n                colr::SectorDict{I,FusionTreeDict{F₂,UnitRange{Int}}}) where\n                    {S<:IndexSpace, N₁, N₂, I<:Sector, A<:SectorDict{I,<:DenseMatrix},\n                     F₁<:FusionTree{I,N₁}, F₂<:FusionTree{I,N₂}}\n        eltype(valtype(data)) ⊆ field(S) ||\n            @warn(\"eltype(data) = $(eltype(data)) ⊈ $(field(S)))\", maxlog=1)\n        new{S, N₁, N₂, I, A, F₁, F₂}(data, codom, dom, rowr, colr)\n    end\n    function TensorMap{S, N₁, N₂, Trivial, A, Nothing, Nothing}(data::A,\n                codom::ProductSpace{S,N₁}, dom::ProductSpace{S,N₂}) where\n                    {S<:IndexSpace, N₁, N₂, A<:DenseMatrix}\n        eltype(data) ⊆ field(S) ||\n            @warn(\"eltype(data) = $(eltype(data)) ⊈ $(field(S)))\", maxlog=1)\n        new{S, N₁, N₂, Trivial, A, Nothing, Nothing}(data, codom, dom)\n    end\nend\n\nconst Tensor{S<:IndexSpace, N, I<:Sector, A, F₁, F₂} = TensorMap{S, N, 0, I, A, F₁, F₂}\nconst TrivialTensorMap{S<:IndexSpace, N₁, N₂, A<:DenseMatrix} = TensorMap{S, N₁, N₂, Trivial, A, Nothing, Nothing}\n\nstruct TensorKeyIterator{I<:Sector, F₁<:FusionTree{I}, F₂<:FusionTree{I}}\n    rowr::SectorDict{I, FusionTreeDict{F₁, UnitRange{Int}}}\n    colr::SectorDict{I, FusionTreeDict{F₂, UnitRange{Int}}}\nend\nstruct TensorPairIterator{I<:Sector, F₁<:FusionTree{I}, F₂<:FusionTree{I}, A<:DenseMatrix}\n    rowr::SectorDict{I, FusionTreeDict{F₁, UnitRange{Int}}}\n    colr::SectorDict{I, FusionTreeDict{F₂, UnitRange{Int}}}\n    data::SectorDict{I, A}\nend\n\nconst TensorIterator{I<:Sector, F₁<:FusionTree{I}, F₂<:FusionTree{I}} = Union{TensorKeyIterator{I, F₁, F₂}, TensorPairIterator{I, F₁, F₂}}\n\nstruct AdjointTensorMap{S<:IndexSpace, N₁, N₂, I<:Sector, A, F₁, F₂} <: AbstractTensorMap{S, N₁, N₂}\n    parent::TensorMap{S, N₂, N₁, I, A, F₂, F₁}\nend\n\nconst AdjointTrivialTensorMap{S<:IndexSpace, N₁, N₂, A<:DenseMatrix} =\n    AdjointTensorMap{S, N₁, N₂, Trivial, A, Nothing, Nothing}\n\nconst EuclideanTensorSpace = TensorSpace{<:EuclideanSpace}\nconst EuclideanTensorMapSpace = TensorMapSpace{<:EuclideanSpace}\nconst AbstractEuclideanTensorMap = AbstractTensorMap{<:EuclideanTensorSpace}\nconst EuclideanTensorMap = TensorMap{<:EuclideanTensorSpace}","category":"page"},{"location":"man/tensors/#Properties","page":"Tensors and the TensorMap type","title":"Properties","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"On both instances and types:","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"storagetype(t::AbstractTensorMap) # gives the way the tensor data are stored, now all DenseArray\nsimilarstoragetype(t::AbstractTensorMap, T)\nnumout(t::AbstractTensorMap) # gives N_1 for the codomain\nnumin(t::AbstractTensorMap) # gives N_2 for the domain\nnumind(t::AbstractTensorMap) # gives N_1+N_2\nconst order = numind\ncodomainind(t::AbstractTensorMap) # 1:N_1\ndomainind(t::AbstractTensorMap) # N_1+1:N_1+N_2\nallind(t::AbstractTensorMap) # 1:N_1+N_2","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"On instances:","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"codomian(t::AbstractTensorMap)\ncodomain(t::AbstractTensorMap, i) # `i`th index space of the codomain of the tensor map `t`.\ndomain(t::AbstractTensorMap)\ndomain(t::AbstractTensorMap, i) # `i`th index space of the domain of the tensor map `t`.\nsource(t::AbstractTensorMap) # gives domain\ntarget(t::AbstractTensorMap) # gives codomain\nspace(t::AbstractTensorMap) # give HomSpace\nspace(t::AbstractTensorMap, i::Int) # `i`th index space of the HomSpace corresponding to the tensor map `t`.\nadjointtensorindex(t::AbstractTensorMap{<:IndexSpace, N₁, N₂}, i) # gives the index in the adjoint tensor which corresponds to the ith vector space in the original tensor\nadjointtensorindices(t::AbstractTensorMap, indices::IndexTuple)\ntensormaptype(::Type{S}, N₁::Int, N₂::Int, ::Type{T}) where {S,T} # Return the correct tensormap type without giving the type of data and the FusionTree. `T` is a subtype of `Number` or of `DenseMatrix`.\nblocksectors(t::TensorMap) # Return an iterator over the different unique coupled sector labels\nhasblock(t::TensorMap, s::Sector) # Check whether the sector `s` is in the block sectors of `t`.\nblocks(t::TensorMap) # Return the data of the tensor map as a `SingletonDict` (for trivial sectortype) or a `SectorDict`.\nblock(t::TensorMap, s::Sector) # Return the data of tensor map corresponding to the blcok sector `s` as a DenseMatrix.\nfusiontrees(t::TensorMap) # Return tbe TensorKeyIterator for all possible splitting and fusion tree pair in the tensor map.\nBase.getindex(t::TensorMap{<:IndexSpace,N₁,N₂,I}, f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}) # t[f1,f2]\nBase.getindex(t::TensorMap{<:IndexSpace,N₁,N₂,I}, sectors::Tuple{Vararg{I}}) # `sectors[1:N₁]` are the sectors in codomain; `sectors[N₁+1:N₁+N₂]` are the dual of each sector in the domain.","category":"page"},{"location":"man/tensors/#Constructors","page":"Tensors and the TensorMap type","title":"Constructors","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TensorMap(f, codom::ProductSpace{S,N₁}, dom::ProductSpace{S,N₂}) where {S<:IndexSpace, N₁, N₂}\nTensorMap(data::DenseArray, codom::ProductSpace{S,N₁}, dom::ProductSpace{S,N₂}; tol = sqrt(eps(real(float(eltype(data)))))) where {S<:IndexSpace, N₁, N₂}\nTensorMap(data::AbstractDict{<:Sector,<:DenseMatrix}, codom::ProductSpace{S,N₁}, dom::ProductSpace{S,N₂}) where {S<:IndexSpace, N₁, N₂}\nTensorMap(f,::Type{T}, codom::ProductSpace{S}, dom::ProductSpace{S}) where {S<:IndexSpace, T<:Number}\nTensorMap(::Type{T}, codom::ProductSpace{S}, dom::ProductSpace{S}) where {S<:IndexSpace, T<:Number}\nTensorMap(::UndefInitializer, ::Type{T}, codom::ProductSpace{S}, dom::ProductSpace{S}) where {S<:IndexSpace, T<:Number}\nTensorMap(::UndefInitializer, codom::ProductSpace{S}, dom::ProductSpace{S}) where {S<:IndexSpace}\nTensorMap(::Type{T}, codom::TensorSpace{S}, dom::TensorSpace{S}) where {T<:Number, S<:IndexSpace}\nTensorMap(dataorf, codom::TensorSpace{S}, dom::TensorSpace{S}) where {S<:IndexSpace}\nTensorMap(dataorf, ::Type{T}, codom::TensorSpace{S}, dom::TensorSpace{S}) where {T<:Number, S<:IndexSpace}\nTensorMap(codom::TensorSpace{S}, dom::TensorSpace{S}) where {S<:IndexSpace}\nTensorMap(dataorf, T::Type{<:Number}, P::TensorMapSpace{S}) where {S<:IndexSpace}\nTensorMap(dataorf, P::TensorMapSpace{S}) where {S<:IndexSpace}\nTensorMap(T::Type{<:Number}, P::TensorMapSpace{S}) where {S<:IndexSpace}\nTensorMap(P::TensorMapSpace{S}) where {S<:IndexSpace}\nTensor(dataorf, T::Type{<:Number}, P::TensorSpace{S}) where {S<:IndexSpace}\nTensor(dataorf, P::TensorSpace{S}) where {S<:IndexSpace}\nTensor(T::Type{<:Number}, P::TensorSpace{S}) where {S<:IndexSpace}\nTensor(P::TensorSpace{S}) where {S<:IndexSpace}\nBase.adjoint(t::TensorMap) = AdjointTensorMap(t)\nBase.adjoint(t::AdjointTensorMap) = t.parent\nzero(t::AbstractTensorMap) # Creat a tensor that is similar to the tensor map `t` with all `0` in the data.\none!(t::AbstractTensorMap) # Overwrite the tensor map `t` by a tensor map in which every matrix in data is an identity matrix.\none(t::AbstractTensorMap) # Creat a tensor map that similar to tensor map `t` and with identity matrices in data.\nid([A::Type{<:DenseMatrix} = Matrix{Float64},] space::VectorSpace) # Construct the identity endomorphism on space `space`, i.e. return a `t::TensorMap` with `domain(t) == codomain(t) == V`, where `storagetype(t) = A` can be specified.\nisomorphism([A::Type{<:DenseMatrix} = Matrix{Float64},] cod::VectorSpace, dom::VectorSpace) # Return a `t::TensorMap` that implements a specific isomorphism between the codomain `cod` and the domain `dom`。\nunitary([A::Type{<:DenseMatrix} = Matrix{Float64},] cod::VectorSpace, dom::VectorSpace) # Return a `t::TensorMap` that implements a specific unitary isomorphism between the codomain `cod` and the domain `dom`, for which `spacetype(dom)` (`== spacetype(cod)`) must be a subtype of `EuclideanSpace`.\nisometry([A::Type{<:DenseMatrix} = Matrix{Float64},] cod::VectorSpace, dom::VectorSpace)","category":"page"},{"location":"man/tensors/#Linear-Operations","page":"Tensors and the TensorMap type","title":"Linear Operations","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"copy!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap)\ncopy(t::AbstractTensorMap)\nfill!(t::AbstractTensorMap, value::Number)\nadjoint!(tdst::AbstractEuclideanTensorMap, tsrc::AbstractEuclideanTensorMap)\nmul!(t1::AbstractTensorMap, t2::AbstractTensorMap, α::Number)\nmul!(t1::AbstractTensorMap, α::Number, t2::AbstractTensorMap)\nmul!(tC::AbstractTensorMap, tA::AbstractTensorMap, tB::AbstractTensorMap, α = true, β = false)\n-(t::AbstractTensorMap)\n*(t::AbstractTensorMap, α::Number)\n*(α::Number, t::AbstractTensorMap)\n*(t1::AbstractTensorMap, t2::AbstractTensorMap)\nrmul!(t::AbstractTensorMap, α::Number) = mul!(t, t, α)\nlmul!(α::Number, t::AbstractTensorMap) = mul!(t, α, t)\naxpy!(α::Number, t1::AbstractTensorMap, t2::AbstractTensorMap)\n+(t1::AbstractTensorMap, t2::AbstractTensorMap)\n-(t1::AbstractTensorMap, t2::AbstractTensorMap)\naxpby!(α::Number, t1::AbstractTensorMap, β::Number, t2::AbstractTensorMap)\nexp!(t::TensorMap)\nexp(t::AbstractTensorMap)\ninv(t::AbstractTensorMap)\n^(t::AbstractTensorMap, p::Integer)\npinv(t::AbstractTensorMap; kwargs...)\nBase.:(\\)(t1::AbstractTensorMap, t2::AbstractTensorMap)\n/(t1::AbstractTensorMap, t2::AbstractTensorMap)\n/(t::AbstractTensorMap, α::Number)\nBase.:\\(α::Number, t::AbstractTensorMap)\n:cos, :sin, :tan, :cot, :cosh, :sinh, :tanh, :coth, :atan, :acot, :asinh\n:sqrt, :log, :asin, :acos, :acosh, :atanh, :acoth\ndot(t1::AbstractEuclideanTensorMap, t2::AbstractEuclideanTensorMap) # Return the elementwise dot product of the data between two tensor maps.\nnorm(t::AbstractEuclideanTensorMap, p::Real = 2) # Return the norm of the tensor map `t` as the norm of the true block diagonal matrix which representing the tensor map.\nnormalize!(t::AbstractTensorMap, p::Real = 2) # Replace the tensor map `t` with the normalize one which has `norm(t,p)==1`.\nnormalize(t::AbstractTensorMap, p::Real = 2) #  Creat a new tensor map that is similar to `t` and has the same data with  `normalize!(t, p)`.\ntr(t::AbstractTensorMap) # Return the trace of the true block diagonal matrix that represent the tensor map.\nsylvester(A::AbstractTensorMap, B::AbstractTensorMap, C::AbstractTensorMap) # it computes the solution `X` to the Sylvester equation `AX + XB + C = 0`\ncatdomain(t1::AbstractTensorMap{S, N₁, 1}, t2::AbstractTensorMap{S, N₁, 1}) where {S, N₁}\ncatcodomain(t1::AbstractTensorMap{S, 1, N₂}, t2::AbstractTensorMap{S, 1, N₂}) where {S, N₂}\n⊗(t1::AbstractTensorMap{S}, t2::AbstractTensorMap{S}, ...) # results in a new `TensorMap` instance whose codomain is `codomain(t1) ⊗ codomain(t2)` and whose domain is `domain(t1) ⊗ domain(t2)`.\n⊠(t1::AbstractTensorMap{<:EuclideanSpace{ℂ}}, t2::AbstractTensorMap{<:EuclideanSpace{ℂ}}) # Return the deligne product of tensors.","category":"page"},{"location":"man/tensors/#Index-manipulations","page":"Tensors and the TensorMap type","title":"Index manipulations","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"","category":"page"},{"location":"man/tensors/#General-arguments","page":"Tensors and the TensorMap type","title":"General arguments","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"All tensors in TensorLabXD.jl are interpreted as linear maps from a domain (ProductSpace{S,N₂}) to a codomain (ProductSpace{S,N₁}), with the same S<:ElementarySpace that labels the type of spaces associated with the individual tensor indices. The overall type for all such tensor maps is AbstractTensorMap{S, N₁, N₂}. The constructor for a concrete TensorMap is TensorMap(..., codomain, domain). Note that we place information about the codomain before that of the domain.  This convention is opposite to the mathematical notation, e.g., mathrmHom(WV) or fWV, but originates from the fact that a normal matrix is denoted as having size m × n or is constructed in Julia as Array(..., (m, n)), where the first integer m refers to the codomain being m-dimensional, and the second integer n to the domain being n-dimensional.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The abstract type AbstractTensor{S,N} is just a synonym for AbstractTensorMap{S,N,0}, i.e., for tensor maps with an empty domain, which is equivalent to the unit of the tensor category.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Currently, AbstractTensorMap has two subtypes. TensorMap provides the actual implementation, where the data of the tensor is stored in a DenseMatrix. AdjointTensorMap is a simple wrapper type to denote the adjoint of an existing TensorMap object. In the future, additional types could be defined, to deal with sparse data, static data, diagonal data, etc...","category":"page"},{"location":"man/tensors/#ss_tensor_storage","page":"Tensors and the TensorMap type","title":"Storage of tensor data","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Let us discuss what is meant by 'tensor data' and how it can efficiently and compactly be stored.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In the case with no symmetries, i.e., sectortype(S) == Trivial, the data of a tensor t = TensorMap(..., V1 ⊗ ... ⊗ VN₁, W1 ⊗ ... ⊗ WN₂) can be represented as a multidimensional array of size","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(dim(V1), dim(V2), …, dim(VN₁), dim(W1), …, dim(WN₂))","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"which can also be reshaped into matrix of size","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(dim(V1)*dim(V2)*…*dim(VN₁), dim(W1)*dim(W2)*…*dim(WN₂))","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"and is really the matrix representation of the linear map that the tensor represents. Given another tensor t′ whose domain matches with the codomain of t, function composition amounts to multiplication of their corresponding data matrices. Tensor factorizations, such as the singular value decomposition, can act directly on this matrix representation.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"note: Note\nOne might wonder if it would not have been more natural to represent the tensor data as (dim(V1), dim(V2), …, dim(VN₁), dim(WN₂), …, dim(W1)) given how employing the duality naturally reverses the tensor product, as encountered with the interface of repartition for fusion trees. However, such a representation, when plainly reshape to a matrix, would not have the above properties and would thus not constitute the matrix representation of the tensor in a compatible basis.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In general:","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"beginaligned\nt = sum_a_1a_N_1sum_b_1b_N_2sum_i = 1^n_a_1*cdots *n_a_N_1\nsum_j = 1^n_b_1*cdots *n_b_N_2 t^ij_(a_1a_N_1)(b_1b_N_2)\n=  sum_a_1a_N_1sum_b_1b_N_2sum_i = 1^n_a_1*cdots *n_a_N_1\nsum_j = 1^n_b_1*cdots *n_b_N_2sum_c_aalphasum_c_bbeta\nX^a_1a_N_1_c_aalphacirc t^ijc_ac_b_(a_1a_N_1)alpha(b_1b_N_2)beta\ncirc (X^b_1b_N_2_c_bbeta)^\nendaligned","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"where t^ij_(a_1a_N_1)(b_1b_N_2) is a map from b_1b_2b_N_2 to a_1a_2a_N_2 and t^ijc_ac_b_(a_1a_N_1)alpha(b_1b_N_2)beta is a tensor map from c_b to c_a. In X^a_1  a_N₁_cα, the index α = (e_1  e_N_1-2 μ₁  μ_N_1-1) is a collective label for the internal sectors e and the vertex degeneracy labels μ of a generic fusion tree.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"A symmetric tensor map should satisfy U_1 t = t U_2, thus for each term of above equation of t, we have","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"beginaligned\nU_a_1a_N_1 X^a_1a_N_1_c_aalpha t^ijc_ac_b_(a_1a_N_1)alpha(b_1b_N_2)beta (X^b_1b_N_2_c_bbeta)^ = X^a_1a_N_1_c_aalpha t^ijc_ac_b_(a_1a_N_1)alpha(b_1b_N_2)beta (X^b_1b_N_2_c_bbeta)^ U_b_1b_N_2\nendaligned","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Write","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"U_c_a = (X^a_1a_N_1_c_aalpha)^ U_a_1a_N_1 X^a_1a_N_1_c_aalpha","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"and","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"U_c_b = (X^b_1b_N_2_c_bbeta)^ U_b_1b_N_2 X^b_1b_N_2_c_bbeta,","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"we get","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"U_c_a t^ijc_ac_b_(a_1a_N_1)alpha(b_1b_N_2)beta = t^ijc_ac_b_(a_1a_N_1)alpha(b_1b_N_2)beta U_c_b.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"From Schur's lemma, we know t^ijc_ac_b_(a_1a_N_1)alpha(b_1b_N_2)beta = t^ijc_a_(a_1a_N_1)alpha(b_1b_N_2)betamathbb1_c_adelta_c_ac_b, where t^ijc_a_(a_1a_N_1)alpha(b_1b_N_2)beta is a complex number.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Then, we obtain","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"beginaligned\nt = sum_a_1a_N_1sum_b_1b_N_2sum_i = 1^n_a_1*cdots *n_a_N_1\nsum_j = 1^n_b_1*cdots *n_b_N_2sum_calphabeta\nX^a_1a_N_1_calphacirc t^ijc_(a_1a_N_1)alpha(b_1b_N_2)beta\nmathbb1_ccirc (X^b_1b_N_2_cbeta)^\n = sum_a_1a_N_1sum_b_1b_N_2 sum_calphabeta\n(mathbb1_n_a_1*cdots * n_a_N_1 otimes X^a_1a_N_1_calpha)\ncirc(t^c_(a_1a_N_1)alpha(b_1b_N_2)betaotimes mathbb1_c)\ncirc(mathbb1_n_b_1*cdots * n_b_N_2\notimes X^b_1b_N_2_cbeta)^\nendaligned","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"where t^c_(a_1a_N_1)alpha(b_1b_N_2)beta is a matrix with dimension (n_a_1**n_a_N_1) times (n_b_1**n_b_N_2).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Now consider the case where sectortype(S) == I for some I which has FusionStyle(I) == UniqueFusion(), i.e. the representations of an Abelian group, e.g. I == Irrep[ℤ₂] or I == Irrep[U₁]. In this case, the tensor data is associated with sectors (a1, a2, …, aN₁) ∈ sectors(V1 ⊗ V2 ⊗ … ⊗ VN₁) and (b1, …, bN₂) ∈ sectors(W1 ⊗ … ⊗ WN₂) such that they fuse to a same common charge, i.e. (c = first(⊗(a1, …, aN₁))) == first(⊗(b1, …, bN₂)). The data associated with this takes the form of a multidimensional array with size (dim(V1, a1), …, dim(VN₁, aN₁), dim(W1, b1), …, dim(WN₂, bN₂)), or equivalently, a matrix of with row size dim(V1, a1)*…*dim(VN₁, aN₁) == dim(codomain, (a1, …, aN₁)) and column size dim(W1, b1)*…*dim(WN₂, bN₂) == dim(domain, (b1, …, bN₂)).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"There could be multiple combinations of (a1, …, aN₁) and (b1, …, bN₂) giving rise to the same c. Stacking all matrices for different (a1,…) and a fixed value of (b1,…) underneath each other, and for fixed value of (a1,…) and different values of (b1,…) next to each other, gives rise to a larger block matrix of all data associated with the central sector c. The size of this matrix is (blockdim(codomain, c), blockdim(domain, c)). This matrix is a diagonal block labeled with sector c of a tensor map.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Henceforth, we refer to the blocks of a tensor map as those diagonal blocks. We directly store these blocks as DenseMatrix and gather them as values in a dictionary, together with the corresponding coupled sector c as key. For a given tensor t, we can access a specific block as block(t, c). The blocks(t) gives an iterator over c=>block(t,c).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The subblocks corresponding to a particular combination of sectors then correspond to a view for some range of the rows and some range of the columns, e.g., view(block(t, c), m₁:m₂, n₁:n₂) where the ranges m₁:m₂ associated with (a1, …, aN₁) and n₁:n₂ associated with (b₁, …, bN₂) are stored within the fields of the instance t of type TensorMap. This view can then lazily be reshaped to a multidimensional array, for which we rely on the package StridedTensorXD.jl. Indeed, the data in this view is not contiguous, because the stride between the different columns is larger than the length of the columns. Nonetheless, this does not pose a problem and even as multidimensional array there is still a definite stride associated with each dimension.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"If we would represent the tensor map t as a matrix, we could reorder the rows and columns to group data corresponding to sectors that fuse to the same c, and the resulting block diagonal representation would emerge. This basis transform is a permutation, which is a unitary operation, that will cancel or go through trivially for linear algebra operations such as composing tensor maps (matrix multiplication) or tensor factorizations such as a singular value decomposition. For such linear algebra operations, we can thus directly act on these diagonal blocks that emerge after a basis transform, provided that the partition of the tensor indices in domain and codomain of the tensor are in line with our needs. For example, composing two tensor maps amounts to multiplying the matrices corresponding to the same c (provided that its subblocks labeled by the different combinations of sectors are ordered in the same way, which we guarantee by associating a canonical order with sectors).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"When FusionStyle(I) isa MultipleFusion, things become slightly more complicated. Not only do (a1, …, aN₁) give rise to different coupled sectors c, there can be multiply ways in which they fuse to c. These different possibilities are enumerated by the iterator fusiontrees((a1, …, aN₁), c) and fusiontrees((b1, …, bN₂), c), and with each of those, there is tensor data that takes the form of a multidimensional array, or, after reshaping, a matrix of size (dim(codomain, (a1, …, aN₁)), dim(domain, (b1, …, bN₂)))).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Again, we can stack all matrices with the same value of f₁ ∈ fusiontrees((a1, …, aN₁), c) horizontally (as they all have the same number of rows), and with the same value of f₂ ∈ fusiontrees((b1, …, bN₂), c) vertically (as they have the same number of columns). What emerges is a large matrix of size (blockdim(codomain, c), blockdim(domain, c)) containing all the tensor data associated with the coupled sector c, where blockdim(P, c) = sum(dim(P, s)*length(fusiontrees(s, c)) for s in sectors(P)) for some instance P of ProductSpace. The tensor implementation does not distinguish between abelian or non-abelian sectors and still stores these matrices as a DenseMatrix, accessible via block(t, c).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Schur's lemma now tells that there is a unitary basis transform which makes the matrix representation of a tensor map block diagonal with the form _c B_c  𝟙_c, where B_c denotes block(t,c) and 𝟙_c is an identity map from c to c. In the non-Abelian case the basis transform to the block diagonal form is not simply a permutation matrix, but a more general unitary matrix composed of the different fusion trees.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Illustrate the block diagonalization of a tensor map graphically:","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"beginaligned\nt  = sum_csum_a_1a_N_1sum_b_1b_N_2 sum_alphabeta\n(mathbb1_n_a_1*cdots * n_a_N_1 otimes X^a_1a_N_1_calpha)\ncirc(t^c_(a_1a_N_1)alpha(b_1b_N_2)betaotimes mathbb1_c)\ncirc(mathbb1_n_b_1*cdots * n_b_N_2\notimes X^b_1b_N_2_cbeta)^\nendaligned","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(Image: tensor storage)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In this diagram, we have indicated how the tensor map can be rewritten in terms of a block diagonal matrix with a unitary matrix on its left and another unitary matrix on its right. So the left and right matrices are squares and represent the unitary basis transform.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In more detail, the basis transformation on the codomain side is given by","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(Image: tensor unitary)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Remembering that V_i = _a_i ℂ^n_a_i  R_a_i with R_a_i the representation space on which irrep a_i acts (with dimension mathrmdim(a_i)), we find V_1    V_N_1 = _a_1  a_N₁ ℂ^n_a_1 *  *n_a_N_1  (R_a_1    R_a_N_1). In the diagram above, the red lines correspond to the direct sum over the different sectors (a_1  a_N₁), there depicted taking three possible values (a), (a) and (a), where (a) is a simplified notation for a certain (a_1  a_N₁). The tensor product ℂ^n_a_1 *  * n_a_N_1  (R_a_1    R_a_N_1) is depicted as (R_a_1    R_a_N_1)^(n_a_1 * *n_a_N_1), i.e. as a direct sum of the spaces R_(a) = (R_a_1    R_a_N_1) according to the dotted horizontal lines, which repeat n_(a) = n_a_1*  *n_a_N_1 times. In this particular example, n_(a)=2, n_(a)=3 and n_(a)=5. The thick vertical line represents the separation between the two different coupled sectors, denoted as c_1 and c_2. Dashed vertical lines represent different ways of reaching the coupled sector, corresponding to different (a) or alpha. In this example, the first sector (a) has one fusion tree to c_1, labeled by c_1(a), and two fusion trees to c_2, labeled by c_2(a)α_1 and c_2(a)α_2. The second sector (a) has only a fusion tree to c_1, labeled by c(a). The third sector (a) only has a fusion tree to c_2, labeld by c_2 (a). Because the fusion trees do not act on the spaces ℂ^n_a_1 * * n_a_N_1, the dotted lines which represent the different n_(a) dimensions are also drawn vertically. For a given sector (a) and a specific splitting tree X^(a)_cα R_cR_(a), the action is 𝟙_n_(a)  X^(a)_cα, which corresponds to the diagonal green blocks in this drawing where the same matrix X^(a)_cα is repeated along the diagonal. Note that the splitting tree is a matrix with number of rows equal to mathrmdim(R_(a)) = d_a_1 d_a_2  d_a_N_1 and number of columns equal to d_c.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(Image: tensor unitary)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"A similar interpretation can be given to the basis transform on the right, by taking its adjoint. In this example, it has two different combinations of sectors (b) and (b), where both have a single fusion tree to c_1 as well as to c_2, and n_(b)=2, n_(b)=3.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(Image: tensor center_tensor)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The center matrix is the block diagonal matrix _c B_c  𝟙_c with diagonal blocks labeled by the coupled charge c, in this case it takes two values c_1 and c_2. Every single small square in between the dotted or dashed lines has size d_c  d_c and corresponds to a single element of B_c, tensored with the identity mathbb1_c. The B_c for a fixed c composed by smaller blocks t^c_(a_1a_N_1)alpha(b_1b_N_2)beta which are labeled by different fusion trees with the coupled sector c. The dashed horizontal lines indicate regions corresponding to different splitting trees, either because of different sectors (a_1  a_N₁) or different labels α within the same sector. Similarly, the dashed vertical lines define the border between regions of different fusion trees from the domain to c, either because of different sectors (b_1  b_N₂) or a different label β.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Note that we never explicitly store or act with the basis transforms on the left and the right. For composing tensor maps (i.e. multiplying them), these basis transforms just cancel, whereas for tensor factorizations they just go through trivially. They transform non-trivially when reshuffling the tensor indices, both within or between the domain and codomain. For this, however, we can completely rely on the manipulations of fusion trees to implicitly compute the effect of the basis transform and construct the new blocks B_c that result with respect to the new basis.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Hence, as before, we only store the diagonal blocks B_c of size (blockdim(codomain(t), c), blockdim(domain(t), c)) as a DenseMatrix, accessible via block(t, c). Within this matrix, there are regions of the form view(block(t, c), m₁:m₂, n₁:n₂) that correspond to the data t^c_(a_1  a_N₁)α (b_1  b_N₂)β associated with a pair of fusion trees X^(a_1  a_N₁)_cα and X^(b_1  b_N₂)_cβ, henceforth again denoted as f₁ and f₂, with f₁.coupled == f₂.coupled == c. The ranges where this subblock is living are managed within the tensor implementation, and these subblocks can be accessed via t[f₁,f₂], and is returned as a StridedArray of size n_a_1  n_a_2    n_a_N_1  n_b_1   n_b_N₂, or in code, (dim(V1, a1), dim(V2, a2), …, dim(VN₁, aN₁), dim(W1, b1), …, dim(WN₂, bN₂)).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"While the implementation does not distinguish between FusionStyle isa UniqueFusion or FusionStyle isa MultipleFusion, in the former case the fusion tree is completely characterized by the uncoupled sectors, and so the subblocks can also be accessed as t[a1, …, aN₁,b1', …, bN₂'].","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"When there is no symmetry at all, i.e. sectortype(t) == Trivial, t[] returns the raw tensor data as a StridedArray of size (dim(V1), …, dim(VN₁), dim(W1), …, dim(WN₂)), whereas block(t, Trivial()) returns the same data as a DenseMatrix of size (dim(V1) * … * dim(VN₁), dim(W1) * … * dim(WN₂)).","category":"page"},{"location":"man/tensors/#ss_tensor_construction","page":"Tensors and the TensorMap type","title":"Constructing tensor maps and accessing tensor data","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Having learned how a tensor is represented and stored, we can now discuss how to create tensors and tensor maps. From hereon, we focus purely on the interface rather than the implementation.","category":"page"},{"location":"man/tensors/#Random-and-uninitialized-tensor-maps","page":"Tensors and the TensorMap type","title":"Random and uninitialized tensor maps","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The most convenient set of constructors are those that construct  tensors or tensor maps with random or uninitialized data. They take the form","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TensorMap(f, codomain, domain)\nTensorMap(f, eltype::Type{<:Number}, codomain, domain)\nTensorMap(undef, codomain, domain)\nTensorMap(undef, eltype::Type{<:Number}, codomain, domain)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In the first form, f can be any function or object that is called with an argument of type Dims{2} = Tuple{Int,Int} and is such that f((m,n)) creates a DenseMatrix instance with size(f(m,n)) == (m,n). In the second form, f is called as f(eltype,(m,n)). Possibilities for f are randn and rand from Julia Base. TensorLabXD.jl provides randnormal and randuniform as an synonym for randn and rand, as well as the new function  randisometry, alternatively called randhaar, that creates a random isometric m × n matrix w satisfying w'*w ≈ I distributed according to the Haar measure (this requires m>= n). The third and fourth calling syntax use the UndefInitializer from Julia Base and generates a TensorMap with unitialized data, which could thus contain NaNs.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In all of these constructors, the last two arguments can be replaced by domain→codomain or codomain←domain, where the arrows are obtained as \\rightarrow+TAB and \\leftarrow+TAB and create a HomSpace as explained in the section on Spaces of morphisms.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Some examples:","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"t1 = TensorMap(randnormal, ℂ^2 ⊗ ℂ^3, ℂ^2)\nt2 = TensorMap(randisometry, Float32, ℂ^2 ⊗ ℂ^3 ← ℂ^2)\nt3 = TensorMap(undef, ℂ^2 → ℂ^2 ⊗ ℂ^3)\ndomain(t1) == domain(t2) == domain(t3)\ncodomain(t1) == codomain(t2) == codomain(t3)\ndisp(x) = show(IOContext(Core.stdout, :compact=>false), \"text/plain\", trunc.(x; digits = 3));\nt1[] |> disp\nblock(t1, Trivial()) |> disp\nreshape(t1[], dim(codomain(t1)), dim(domain(t1))) |> disp","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"All constructors can also be replaced by Tensor(..., codomain), in which case the domain is assumed to be the empty ProductSpace{S,0}(), which can easily be obtained as one(codomain). Indeed, the empty product space is the unit object of the monoidal category, equivalent to the field of scalars 𝕜, and thus the multiplicative identity (especially since * also acts as tensor product on vector spaces).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The matrices created by f are the matrices B_c discussed above, i.e. those returned by block(t, c). Only numerical matrices of type DenseMatrix are accepted, which in practice just means Julia's intrinsic Matrix{T} for some T<:Number. In the future, we will add support for CuMatrix from CuArrays.jl to harness GPU computing power, and maybe SharedArray from the Julia's SharedArrays standard library.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Support for static or sparse data is currently unavailable, and if it would be implemented, it would lead to new subtypes of AbstractTensorMap which are distinct from TensorMap. Future implementations of e.g. SparseTensorMap or StaticTensorMap could be useful. Furthermore, there could be specific implementations for tensors whose blocks are Diagonal.","category":"page"},{"location":"man/tensors/#Tensor-maps-from-existing-data","page":"Tensors and the TensorMap type","title":"Tensor maps from existing data","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"To create a TensorMap with existing data, one can use the aforementioned form but with the function f replaced with the actual data, i.e. TensorMap(data, codomain, domain).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Here, data can be of two types. It can be a dictionary (any Associative subtype) which has blocksectors c of type sectortype(codomain) as keys, and the corresponding matrix blocks as value, i.e. data[c] is some DenseMatrix of size (blockdim(codomain, c), blockdim(domain, c)). This is the form of how the data is stored within the TensorMap objects.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For those space types for which a TensorMap can be converted to a plain multidimensional array, the data can also be a general DenseArray, either of rank N₁+N₂ and with matching size (dims(codomain)..., dims(domain)...), or just as a DenseMatrix with size (dim(codomain), dim(domain)). This is true in particular if the sector type is Trivial, e.g. for CartesianSpace or ComplexSpace. Then the data array is just reshaped into matrix form and referred to as such in the resulting TensorMap instance. When spacetype is GradedSpace, the TensorMap constructor will try to reconstruct the tensor data such that the resulting tensor t satisfies data == convert(Array, t). This might not be possible, if the data does not respect the symmetry structure.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Some examples:","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"data = zeros(2,2,2,2)\n# encode the operator (σ_x * σ_x + σ_y * σ_y + σ_z * σ_z)/4\n# that is, the swap gate, which maps the last two indices on the first two in reversed order\n# also known as Heisenberg interaction between two spin 1/2 particles\ndata[1,2,2,1] = data[2,1,1,2] = 1/2\ndata[1,1,1,1] = data[2,2,2,2] = 1/4\ndata[1,2,1,2] = data[2,1,2,1] = -1/4\nV1 = ℂ^2 # generic qubit hilbert space\nt1 = TensorMap(data, V1 ⊗ V1, V1 ⊗ V1)\nV2 = SU2Space(1/2=>1) # hilbert space of an actual spin-1/2 particle, respecting symmetry\nt2 = TensorMap(data, V2 ⊗ V2, V2 ⊗ V2)\nV3 = U1Space(1/2=>1,-1/2=>1) # restricted space that only uses the `σ_z` rotation symmetry\nt3 = TensorMap(data, V3 ⊗ V3, V3 ⊗ V3)\nfor (c,b) in blocks(t3)\n    println(\"Data for block $c :\")\n    b |> disp\n    println()\nend","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Hence, we recognize that the Heisenberg interaction has eigenvalue -34 in the coupled spin zero sector (SUIrrep(0)), and eigenvalue +14 in the coupled spin 1 sector (SU2Irrep(1)). Using Irrep[U₁] instead, we observe that both coupled charge U1Irrep(+1) and U1Irrep(-1) have eigenvalue +14. The coupled charge U1Irrep(0) sector is two-dimensional, and has an eigenvalue +14 and an eigenvalue -34.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"To construct the proper data in more complicated cases, one has to know where to find each sector in the range 1:dim(V) of every index i with associated space V, as well as the internal structure of the representation space when the corresponding sector c has dim(c)>1, i.e. in the case of FusionStyle(c) isa MultipleFusion. Currently, the only non- abelian sectors are Irrep[SU₂] and Irrep[CU₁], for which the internal structure is the natural one.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"There are some tools available to facilate finding the proper range of sector c in space V, namely axes(V, c). This also works on a ProductSpace, with a tuple of sectors. An example","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"V = SU2Space(0=>3, 1=>2, 2=>1)\nP = V ⊗ V ⊗ V\naxes(P, (SU2Irrep(1), SU2Irrep(0), SU2Irrep(2)))","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Note that the length of the range is the degeneracy dimension of that sector, times the dimension of the internal representation space, i.e. the quantum dimension of that sector.","category":"page"},{"location":"man/tensors/#Constructing-similar-tensors","page":"Tensors and the TensorMap type","title":"Constructing similar tensors","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"A third way to construct a TensorMap instance is to use Base.similar, i.e.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"similar(t [, T::Type{<:Number}, codomain, domain])","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"where T is a possibly different eltype for the tensor data, and codomain and domain optionally define a new codomain and domain for the resulting tensor. By default, these values just take the value from the input tensor t. The result will be a new TensorMap instance, with undef data, but whose data is stored in the same subtype of DenseMatrix (e.g. Matrix or CuMatrix or ...) as t. In particular, this uses the methods storagetype(t) and TensorLabXD.similarstoragetype(t, T).","category":"page"},{"location":"man/tensors/#Special-purpose-constructors","page":"Tensors and the TensorMap type","title":"Special purpose constructors","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Some specific new tensors can be created by methods zero, one, id, isomorphism, unitary and isometry.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Tensor maps behave as vectors and can be added (if they have the same domain and codomain); zero(t) is the additive identity, i.e. a TensorMap instance where all entries are zero.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For a t::TensorMap with domain(t) == codomain(t), i.e. an endomorphism, one(t) creates the identity tensor, i.e. the identity under composition. As discussed in the section on linear algebra operations, we denote composition of tensor maps with the mutliplication operator *, such that one(t) is the multiplicative identity. Similarly, it can be created as id(V) with V the relevant vector space, e.g. one(t) == id(domain(t)). The identity tensor is currently represented with dense data, and one can use id(A::Type{<:DenseMatrix}, V) to specify the type of DenseMatrix (and its eltype), e.g. A = Matrix{Float64}.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"It often occurs that we want to construct a specific isomorphism between two spaces that are isomorphic but not equal, and for which there is no canonical choice. Hereto, one can use the method u = isomorphism([A::Type{<:DenseMatrix}, ] codomain, domain), which will explicitly check that the domain and codomain are isomorphic, and return an error otherwise. Again, an optional first argument can be given to specify the specific type of DenseMatrix that is currently used to store the rather trivial data of this tensor. If spacetype(u) <: EuclideanSpace, the same result can be obtained with the method u = unitary([A::Type{<:DenseMatrix}, ] codomain, domain). Note that reversing the domain and codomain yields the inverse morphism, which in the case of EuclideanSpace coincides with the adjoint morphism, i.e. isomorphism(A, domain, codomain) == adjoint(u) == inv(u), where inv and adjoint will be further discussed below.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"If two spaces V1 and V2 are such that V2 can be embedded in V1, i.e. there exists an inclusion with a left inverse, and they represent tensor products of some EuclideanSpace, the function w = isometry([A::Type{<:DenseMatrix}, ], V1, V2) creates one specific isometric embedding, such that adjoint(w)*w == id(V2) and w*adjoint(w) is some hermitian idempotent (a.k.a. orthogonal projector) acting on V1. An error will be thrown if such a map cannot be constructed for the given domain and codomain.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Let's conclude this section with some examples with GradedSpace.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"V1 = ℤ₂Space(0=>3,1=>2)\nV2 = ℤ₂Space(0=>2,1=>1)\n# First a `TensorMap{ℤ₂Space, 1, 1}`\nm = TensorMap(randn, V1, V2)\nconvert(Array, m) |> disp\n# compare with:\nblock(m, Irrep[ℤ₂](0)) |> disp\nblock(m, Irrep[ℤ₂](1)) |> disp\n# Now a `TensorMap{ℤ₂Space, 2, 2}`\nt = TensorMap(randn, V1 ⊗ V1, V2 ⊗ V2')\n(array = convert(Array, t)) |> disp\nd1 = dim(codomain(t))\nd2 = dim(domain(t))\n(matrix = reshape(array, d1, d2)) |> disp\n(u = reshape(convert(Array, unitary(codomain(t), fuse(codomain(t)))), d1, d1)) |> disp\n(v = reshape(convert(Array, unitary(domain(t), fuse(domain(t)))), d2, d2)) |> disp\nu'*u ≈ I ≈ v'*v\n(u'*matrix*v) |> disp\n# compare with:\nblock(t, Z2Irrep(0)) |> disp\nblock(t, Z2Irrep(1)) |> disp","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Here, we illustrated some additional concepts. Firstly, note that we convert a TensorMap to an Array. This only works when sectortype(t) supports fusiontensor, and in particular when BraidingStyle(sectortype(t)) == Bosonic(), e.g. the case of trivial tensors (the category mathbfVect) and group representations (the category mathbfRep_mathsfG, which can be interpreted as a subcategory of mathbfVect). Here, we are in this case with mathsfG = ℤ₂. For a TensorMap{S,1,1}, the blocks directly correspond to the diagonal blocks in the block diagonal structure of its representation as an Array, there is no basis transform in between. This is no longer the case for TensorMap{S,N₁,N₂} with different values of N₁ and N₂. Here, we use the operation fuse(V), which creates an ElementarySpace which is isomorphic to a given space V (of type ProductSpace or ElementarySpace). The specific map between those two spaces constructed using the specific method unitary implements precisely the basis change from the product basis to the coupled basis. In this case, for a group G with FusionStyle(Irrep[G]) isa UniqueFusion, it is a permutation matrix. Specifically choosing V equal to the codomain and domain of t, we can construct the explicit basis transforms that bring t into block diagonal form.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Let's repeat the same exercise for I = Irrep[SU₂], which has FusionStyle(I) isa MultipleFusion.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"V1 = SU₂Space(0=>2,1=>1)\nV2 = SU₂Space(0=>1,1=>1)\n# First a `TensorMap{SU₂Space, 1, 1}`\nm = TensorMap(randn, V1, V2)\nconvert(Array, m) |> disp\n# compare with:\nblock(m, Irrep[SU₂](0)) |> disp\nblock(m, Irrep[SU₂](1)) |> disp\n# Now a `TensorMap{SU₂Space, 2, 2}`\nt = TensorMap(randn, V1 ⊗ V1, V2 ⊗ V2')\n(array = convert(Array, t)) |> disp\nd1 = dim(codomain(t))\nd2 = dim(domain(t))\n(matrix = reshape(array, d1, d2)) |> disp\n(u = reshape(convert(Array, unitary(codomain(t), fuse(codomain(t)))), d1, d1)) |> disp\n(v = reshape(convert(Array, unitary(domain(t), fuse(domain(t)))), d2, d2)) |> disp\nu'*u ≈ I ≈ v'*v\n(u'*matrix*v) |> disp\n# compare with:\nblock(t, SU2Irrep(0)) |> disp\nblock(t, SU2Irrep(1)) |> disp\nblock(t, SU2Irrep(2)) |> disp","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Note that the basis transforms u and v are no longer permutation matrices, but are still unitary. Note that they render the tensor block diagonal, but that now every element of the diagonal blocks labeled by c comes itself in a tensor product with an identity matrix of size dim(c), i.e. dim(SU2Irrep(1)) = 3 and dim(SU2Irrep(2)) = 5.","category":"page"},{"location":"man/tensors/#ss_tensor_properties","page":"Tensors and the TensorMap type","title":"Tensor properties","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Given a t::AbstractTensorMap{S,N₁,N₂}, there are various methods to query its properties. The most important are codomain(t) and domain(t). The space(t) gives the corresponding HomSpace. We can also query space(t, i), the space associated with the ith index. For i ∈ 1:N₁, this corresponds to codomain(t, i) = codomain(t)[i]. For i ∈ (N₁+1:N₁+N₂), this corresponds to dual(domain(t, i-N₁)) = dual(domain(t)[i-N₁]).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The total number of indices, i.e. N₁+N₂, is given by numind(t), with N₁ == numout(t) and N₂ == numin(t), the number of outgoing and incoming indices. There are also the unexported methods TensorLabXD.codomainind(t) and TensorLabXD.domainind(t) which return the tuples (1, 2, …, N₁) and (N₁+1, …, N₁+N₂), and are useful for internal purposes. The type parameter S<:ElementarySpace can be obtained as spacetype(t); the corresponding sector can directly obtained as sectortype(t) and is Trivial when S != GradedSpace. The underlying field scalars of S can also directly be obtained as field(t). This is different from eltype(t), which returns the type of Number in the tensor data, i.e. the type parameter T in the (subtype of) DenseMatrix{T} in which the matrix blocks are stored. Note that during construction, a (one-time) warning is printed if !(T ⊂ field(S)). The specific DenseMatrix{T} subtype in which the tensor data is stored is obtained as storagetype(t). Each of the methods numind, numout, numin, TensorLabXD.codomainind, TensorLabXD.domainind, spacetype, sectortype, field, eltype and storagetype work in the type domain as well, i.e. they are encoded in typeof(t).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"There are methods to probe the data. blocksectors(t) returns an iterator over the different coupled sectors that can be obtained from fusing the uncoupled sectors available in the domain, but they must also be obtained from fusing the uncoupled sectors available in the codomain (i.e. it is the intersection of both blocksectors(codomain(t)) and blocksectors(domain(t))). For a specific sector c ∈ blocksectors(t), block(t, c) returns the corresponding data. Both are obtained together with blocks(t), which returns an iterator over the pairs c=>block(t, c). There is fusiontrees(t) which returns an iterator over splitting-fusion tree pairs (f₁,f₂), for which the corresponding data is given by t[f₁,f₂] (i.e. using Base.getindex).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Let's again illustrate these methods with an example, continuing with the tensor t from the previous example","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"typeof(t)\ncodomain(t)\ndomain(t)\nspace(t,1)\nspace(t,2)\nspace(t,3)\nspace(t,4)\nnumind(t)\nnumout(t)\nnumin(t)\nspacetype(t)\nsectortype(t)\nfield(t)\neltype(t)\nstoragetype(t)\nblocksectors(t)\nblocks(t)\nblock(t, first(blocksectors(t)))\nfusiontrees(t)\nf1, f2 = first(fusiontrees(t))\nt[f1,f2]","category":"page"},{"location":"man/tensors/#ss_tensor_readwrite","page":"Tensors and the TensorMap type","title":"Reading and writing tensors: Dict conversion","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"There are no custom or dedicated methods for reading, writing or storing TensorMaps, however, there is the possibility to convert a t::AbstractTensorMap into a Dict, simply as convert(Dict, t). The backward conversion convert(TensorMap, dict) will return a tensor that is equal to t, i.e. t == convert(TensorMap, convert(Dict, t)).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"This conversion relies on that the string represenation of objects such as VectorSpace, FusionTree or Sector should be such that it represents valid code to recreate the object. Hence, we store information about the domain and codomain of the tensor, and the sector associated with each data block, as a String obtained with repr. This provides the flexibility to still change the internal structure of such objects, without this breaking the ability to load older data files. The resulting dictionary can then be stored using any of the provided Julia packages such as JLD.jl, JLD2.jl, BSON.jl, JSON.jl, ...","category":"page"},{"location":"man/tensors/#ss_tensor_linalg","page":"Tensors and the TensorMap type","title":"Vector space and linear algebra operations","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"AbstractTensorMap instances t represent linear maps, i.e. homomorphisms in a 𝕜-linear category, just like matrices. To a large extent, they follow the interface of Matrix in Julia's LinearAlgebra standard library. Many methods from LinearAlgebra are (re)exported by TensorLabXD.jl, and can then us be used without using LinearAlgebra explicitly. In all of the following methods, the implementation acts directly on the underlying matrix blocks and never needs to perform any basis transforms.","category":"page"},{"location":"man/tensors/#Copy-and-fill:","page":"Tensors and the TensorMap type","title":"Copy and fill:","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Base.copy!(tdst::AbstractTensorMap, tsrc::AbstractTensorMap) # overwrite `tdst` as `tsrc`\nBase.copy(t::AbstractTensorMap) # return new tensormap = t\nBase.fill!(t::AbstractTensorMap, value::Number) # overwrite `t` with all data = value","category":"page"},{"location":"man/tensors/#Adjoint:","page":"Tensors and the TensorMap type","title":"Adjoint:","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For instances t::AbstractEuclideanTensorMap there is associated an adjoint operation, given by adjoint(t) or simply t', such that domain(t') == codomain(t) and codomain(t') == domain(t). Note that for an instance t::TensorMap{S,N₁,N₂}, t' is stored in a wrapper called AdjointTensorMap{S,N₂,N₁}, which is another subtype of AbstractTensorMap. Index i of t appears in t' at index position j = TensorLabXD.adjointtensorindex(t, i). There is also a plural TensorLabXD.adjointtensorindices to convert multiple indices at once. Since the adjoint interchanges domain and codomain, we have space(t', j) == space(t, i)'.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"LinearAlgebra.adjoint!(tdst::AbstractEuclideanTensorMap,\n                        tsrc::AbstractEuclideanTensorMap) # overwrite tdst as adjoint(tsrc)","category":"page"},{"location":"man/tensors/#Multiplications-and-linear-combinations-of-Tensor-maps:","page":"Tensors and the TensorMap type","title":"Multiplications and linear combinations of Tensor maps:","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The AbstractTensorMap instances behave themselves as vectors, i.e., 𝕜-linear and so they can be multiplied by scalars and, if they live in the same space, i.e. have the same domain and codomain, they can be added to each other.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The AbstractTensorMap instances can be composed, provided the domain of the first object coincides with the codomain of the second. Composing tensor maps uses the regular multiplication symbol as in t = t1*t2, which is also used for matrix multiplication.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Base.:-(t::AbstractTensorMap) # return new tensormap = -t\nBase.:+(t1::AbstractTensorMap, t2::AbstractTensorMap) # return new tensormap = t1+t2\nBase.:-(t1::AbstractTensorMap, t2::AbstractTensorMap) # return new tensormap = t1-t2\nLinearAlgebra.mul!(t1::AbstractTensorMap, t2::AbstractTensorMap, α::Number) # overwrite t1 as t2*α\nLinearAlgebra.mul!(t1::AbstractTensorMap, α::Number, t2::AbstractTensorMap) # overwrite t1 as α*t2\nLinearAlgebra.mul!(tC::AbstractTensorMap, tA::AbstractTensorMap, tB::AbstractTensorMap,\n                        α = true, β = false) # overwrite tC as tA*tB*α + tC*β\nBase.:*(t::AbstractTensorMap, α::Number) # return new tensormap = t*α\nBase.:*(α::Number, t::AbstractTensorMap) # return new tensormap = α*t\nBase.:*(t1::AbstractTensorMap, t2::AbstractTensorMap) # return new tensormap = t1*t2\nLinearAlgebra.rmul!(t::AbstractTensorMap, α::Number) # overwrite t as t*α\nLinearAlgebra.lmul!(α::Number, t::AbstractTensorMap) # overwrite t as α*t\nLinearAlgebra.axpy!(α::Number, t1::AbstractTensorMap, t2::AbstractTensorMap) # overwrite t2 as t1*α+t2\nLinearAlgebra.axpby!(α::Number, t1::AbstractTensorMap, β::Number, t2::AbstractTensorMap) # overwrite t2 as t1*α+t2*β\nBase.:^(t::AbstractTensorMap, p::Integer) # return new tensormap = t*t*...*t (p times)\nBase.:/(t::AbstractTensorMap, α::Number) # return new tensormap = t/α\nBase.:\\(α::Number, t::AbstractTensorMap) # return new tensormap = α\\t","category":"page"},{"location":"man/tensors/#Trace-and-exp:","page":"Tensors and the TensorMap type","title":"Trace and exp:","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For case of endomorphisms t, we can compute the trace via tr(t) and exponentiate them using exp(t), or if the contents of t can be destroyed in the process, exp!(t).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"LinearAlgebra.tr(t::AbstractTensorMap) # return the trace of all data blocks\nexp!(t::TensorMap) # overwrite `t` as `exp(t)`\nBase.exp(t::AbstractTensorMap) # return new tensormap = exp(t)","category":"page"},{"location":"man/tensors/#Invert-a-tensor-map:","page":"Tensors and the TensorMap type","title":"Invert a tensor map:","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"We can invert a tensor map using inv(t) if the domain and codomain are isomorphic, which can be checked by fuse(codomain(t)) == fuse(domain(t)). If the inverse is composed with another tensor t2, we can use the syntax t1\\t2 or t2/t1. This syntax also accepts instances t1 whose domain and codomain are not isomorphic, and then amounts to pinv(t1), the Moore-Penrose pseudoinverse. This,   however, is only really justified as minimizing the least squares problem if spacetype(t) <: EuclideanSpace.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Base.inv(t::AbstractTensorMap) # return new tensormap = inv(t)\nLinearAlgebra.pinv(t::AbstractTensorMap; kwargs...) # return new tensormap = pinv(t)\nBase.:(\\)(t1::AbstractTensorMap, t2::AbstractTensorMap) # return X such that t1*X = t2\nBase.:(/)(t1::AbstractTensorMap, t2::AbstractTensorMap) # return X such that t1 = X*t2\nLinearAlgebra.sylvester(A::AbstractTensorMap, B::AbstractTensorMap,\n                        C::AbstractTensorMap) # return X such that A*X+X*B+C=0","category":"page"},{"location":"man/tensors/#Dot,-norm-and-normalize:","page":"Tensors and the TensorMap type","title":"Dot, norm and normalize:","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For t::AbstractTensorMap{S} where S<:EuclideanSpace, henceforth referred to as a (Abstract)EuclideanTensorMap, we can compute norm(t), and for two such instances, the inner product dot(t1, t2), provided t1 and t2 have the same domain and codomain.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For (Abstract)EuclideanTensorMap, normalize(t) and normalize!(t) return a scaled version of t with unit norm. These operations should also exist for S<:InnerProductSpace, but requires an interface for defining a custom inner product in these spaces. Currently, there is no concrete subtype of InnerProductSpace that is not a subtype of EuclideanSpace. The CartesianSpace, ComplexSpace and GradedSpace are all subtypes of EuclideanSpace.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"LinearAlgebra.dot(t1::AbstractEuclideanTensorMap, t2::AbstractEuclideanTensorMap) # return the elementwise dot product\nLinearAlgebra.norm(t::AbstractEuclideanTensorMap, p::Real = 2) # return the p-norm\nLinearAlgebra.normalize!(t::AbstractTensorMap, p::Real = 2) # overwrite `t` with normalized one\nLinearAlgebra.normalize(t::AbstractTensorMap, p::Real = 2) # return new tensormap = normalize(t)","category":"page"},{"location":"man/tensors/#Equal-and-approximate:","page":"Tensors and the TensorMap type","title":"Equal and approximate:","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"AbstractTensorMap instances can be tested for exact (t1 == t2) or approximate (t1 ≈ t2) equality, though the latter requires norm can be computed.","category":"page"},{"location":"man/tensors/#Additive-and-multiplicative-identity,-and-morphisms:","page":"Tensors and the TensorMap type","title":"Additive and multiplicative identity, and morphisms:","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The additive identity can be created by zero(t), which produces a zero tensor with the same domain and codomain as t.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"When tensor map instances are endomorphisms, i.e. they have the same domain and codomain, there is a multiplicative identity which can be obtained as one(t) or    one!(t), where the latter overwrites the contents of t. The multiplicative identity on a space V can also be obtained using id(A, V), such that for a general homomorphism t, we have t == id(codomain(t))*t == t*id(domain(t)).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Base.zero(t::AbstractTensorMap) # return new tensormap with all 0\none!(t::AbstractTensorMap) # overwrite t as identity matrices\nBase.one(t::AbstractTensorMap) # return new tensormap with identity matrices\nid([A::Type{<:DenseMatrix} = Matrix{Float64},] space::VectorSpace) # return new identity endomorphism on space with type A\nisomorphism(::Type{A}, cod::ProductSpace, dom::ProductSpace) where {A<:DenseMatrix} # return new isomorphisms\nunitary(cod::EuclideanTensorSpace, dom::EuclideanTensorSpace) # return new unitary isomorphism\nisometry(::Type{A}, cod::ProductSpace{S},\n            dom::ProductSpace{S}) where {A<:DenseMatrix, S<:EuclideanSpace} # return new isometry","category":"page"},{"location":"man/tensors/#Tensor-and-deligne-product:","page":"Tensors and the TensorMap type","title":"Tensor and deligne product:","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The tensor product of two TensorMap instances t1 and t2 is obtained as t1 ⊗ t2 and results in a new TensorMap with codomain(t1⊗t2) = codomain(t1) ⊗ codomain(t2)    and domain(t1⊗t2) = domain(t1) ⊗ domain(t2).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"⊗(t1::AbstractTensorMap{S}, t2::AbstractTensorMap{S}) where S # return new tensormap = t1⊗t2\n⊠(t1::AbstractTensorMap{<:EuclideanSpace{ℂ}}, t2::AbstractTensorMap{<:EuclideanSpace{ℂ}})","category":"page"},{"location":"man/tensors/#catdomain-and-catcodomain:","page":"Tensors and the TensorMap type","title":"catdomain and catcodomain:","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"If we have two TensorMap{S,N,1} instances t1 and t2 with the same codomain, we     can combine them in a way that is analogous to hcat, i.e. we stack them such that the new tensor catdomain(t1, t2) has also the same codomain, but has a domain which is     domain(t1) ⊕ domain(t2).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Similarly, if t1 and t2 are of type TensorMap{S,1,N} and have the same domain, the operation catcodomain(t1, t2) results in a new tensor with the same domain and a   codomain given by codomain(t1) ⊕ codomain(t2), which is the analogy of vcat. Note    that direct sum only makes sense between ElementarySpace objects, i.e. there is no     way to give a tensor product meaning to a direct sum of tensor product spaces.","category":"page"},{"location":"man/tensors/#Other-useful-functions:","page":"Tensors and the TensorMap type","title":"Other useful functions:","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":":cos, :sin, :tan, :cot, :cosh, :sinh, :tanh, :coth, :atan, :acot, :asinh\n:sqrt, :log, :asin, :acos, :acosh, :atanh, :acoth","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Time for some more examples:","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"t == t + zero(t) == t*id(domain(t)) == id(codomain(t))*t\nt2 = TensorMap(randn, ComplexF64, codomain(t), domain(t));\ndot(t2, t)\ntr(t2'*t)\ndot(t2, t) ≈ dot(t', t2')\ndot(t2, t2)\nnorm(t2)^2\nt3 = copyto!(similar(t, ComplexF64), t);\nt3 == t\nrmul!(t3, 0.8);\nt3 ≈ 0.8*t\naxpby!(0.5, t2, 1.3im, t3);\nt3 ≈ 0.5 * t2  +  0.8 * 1.3im * t\nt4 = TensorMap(randn, fuse(codomain(t)), codomain(t));\nt5 = TensorMap(undef, fuse(codomain(t)), domain(t));\nmul!(t5, t4, t) == t4*t\ninv(t4) * t4 ≈ id(codomain(t))\nt4 * inv(t4) ≈ id(fuse(codomain(t)))\nt4 \\ (t4 * t) ≈ t\nt6 = TensorMap(randn, ComplexF64, V1, codomain(t));\nnumout(t4) == numout(t6) == 1\nt7 = catcodomain(t4, t6);\nforeach(println, (codomain(t4), codomain(t6), codomain(t7)))\nnorm(t7) ≈ sqrt(norm(t4)^2 + norm(t6)^2)\nt8 = t4 ⊗ t6;\nforeach(println, (codomain(t4), codomain(t6), codomain(t8)))\nforeach(println, (domain(t4), domain(t6), domain(t8)))\nnorm(t8) ≈ norm(t4)*norm(t6)","category":"page"},{"location":"man/tensors/#Planar-index-manipulations","page":"Tensors and the TensorMap type","title":"Planar index manipulations","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In many cases, the bipartition of tensor indices (i.e. ElementarySpace instances) between the codomain and domain is not fixed throughout the different operations that need to be performed on that tensor map, i.e. we want to use the duality to move spaces from domain to codomain and vice versa. Furthermore, we want to use the braiding to reshuffle the order of the indices.","category":"page"},{"location":"man/tensors/#Braiding-index-manipulations","page":"Tensors and the TensorMap type","title":"Braiding index manipulations","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"braid(t::AbstractTensorMap{S,N₁,N₂}, levels::NTuple{N₁+N₂,Int},\n        p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int})","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"and","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"permute(t::AbstractTensorMap{S,N₁,N₂},\n        p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int}; copy = false)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"both of which return an instance of AbstractTensorMap{S,N₁′,N₂′}.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In these methods, p1 and p2 specify which of the original tensor indices ranging from 1 to N₁+N₂ make up the new codomain (with N₁′ spaces) and new domain (with N₂′ spaces). Hence, (p1..., p2...) should be a valid permutation of 1:(N₁+N₂). Note that, throughout TensorLabXD.jl, permutations are always specified using tuples of Ints, for reasons of type stability. For braid, we also need to specify levels or depths for each of the indices of the original tensor, which determine whether indices will braid over or underneath each other (use the braiding or its inverse). We refer to the section on manipulating fusion trees for more details.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"When BraidingStyle(sectortype(t)) isa SymmetricBraiding, we can use the simpler interface of permute, which does not require the argument levels. permute accepts a keyword argument copy. When copy == true, the result will be a tensor with newly allocated data that can independently be modified from that of the input tensor t. When copy takes the default value false, permute can try to return the result in a way that it shares its data with the input tensor t, though this is only possible in specific cases (e.g. when sectortype(S) == Trivial and (p1..., p2...) = (1:(N₁+N₂)...)).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Both braid and permute come in a version where the result is stored in an already existing tensor, i.e. braid!(tdst, tsrc, levels, p1, p2) and permute!(tdst, tsrc, p1, p2).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Another operation that belongs und index manipulations is taking the transpose of a tensor, i.e. LinearAlgebra.transpose(t) and LinearAlgebra.transpose!(tdst, tsrc), both of which are reexported by TensorLabXD.jl. Note that transpose(t) is not simply equal to reshuffling domain and codomain with braid(t, (1:(N₁+N₂)...), reverse(domainind(tsrc)), reverse(codomainind(tsrc)))). Indeed, the graphical representation (where we draw the codomain and domain as a single object), makes clear that this introduces an additional (inverse) twist, which is then compensated in the transpose implementation.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(Image: transpose)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In categorical language, the reason for this extra twist is that we use the left coevaluation η, but the right evaluation tildeϵ, when repartitioning the indices between domain and codomain.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"There are a number of other index related manipulations. We can apply a twist (or inverse twist) to one of the tensor map indices via twist(t, i; inv = false) or twist!(t, i; inv = false). Note that the latter method does not store the result in a new destination tensor, but just modifies the tensor t in place. Twisting several indices simultaneously can be obtained by using the defining property","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"θ_VW = τ_WV  (θ_W  θ_V)  τ_VW = (θ_V  θ_W)  τ_WV  τ_VW","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"but is currently not implemented explicitly.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For all sector types I with BraidingStyle(I) == Bosonic(), all twists are 1 and thus have no effect. Let us start with some examples, in which we illustrate that, albeit permute might act highly non-trivial on the fusion trees and on the corresponding data, after conversion to a regular Array (when possible), it just acts like permutedims","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"domain(t) → codomain(t)\nta = convert(Array, t);\nt′ = permute(t, (1,2,3,4));\ndomain(t′) → codomain(t′)\nconvert(Array, t′) ≈ ta\nt′′ = permute(t, (4,2,3),(1,));\ndomain(t′′) → codomain(t′′)\nconvert(Array, t′′) ≈ permutedims(ta, (4,2,3,1))\nm\ntranspose(m)\nconvert(Array, transpose(t)) ≈ permutedims(ta,(4,3,2,1))\ndot(t2, t) ≈ dot(transpose(t2), transpose(t))\ntranspose(transpose(t)) ≈ t\ntwist(t, 3) ≈ t\n# as twist acts trivially for\nBraidingStyle(sectortype(t))","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Note that transpose acts like one would expect on a TensorMap{S,1,1}. On a TensorMap{S,N₁,N₂}, because transpose replaces the codomain with the dual of the domain, which has its tensor product operation reversed, this in the end amounts in a complete reversal of all tensor indices when representing it as a plain mutli-dimensional Array. Also, note that we have not defined the conjugation of TensorMap instances. One definition that one could think of is conj(t) = adjoint(transpose(t)). However note that codomain(adjoint(tranpose(t))) == domain(transpose(t)) == dual(codomain(t)) and similarly domain(adjoint(tranpose(t))) == dual(domain(t)), where dual of a ProductSpace is composed of the dual of the ElementarySpace instances, in reverse order of tensor product. This might be very confusing, and as such we leave tensor conjugation undefined. However, note that we have a conjugation syntax within the context of tensor contractions.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"To show the effect of twist, we now consider a type of sector I for which BraidingStyle{I} != Bosonic(). In particular, we use FibonacciAnyon. We cannot convert the resulting TensorMap to an Array, so we have to rely on indirect tests to verify our results.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"V1 = GradedSpace{FibonacciAnyon}(:I=>3,:τ=>2)\nV2 = GradedSpace{FibonacciAnyon}(:I=>2,:τ=>1)\nm = TensorMap(randn, Float32, V1, V2)\ntranspose(m)\ntwist(braid(m, (1,2), (2,), (1,)), 1)\nt1 = TensorMap(randn, V1*V2', V2*V1);\nt2 = TensorMap(randn, ComplexF64, V1*V2', V2*V1);\ndot(t1, t2) ≈ dot(transpose(t1), transpose(t2))\ntranspose(transpose(t1)) ≈ t1","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"A final operation that one might expect in this section is to fuse or join indices, and its inverse, to split a given index into two or more indices. For a plain tensor (i.e. with sectortype(t) == Trivial) amount to the equivalent of reshape on the multidimensional data. However, this represents only one possibility, as there is no canonically unique way to embed the tensor product of two spaces V₁ ⊗ V₂ in a new space V = fuse(V₁⊗V₂). Such a mapping can always be accompagnied by a basis transform. However, one particular choice is created by the function isomorphism, or for EuclideanSpace spaces, unitary. Hence, we can join or fuse two indices of a tensor by first constructing u = unitary(fuse(space(t, i) ⊗ space(t, j)), space(t, i) ⊗ space(t, j)) and then contracting this map with indices i and j of t, as explained in the section on contracting tensors. Note, however, that a typical algorithm is not expected to often need to fuse and split indices, as e.g. tensor factorizations can easily be applied without needing to reshape or fuse indices first, as explained in the next section.","category":"page"},{"location":"man/tensors/#ss_tensor_factorization","page":"Tensors and the TensorMap type","title":"Tensor factorizations","text":"","category":"section"},{"location":"man/tensors/#Eigenvalue-decomposition","page":"Tensors and the TensorMap type","title":"Eigenvalue decomposition","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"As tensors are linear maps, they have various kinds of factorizations. Endomorphism, i.e. tensor maps t with codomain(t) == domain(t), have an eigenvalue decomposition. For this, we overload both LinearAlgebra.eigen(t; kwargs...) and LinearAlgebra.eigen!(t; kwargs...), where the latter destroys t in the process. The keyword arguments are the same that are accepted by LinearAlgebra.eigen(!) for matrices. The result is returned as D, V = eigen(t), such that t*V ≈ V*D. For given t::TensorMap{S,N,N}, V is a TensorMap{S,N,1}, whose codomain corresponds to that of t, but whose domain is a single space S (or more correctly a ProductSpace{S,1}), that corresponds to fuse(codomain(t)). The eigenvalues are encoded in D, a TensorMap{S,1,1}, whose domain and codomain correspond to the domain of V. Indeed, we cannot reasonably associate a tensor product structure with the different eigenvalues. Note that D stores the eigenvalues on the diagonal of a (collection of) DenseMatrix instance(s), as there is currently no dedicated DiagonalTensorMap or diagonal storage support.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"We also define LinearAlgebra.ishermitian(t), which can only return true for instances of AbstractEuclideanTensorMap. In all other cases, as the inner product is not defined, there is no notion of hermiticity (i.e. we are not working in a †-category). For instances of EuclideanTensorMap, we also define and export the routines eigh and eigh!, which compute the eigenvalue decomposition under the guarantee (not checked) that the map is hermitian. Hence, eigenvalues will be real and V will be unitary with eltype(V) == eltype(t). We also define and export eig and eig!, which similarly assume that the TensorMap is not hermitian (hence this does not require EuclideanTensorMap), and always returns complex values eigenvalues and eigenvectors. Like for matrices, LinearAlgebra.eigen is type unstable and checks hermiticity at run-time, then falling back to either eig or eigh.","category":"page"},{"location":"man/tensors/#Orthogonal-factorizations","page":"Tensors and the TensorMap type","title":"Orthogonal factorizations","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Other factorizations that are provided by TensorLabXD.jl are orthogonal or unitary in nature, and thus always require a AbstractEuclideanTensorMap. However, they don't require equal domain and codomain. Let us first discuss the singular value decomposition, for which we define and export the methods tsvd and tsvd! (where as always, the latter destroys the input).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"U, Σ, Vʰ, ϵ = tsvd(t; trunc = notrunc(), p::Real = 2,\n                        alg::OrthogonalFactorizationAlgorithm = SDD())","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"This computes a (possibly truncated) singular value decomposition of t::TensorMap{S,N₁,N₂} (with S<:EuclideanSpace), such that norm(t - U*Σ*Vʰ) ≈ ϵ, where U::TensorMap{S,N₁,1}, S::TensorMap{S,1,1}, Vʰ::TensorMap{S,1,N₂} and ϵ::Real. U is an isometry, i.e. U'*U approximates the identity, whereas U*U' is an idempotent (squares to itself). The same holds for adjoint(Vʰ). The domain of U equals the domain and codomain of Σ and the codomain of Vʰ. In the case of trunc = notrunc() (default value, see below), this space is given by min(fuse(codomain(t)), fuse(domain(t))). The singular values are contained in Σ and are stored on the diagonal of a (collection of) DenseMatrix instance(s), similar to the eigenvalues before.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The keyword argument trunc provides a way to control the truncation, and is connected to the keyword argument p. The default value notrunc() implies no truncation, and thus ϵ = 0. Other valid options are","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"truncerr(η::Real): truncates such that the p-norm of the truncated singular values   is smaller than η times the p-norm of all singular values;\ntruncdim(χ::Integer): finds the optimal truncation such that the equivalent total   dimension of the internal vector space is no larger than χ;\ntruncspace(W): truncates such that the dimension of the internal vector space is   smaller than that of W in any sector, i.e. with   W₀ = min(fuse(codomain(t)), fuse(domain(t))) this option will result in   domain(U) == domain(Σ) == codomain(Σ) == codomain(Vᵈ) == min(W, W₀);\ntrunbelow(η::Real): truncates such that every singular value is larger then η; this   is different from truncerr(η) with p = Inf because it works in absolute rather than   relative values.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Furthermore, the alg keyword can be either SVD() or SDD() (default), which corresponds to two different algorithms in LAPACK to compute singular value decompositions. The default value SDD() uses a divide-and-conquer algorithm and is typically the fastest, but can loose some accuracy. The SVD() method uses a QR-iteration scheme and can be more accurate, but is typically slower. Since Julia 1.3, these two algorithms are also available in the LinearAlgebra standard library, where they are specified as LinearAlgebra.DivideAndConquer() and LinearAlgebra.QRIteration().","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Note that we defined the new method tsvd (truncated or tensor singular value decomposition), rather than overloading LinearAlgebra.svd. We (will) also support LinearAlgebra.svd(t) as alternative for tsvd(t; trunc = notrunc()), but note that the return values are then given by U, Σ, V = svd(t) with V = adjoint(Vʰ).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"We also define the following pair of orthogonal factorization algorithms, which are useful when one is not interested in truncating a tensor or knowing the singular values, but only in its image or coimage.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Q, R = leftorth(t; alg::OrthogonalFactorizationAlgorithm = QRpos(), kwargs...):   this produces an isometry Q::TensorMap{S,N₁,1} (i.e. Q'*Q approximates the identity,   Q*Q' is an idempotent, i.e. squares to itself) and a general tensor map   R::TensorMap{1,N₂}, such that t ≈ Q*R. Here, the domain of Q and thus codomain of   R is a single vector space of type S that is typically given by   min(fuse(codomain(t)), fuse(domain(t))).\nThe underlying algorithm used to compute this decomposition can be chosen among QR(),   QRpos(), QL(), QLpos(), SVD(), SDD(), Polar(). QR() uses the underlying   qr decomposition from LinearAlgebra, while QRpos() (the default) adds a correction   to that to make sure that the diagonal elements of R are positive.   Both result in upper triangular R, which are square when codomain(t) ≾ domain(t)   and wide otherwise. QL() and QLpos() similarly result in a lower triangular   matrices in R, but only work in the former case, i.e. codomain(t) ≾ domain(t),   which amounts to blockdim(codomain(t), c) >= blockdim(domain(t), c) for all   c ∈ blocksectors(t).\nOne can also use alg = SVD() or alg = SDD(), with extra keywords to control the   absolute (atol) or relative (rtol) tolerance. We then set Q=U and R=Σ*Vʰ from   the corresponding singular value decomposition, where only these singular values   σ >= max(atol, norm(t)*rtol) (and corresponding singular vectors in U) are kept.   More finegrained control on the chosen singular values can be obtained with tsvd and   its trunc keyword.\nFinally, Polar() sets Q=U*Vʰ and R = (Vʰ)'*Σ*Vʰ, such that R is positive   definite; in this case SDD() is used to actually compute the singular value   decomposition and no atol or rtol can be provided.\nL, Q = rightorth(t; alg::OrthogonalFactorizationAlgorithm = QRpos()):   this produces a general tensor map L::TensorMap{S,N₁,1} and the adjoint of an isometry   Q::TensorMap{S,1,N₂}, such that t ≈ L*Q. Here, the domain of L and thus codomain   of Q is a single vector space of type S that is typically given by   min(fuse(codomain(t)), fuse(domain(t))).\nThe underlying algorithm used to compute this decomposition can be chosen among LQ(),   LQpos(), RQ(), RQpos(), SVD(), SDD(), Polar(). LQ() uses the underlying   qr decomposition from LinearAlgebra on the transposed data, and leads to lower   triangular matrices in L; LQpos() makes sure the diagonal elements are   positive. The matrices L are square when codomain(t) ≿ domain(t) and tall otherwise.   Similarly, RQ() and RQpos() result in upper triangular matrices in L, but only   works if codomain(t) ≿ domain(t), i.e. when   blockdim(codomain(t), c) <= blockdim(domain(t), c) for all c ∈ blocksectors(t).\nOne can also use alg = SVD() or alg = SDD(), with extra keywords to control the   absolute (atol) or relative (rtol) tolerance. We then set L=U*Σ and Q=Vʰ from   the corresponding singular value decomposition, where only these singular values   σ >= max(atol, norm(t)*rtol) (and corresponding singular vectors in Vʰ) are kept.   More finegrained control on the chosen singular values can be obtained with tsvd and   its trunc keyword.\nFinally, Polar() sets L = U*Σ*U' and Q=U*Vʰ, such that L is positive definite;   in this case SDD() is used to actually compute the singular value decomposition and no   atol or rtol can be provided.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Furthermore, we can compute an orthonormal basis for the orthogonal complement of the image and of the co-image (i.e. the kernel) with the following methods:","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"N = leftnull(t; alg::OrthogonalFactorizationAlgorithm = QR(), kwargs...):   returns an isometric TensorMap{S,N₁,1} (i.e. N'*N approximates the identity) such   that N'*t is approximately zero.\nHere, alg can be QR() (QRpos() acts identically in this case), which assumes that   t is full rank in all of its blocks and only returns an orthonormal basis for the   missing columns.\nIf this is not the case, one can also use alg = SVD() or alg = SDD(), with extra   keywords to control the absolute (atol) or relative (rtol) tolerance. We then   construct N from the left singular vectors corresponding to singular values   σ < max(atol, norm(t)*rtol).\nN = rightnull(t; alg::OrthogonalFactorizationAlgorithm = QR(), kwargs...):   returns a TensorMap{S,1,N₂} with isometric adjoint (i.e. N*N' approximates the   identity) such that t*N' is approximately zero.\nHere, alg can be LQ() (LQpos() acts identically in this case), which assumes that   t is full rank in all of its blocks and only returns an orthonormal basis for the   missing rows.\nIf this is not the case, one can also use alg = SVD() or alg = SDD(), with extra   keywords to control the absolute (atol) or relative (rtol) tolerance. We then   construct N from the right singular vectors corresponding to singular values   σ < max(atol, norm(t)*rtol).","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Note that the methods leftorth, rightorth, leftnull and rightnull also come in a form with exclamation mark, i.e. leftorth!, rightorth!, leftnull! and rightnull!, which destroy the input tensor t.","category":"page"},{"location":"man/tensors/#Factorizations-for-custom-index-bipartions","page":"Tensors and the TensorMap type","title":"Factorizations for custom index bipartions","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Finally, note that each of the factorizations take a single argument, the tensor map t, and a number of keyword arguments. They perform the factorization according to the given codomain and domain of the tensor map. In many cases, we want to perform the factorization according to a different bipartition of the indices. When BraidingStyle(sectortype(t)) isa SymmetricBraiding, we can immediately specify an alternative bipartition of the indices of t in all of these methods, in the form","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"factorize(t::AbstracTensorMap, pleft::NTuple{N₁′,Int}, pright::NTuple{N₂′,Int}; kwargs...)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"where pleft will be the indices in the codomain of the new tensor map, and pright the indices of the domain. Here, factorize is any of the methods LinearAlgebra.eigen, eig, eigh, tsvd, LinearAlgebra.svd, leftorth, rightorth, leftnull and rightnull. This signature does not allow for the exclamation mark, because it amounts to","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"factorize!(permute(t, pleft, pright; copy = true); kwargs...)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"where permute was introduced and discussed in the previous section. When the braiding is not symmetric, the user should manually apply braid to bring the tensor map in proper form before performing the factorization.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Some examples to conclude this section","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"V1 = SU₂Space(0=>2,1/2=>1)\nV2 = SU₂Space(0=>1,1/2=>1,1=>1)\n\nt = TensorMap(randn, V1 ⊗ V1, V2);\nU, S, W = tsvd(t);\nt ≈ U * S * W\nD, V = eigh(t'*t);\nD ≈ S*S\nU'*U ≈ id(domain(U))\nS\n\nQ, R = leftorth(t; alg = Polar());\nisposdef(R)\nQ ≈ U*W\nR ≈ W'*S*W\n\nU2, S2, W2, ε = tsvd(t; trunc = truncspace(V1));\nW2*W2' ≈ id(codomain(W2))\nS2\nε ≈ norm(block(S, Irrep[SU₂](1)))*sqrt(dim(Irrep[SU₂](1)))\n\nL, Q = rightorth(t, (1,), (2,3));\ncodomain(L), domain(L), domain(Q)\nQ*Q'\nP = Q'*Q;\nP ≈ P*P\nt′ = permute(t, (1,), (2,3));\nt′ ≈ t′ * P","category":"page"},{"location":"man/tensors/#ss_tensor_contraction","page":"Tensors and the TensorMap type","title":"Bosonic tensor contractions and tensor networks","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"One of the most important operation with tensor maps is to compose them, more generally known as contracting them. As mentioned in the section on category theory, a typical composition of maps in a ribbon category can graphically be represented as a planar arrangement of the morphisms (i.e. tensor maps, boxes with lines emanating from top and bottom, corresponding to source and target, i.e. domain and codomain), where the lines connecting the source and targets of the different morphisms should be thought of as ribbons, that can braid over or underneath each other, and that can twist.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Technically, we can embed this diagram in ℝ  01 and attach all the unconnected line endings corresponding objects in the source at some position (x0) for xℝ, and all line endings corresponding to objects in the target at some position (x1). The resulting morphism is then invariant under framed three-dimensional isotopy, i.e. three-dimensional rearrangements of the morphism that respect the rules of boxes connected by ribbons whose open endings are kept fixed. Such a two-dimensional diagram cannot easily be encoded in a single line of code.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"However, things simplify when the braiding is symmetric (such that over- and under- crossings become equivalent, i.e. just crossings), and when twists, i.e. self-crossings in this case, are trivial. This amounts to BraidingStyle(I) == Bosonic() in the language of TensorLabXD.jl, and is true for any subcategory of mathbfVect, i.e. ordinary tensors, possibly with some symmetry constraint. The case of mathbfSVect and its subcategories, and more general categories, are discussed below.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"In the case of trivial twists, we can deform the diagram such that we first combine every morphism with a number of coevaluations η so as to represent it as a tensor, i.e. with a trivial domain. We can then rearrange the morphism to be all aligned up horizontally, where the original morphism compositions are now being performed by evaluations ϵ. This process will generate a number of crossings and twists. The twists can be omitted because they act trivially. Similarly, double crossings can also be omitted. As a consequence, the diagram, or the morphism it represents, is completely specified by the tensors it is composed of, and which indices between the different tensors are connect, via the evaluation ϵ, and which indices make up the source and target of the resulting morphism. If we also compose the resulting morphisms with coevaluations so that it has a trivial domain, we just have one type of unconnected lines, henceforth called open indices. We sketch such a rearrangement in the following picture","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(Image: tensor unitary)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Hence, we can now specify such a tensor diagram, henceforth called a tensor contraction or also tensor network, using a one-dimensional syntax that mimicks abstract index notation and specifies which indices are connected by the evaluation map using Einstein's summation conventation. Indeed, for BraidingStyle(I) == Bosonic(), such a tensor contraction can take the same format as if all tensors were just multi-dimensional arrays. For this, we rely on the interface provided by the package TensorContractionsXD.jl.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"The above picture would be encoded as","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor E[a,b,c,d,e] := A[v,w,d,x]*B[y,z,c,x]*C[v,e,y,b]*D[a,w,z]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"or","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor E[:] := A[1,2,-4,3]*B[4,5,-3,3]*C[1,-5,4,-2]*D[-1,2,5]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"where the latter syntax is known as NCON-style, and labels the unconnected or outgoing indices with negative integers, and the contracted indices with positive integers.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"A number of remarks are in order. TensorContractionsXS.jl accepts both integers and any valid variable name as dummy label for indices, and everything in [ ] is not resolved in the current context but interpreted as a dummy label. Here, we label the indices of a TensorMap, like A::TensorMap{S,N₁,N₂}, in a linear fashion, where the first position corresponds to the first space in codomain(A), and so forth, up to position N₁. Index N₁+1then corresponds to the first space in domain(A). However, because we have applied the coevaluation η, it actually corresponds to the corresponding dual space, in accordance with the interface of space(A, i) that we introduced above, and as indiated by the dotted box around A in the above picture. The same holds for the other tensor maps. Note that our convention also requires that we braid indices that we brought from the domain to the codomain, and so this is only unambiguous for a symmetric braiding, where there is a unique way to permute the indices.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"With the current syntax, we create a new object E because we use the definition operator :=. Furthermore, with the current syntax, it will be a Tensor, i.e. it will have a trivial domain, and correspond to the dotted box in the picture above, rather than the actual morphism E. We can also directly define E with the correct codomain and domain by rather using","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor E[a b c;d e] := A[v,w,d,x]*B[y,z,c,x]*C[v,e,y,b]*D[a,w,z]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"or","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor E[(a,b,c);(d,e)] := A[v,w,d,x]*B[y,z,c,x]*C[v,e,y,b]*D[a,w,z]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"where the latter syntax can also be used when the codomain is empty. When using the assignment operator =, the TensorMap E is assumed to exist and the contents will be written to the currently allocated memory. Note that for existing tensors, both on the left hand side and right hand side, trying to specify the indices in the domain and the codomain seperately using the above syntax, has no effect, as the bipartition of indices are already fixed by the existing object. Hence, if E has been created by the previous line of code, all of the following lines are now equivalent","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor E[(a,b,c);(d,e)] = A[v,w,d,x]*B[y,z,c,x]*C[v,e,y,b]*D[a,w,z]\n@tensor E[a,b,c,d,e] = A[v w d;x]*B[(y,z,c);(x,)]*C[v e y; b]*D[a,w,z]\n@tensor E[a b; c d e] = A[v; w d x]*B[y,z,c,x]*C[v,e,y,b]*D[a w;z]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"and none of those will or can change the partition of the indices of E into its codomain and its domain.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Two final remarks are in order. Firstly, the order of the tensors appearing on the right hand side is irrelevant, as we can reorder them by using the allowed moves of the Penrose graphical calculus, which yields some crossings and a twist. As the latter is trivial, it can be omitted, and we just use the same rules to evaluate the newly ordered tensor network. For the particular case of matrix matrix multiplication, which also captures more general settings by appropriotely combining spaces into a single line, we indeed find","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"(Image: tensor contraction reorder)","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"or thus, the following to lines of code yield the same result","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor C[i,j] := B[i,k]*A[k,j]\n@tensor C[i,j] := A[k,j]*B[i,k]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Reordering of tensors can be used internally by the @tensor macro to evaluate the contraction in a more efficient manner. In particular, the NCON-style of specifying the contraction gives the user control over the order, and there are other macros, such as @tensoropt, that try to automate this process. There is also an @ncon macro and ncon function, an we recommend reading the manual of TensorContractionsXS.jl to learn more about the possibilities and how they work.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"A final remark involves the use of adjoints of tensors. The current framework is such that the user should not be to worried about the actual bipartition into codomain and domain of a given TensorMap instance. Indeed, for factorizations one just specifies the requested bipartition via the factorize(t, pleft, pright) interface, and for tensor contractions the @contract macro figures out the correct manipulations automatically. However, when wanting to use the adjoint of an instance t::TensorMap{S,N₁,N₂}, the resulting adjoint(t) is a AbstractTensorMap{S,N₂,N₁} and one need to know the values of N₁ and N₂ to know exactly where the ith index of t will end up in adjoint(t), and hence to know and understand the index order of t'. Within the @tensor macro, one can instead use conj() on the whole index expression so as to be able to use the original index ordering of t. Indeed, for matrices of thus, TensorMap{S,1,1} instances, this yields exactly the equivalence one expects, namely equivalence between the following to expressions.","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"@tensor C[i,j] := B'[i,k]*A[k,j]\n@tensor C[i,j] := conj(B[k,i])*A[k,j]","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"For e.g. an instance A::TensorMap{S,3,2}, the following two syntaxes have the same effect within an @tensor expression: conj(A[a,b,c,d,e]) and A'[d,e,a,b,c].","category":"page"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"Some examples:","category":"page"},{"location":"man/tensors/#Fermionic-tensor-contractions","page":"Tensors and the TensorMap type","title":"Fermionic tensor contractions","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"man/tensors/#Anyonic-tensor-contractions","page":"Tensors and the TensorMap type","title":"Anyonic tensor contractions","text":"","category":"section"},{"location":"man/tensors/","page":"Tensors and the TensorMap type","title":"Tensors and the TensorMap type","text":"TODO","category":"page"},{"location":"man/spaces/#s_spaces","page":"Vector spaces","title":"Vector spaces","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"using TensorLabXD","category":"page"},{"location":"man/spaces/#Types","page":"Vector spaces","title":"Types","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"# Field\nabstract type Field end\nstruct RealNumbers <: Field end\nstruct ComplexNumbers <: Field end\nconst ℝ = RealNumbers()\nconst ℂ = ComplexNumbers()\n\n# Vector Space\nabstract type VectorSpace end\n\n## Elementary Space\nabstract type ElementarySpace{𝕜} <: VectorSpace end\nconst IndexSpace = ElementarySpace\nstruct GeneralSpace{𝕜} <: ElementarySpace{𝕜}\n    d::Int\n    dual::Bool\n    conj::Bool\nend\n\nabstract type InnerProductSpace{𝕜} <: ElementarySpace{𝕜} end\nabstract type EuclideanSpace{𝕜} <: InnerProductSpace{𝕜} end\nstruct CartesianSpace <: EuclideanSpace{ℝ}\n    d::Int\nend\nstruct ComplexSpace <: EuclideanSpace{ℂ}\n  d::Int\n  dual::Bool\nend\nstruct GradedSpace{I<:Sector, D} <: EuclideanSpace{ℂ}\n    dims::D\n    dual::Bool\nend\n\n# Composite Space\nabstract type CompositeSpace{S<:ElementarySpace} <: VectorSpace end\nstruct ProductSpace{S<:ElementarySpace, N} <: CompositeSpace{S}\n    spaces::NTuple{N, S}\nend\nconst TensorSpace{S<:ElementarySpace} = Union{S, ProductSpace{S}}\n\n# Space of Morphisms\nstruct HomSpace{S<:ElementarySpace, P1<:CompositeSpace{S}, P2<:CompositeSpace{S}}\n    codomain::P1\n    domain::P2\nend\nconst TensorMapSpace{S<:ElementarySpace, N₁, N₂} = HomSpace{S, ProductSpace{S, N₁}, ProductSpace{S, N₂}}","category":"page"},{"location":"man/spaces/#Properties","page":"Vector spaces","title":"Properties","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"On both VectorSpace instances and types:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"spacetype # type of ElementarySpace associated with a composite space or a tensor or a HomSpace\nfield # field of a vector space or a tensor map or a HomSpace\nBase.oneunit # the corresponding vector space that represents the trivial 1D space isomorphic to the corresponding field\nsectortype # sector type of a space or a tensor or a HomSpace\none(::S) where {S<:ElementarySpace} -> ProductSpace{S, 0}\none(::ProductSpace{S}) where {S<:ElementarySpace} -> ProductSpace{S, 0}  # Return a tensor product of zero spaces of type `S`, i.e. this is the unit object under the tensor product operation, such that `V ⊗ one(V) == V`.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"On VectorSpace instances:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"sectors # an iterator over the different sectors of an ElementarySpace\nsectors(P::ProductSpace{S, N}) # Return an iterator over all possible combinations of sectors (represented as an `NTuple{N, sectortype(S)}`) that can appear within the tensor product space `P`.\nblocksectors(V::ElementarySpace) = sectors(V) # make ElementarySpace instances behave similar to ProductSpace instances\nblocksectors(P::ProductSpace) # Return an iterator over the different unique coupled sector labels\nblocksectors(W::HomSpace) # Return an iterator over the different unique coupled sector labels, i.e. the intersection of the different fusion outputs that can be obtained by fusing the sectors present in the domain, as well as from the codomain.\nblocksectors(t::TensorMap) # Return an iterator over the different unique coupled sector labels\ndim # total dimension of a vector space or a product space\ndim(V::ElementarySpace, ::Trivial) # return dim(V)\ndim(V::GradedSpace, c::I) # the degeneracy or multiplicity of sector c in a Graded Space\ndim(W::HomSpace) # Return the total dimension of a `HomSpace`, i.e. the number of linearly independent morphisms that can be constructed within this space.\ndim(P::ProductSpace, n::Int) # dim for the `n`th vector space of the product space\ndim(P::ProductSpace{S, N}, s::NTuple{N, sectortype(S)}) # Return the total degeneracy dimension corresponding to a tuple of sectors for each of the spaces in the tensor product, obtained as `prod(dims(P, s))``.\ndim(t::AbstractTensorMap) # total dim for corresponding HomSpace\ndim(t::TensorMap) # Return the total dimension of the tensor map, i.e., the number of elements in all DenseMatrix of the data.\ndims(P::ProductSpace) # Return the dimensions of the spaces in the tensor product space as a tuple of integers.\ndims(P::ProductSpace{S, N}, s::NTuple{N, sectortype(S)}) # Return the degeneracy dimensions corresponding to a tuple of sectors `s` for each of the spaces in the tensor product `P`.\nblockdim(V::ElementarySpace, c::Sector) = dim(V, c) # make ElementarySpace instances behave similar to ProductSpace instances\nblockdim(P::ProductSpace, c::Sector) # Return the total dimension of a coupled sector `c` in the product space\nhassector(V::ElementarySpace, a::Sector) # whether a vector space `V` has a subspace corresponding to sector `a` with non-zero multiplicity\nhassector(P::ProductSpace{S, N}, s::NTuple{N, sectortype(S)}) # Query whether `P` has a non-zero degeneracy of sector `s`, representing a combination of sectors on the individual tensor indices.\nBase.axes(V::ElementarySpace) # the axes of an elementary space as `1:dim(V)`\nBase.axes(V::ElementarySpace, a::Sector) # axes corresponding to the sector `a` in an elementary space as a UnitRange.\nBase.axes(P::ProductSpace) # the axes for all index spaces in product space `P`\nBase.axes(P::ProductSpace, n::Int) # the axes for `n`th index space of product space `P`\nBase.axes(P::ProductSpace{<:ElementarySpace, N}, sectors::NTuple{N, <:Sector}) where {N} # the axes of `sectors[i]` in `P.spaces[i]` for all `i ∈ 1:N`.\nBase.conj(V::ElementarySpace) # returns the complex conjugate space (conj(V)==V̅)\ndual(V::EuclideanSpace) = conj(V) # returns the dual space (dual(V)==V^*); for product space the sequence of the vector spaces are reversed.\ndual(P::ProductSpace) # Return a new product space with reversed order of index spaces of the input product space and take the dual of each index space.\ndual(W::HomSpace) # Return the dual of a HomSpace which contains the dual of morphisms in this space. It corresponds to 180 degree rotation in the graphical representation.\nBase.adjoint(V::VectorSpace) = dual(V) # make V' as the dual of V\nBase.adjoint(W::HomSpace{<:EuclideanSpace}) # Return the adjoint of a HomSpace which contains the dagger of morphisms in this space. It corresponds to mirror operation and then reversing all arrows in the graphical\nrepresentation.\nisdual(V::ElementarySpace) # wether an ElementarySpace `V` is normal or rather a dual space\nflip(V::ElementarySpace) # flip(V)==V̅^*\n⊕ # direct sum of the elementary spaces `V1`, `V2`, ...\n⊗ # representing the tensor product of several elementary vector spaces\nBase.:*(V1::VectorSpace, V2::VectorSpace) = ⊗(V1, V2)\nfuse(V1::S, V2::S, V3::S...) where {S<:ElementarySpace} # returns a single vector space that is isomorphic to the fusion product of the individual spaces\nfuse(P::ProductSpace{S}) where {S<:ElementarySpace}\nismonomorphic # Return whether there exist monomorphisms from `V1` to `V2`, i.e. 'injective' morphisms with left inverses.\nisepimorphic # Return whether there exist epimorphisms from `V1` to `V2`, i.e. 'surjective' morphisms with right inverses.\nisisomorphic # Return if `V1` and `V2` are isomorphic, meaning that there exists isomorphisms from `V1` to `V2`, i.e. morphisms with left and right inverses.\nconst ≾ = ismonomorphic\nconst ≿ = isepimorphic\nconst ≅ = isisomorphic\n≺(V1::VectorSpace, V2::VectorSpace) = V1 ≾ V2 && !(V1 ≿ V2)\n≻(V1::VectorSpace, V2::VectorSpace) = V1 ≿ V2 && !(V1 ≾ V2)\ninfimum # Return the infimum of a number of elementary spaces\nsupremum # Return the supremum of a number of elementary spaces\nBase.:(==)\nBase.hash\nBase.length(P::ProductSpace) # number of vector spaces\nBase.iterate\nBase.indexed_iterate\nBase.eltype\nBase.IteratorEltype\nBase.IteratorSize\nBase.convert\ncodomain(W::HomSpace) # codomain of a HomSpace.\ndomain(W::HomSpace) # domain of a HomSpace.\n","category":"page"},{"location":"man/spaces/#Constructors","page":"Vector spaces","title":"Constructors","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"# Cartesian and Complex Space\nCartesianSpace(d::Integer = 0; dual = false) # Constructed by an integer number which is the dim of the space\nComplexSpace(d::Integer = 0; dual = false)\nCartesianSpace(dim::Pair; dual = false) # Constructed by (Trivial(),d)\nComplexSpace(dim::Pair; dual = false)\nCartesianSpace(dims::AbstractDict; kwargs...) # Constructed by (Trivial() => d)\nComplexSpace(dims::AbstractDict; kwargs...)\nBase.getindex(::RealNumbers) = CartesianSpace # Make ℝ[] a synonyms for CartesianSpace.\nBase.getindex(::ComplexNumbers) = ComplexSpace # make ℂ[] a synonyms for ComplexSpace\nBase.:^(::RealNumbers, d::Int) # Return a CartesianSpace with dimension `d`.\nBase.:^(::ComplexNumbers, d::Int) # Return a ComplexSpace with dimension `d`\n\n# Graded Space\nGradedSpace{I, NTuple{N, Int}}(dims; dual::Bool = false) where {I, N} # dims = (c=>dc,...)\nGradedSpace{I, NTuple{N, Int}}(dims::Pair; dual::Bool = false) where {I, N}\nGradedSpace{I, SectorDict{I, Int}}(dims; dual::Bool = false) where {I<:Sector}\nGradedSpace{I, SectorDict{I, Int}}(dims::Pair; dual::Bool = false) where {I<:Sector}\nGradedSpace{I,D}(; kwargs...) where {I<:Sector,D}\nGradedSpace{I,D}(d1::Pair, d2::Pair, dims::Vararg{Pair}; kwargs...) where {I<:Sector,D}\nGradedSpace{I}(args...; kwargs...) where {I<:Sector}\nGradedSpace(dims::Tuple{Vararg{Pair{I, <:Integer}}}; dual::Bool = false) where {I<:Sector}\nGradedSpace(dims::Vararg{Pair{I, <:Integer}}; dual::Bool = false) where {I<:Sector}\nGradedSpace(dims::AbstractDict{I, <:Integer}; dual::Bool = false) where {I<:Sector}\n\nstruct SpaceTable end\nconst Vect = SpaceTable()\nBase.getindex(::SpaceTable) = ComplexSpace # Vect[] = ComplexSpace\nBase.getindex(::SpaceTable, ::Type{Trivial}) = ComplexSpace\nBase.getindex(::SpaceTable, I::Type{<:Sector}) # # Vect[I]; Return `GradedSpace{I, NTuple{N, Int}}` if `HasLength`; return `GradedSpace{I, SectorDict{I, Int}}` if `IsInfinite`.\nBase.getindex(::ComplexNumbers, I::Type{<:Sector}) = Vect[I] # Make ℂ[I] = Vect[I]\n\nstruct RepTable end\nconst Rep = RepTable()\nBase.getindex(::RepTable, G::Type{<:Group}) # Rep[G] = Vect[Irrep[G]]\nconst ZNSpace{N} = GradedSpace{ZNIrrep{N}, NTuple{N,Int}}\nconst Z2Space = ZNSpace{2}\nconst Z3Space = ZNSpace{3}\nconst Z4Space = ZNSpace{4}\nconst U1Space = Rep[U₁]\nconst CU1Space = Rep[CU₁]\nconst SU2Space = Rep[SU₂]\nconst ℤ₂Space = Z2Space\nconst ℤ₃Space = Z3Space\nconst ℤ₄Space = Z4Space\nconst U₁Space = U1Space\nconst CU₁Space = CU1Space\nconst SU₂Space = SU2Space\n\n# Product Space\nProductSpace(spaces::Vararg{S, N}) where {S<:ElementarySpace, N}\nProductSpace{S, N}(spaces::Vararg{S, N}) where {S<:ElementarySpace, N}\nProductSpace{S}(spaces) where {S<:ElementarySpace}\nProductSpace(P::ProductSpace)\n⊗(V1::S, V2::S) where {S<:ElementarySpace}= ProductSpace((V1, V2))\n⊗(P1::ProductSpace{S}, V2::S) where {S<:ElementarySpace}\n⊗(V1::S, P2::ProductSpace{S}) where {S<:ElementarySpace}\n⊗(P1::ProductSpace{S}, P2::ProductSpace{S}) where {S<:ElementarySpace}\n⊗(P::ProductSpace{S, 0}, ::ProductSpace{S, 0}) where {S<:ElementarySpace} = P\n⊗(P::ProductSpace{S}, ::ProductSpace{S, 0}) where {S<:ElementarySpace} = P\n⊗(::ProductSpace{S, 0}, P::ProductSpace{S}) where {S<:ElementarySpace} = P\n⊗(V::ElementarySpace) = ProductSpace((V,))\n⊗(P::ProductSpace) = P\nBase.:^(V::ElementarySpace, N::Int) = ProductSpace{typeof(V), N}(ntuple(n->V, N))\nBase.:^(V::ProductSpace, N::Int) = ⊗(ntuple(n->V, N)...)\nBase.literal_pow(::typeof(^), V::ElementarySpace, p::Val{N}) where N =\n    ProductSpace{typeof(V), N}(ntuple(n->V, p))\ninsertunit(P::ProductSpace, i::Int = length(P)+1; dual = false, conj = false) # For `P::ProductSpace{S,N}`, this adds an extra tensor product factor at position `1 <= i <= N+1` (last position by default) which is just a the `S`-equivalent of the underlying field of scalars, i.e. `oneunit(S)`.\n\n# HomSpace\n→(dom::TensorSpace{S}, codom::TensorSpace{S}) where {S<:ElementarySpace} =\n    HomSpace(ProductSpace(codom), ProductSpace(dom))\n←(codom::TensorSpace{S}, dom::TensorSpace{S}) where {S<:ElementarySpace} =\n    HomSpace(ProductSpace(codom), ProductSpace(dom))    ","category":"page"},{"location":"man/spaces/#Others-structures","page":"Vector spaces","title":"Others structures","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"struct TrivialOrEmptyIterator\n    isempty::Bool\nend # returns nothing is isempty = true, otherwise returns Trivial()","category":"page"},{"location":"man/spaces/#Details-about-dual,-conj,-flip","page":"Vector spaces","title":"Details about dual, conj, flip","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In vectorspaces.jl:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"function dual end\ndual(V::EuclideanSpace) = conj(V)\nBase.adjoint(V::VectorSpace) = dual(V)\nfunction flip end","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In generalspace.jl:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"dual(V::GeneralSpace{𝕜}) where {𝕜} =\n    GeneralSpace{𝕜}(dim(V), !isdual(V), isconj(V))\nBase.conj(V::GeneralSpace{𝕜}) where {𝕜} =\n    GeneralSpace{𝕜}(dim(V), isdual(V), !isconj(V))","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In cartesianspace.jl:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"flip(V::CartesianSpace) = V","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In complexspace.jl:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Base.conj(V::ComplexSpace) = ComplexSpace(dim(V), !isdual(V))\nflip(V::ComplexSpace) = dual(V)","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In sectors.jl:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Base.conj(a::I): overlinea, conjugate or dual label of a.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"dual(a::Sector) = conj(a)","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In trivial.jl:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Base.conj(::Trivial) = Trivial()","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In anyons.jl:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Base.conj(s::IsingAnyon) = s\nBase.conj(s::FibonacciAnyon) = s","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In irreps.jl:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Base.conj(c::ZNIrrep{N}) where {N} = ZNIrrep{N}(-c.n)\nBase.conj(c::U1Irrep) = U1Irrep(-c.charge)\nBase.conj(s::SU2Irrep) = s\nBase.conj(c::CU1Irrep) = c","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In gradedspace.jl:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In fact, GradedSpace is the reason flip exists, cause in this case it is different than dual. The existence of flip originates from the non-trivial isomorphism between R_overlinea and R_a^*, i.e. the representation space of the dual overlinea of sector a and the dual of the representation space of sector a. In order for flip(V) to be isomorphic to V, it is such that, if V = GradedSpace(a=>n_a,...) then flip(V) = dual(GradedSpace(dual(a)=>n_a,....)).","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In the structure of TensorLabXD.jl, we only keep the simple objects. It means that we don't have objects correspond to a^* in the language of category. Therefore, dual(a) = conj(a) both correspond to overlinea. The dual space of a space is denoted in the field named as dual in the type definitions. If dual = true, it means that we represent the space R_a^* which is isomorphic to R_overlinea, and in the methods like sectors and dim we get the sectors and corresponding dims in the corresponding R_overlinea.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"sectors(V::GradedSpace{I,<:AbstractDict}) where {I<:Sector} =\n    SectorSet{I}(s->isdual(V) ? dual(s) : s, keys(V.dims))\nsectors(V::GradedSpace{I,NTuple{N,Int}}) where {I<:Sector, N} =\n    SectorSet{I}(Iterators.filter(n->V.dims[n]!=0, 1:N)) do n\n        isdual(V) ? dual(values(I)[n]) : values(I)[n]\ndim(V::GradedSpace{I,<:AbstractDict}, c::I) where {I<:Sector} =\n    get(V.dims, isdual(V) ? dual(c) : c, 0)\ndim(V::GradedSpace{I,<:Tuple}, c::I) where {I<:Sector} =\n    V.dims[findindex(values(I), isdual(V) ? dual(c) : c)]    \nBase.conj(V::GradedSpace) = typeof(V)(V.dims, !V.dual)\nfunction flip(V::GradedSpace{I}) where {I<:Sector}\n    if isdual(V)\n        typeof(V)(c=>dim(V, c) for c in sectors(V))\n    else\n        typeof(V)(dual(c)=>dim(V, c) for c in sectors(V))'\n    end\nend        ","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In productspace.jl:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The order of the spaces are reversed before taking the dual of each elementray vecor space:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"dual(P::ProductSpace{<:ElementarySpace, 0}) = P\ndual(P::ProductSpace) = ProductSpace(map(dual, reverse(P.spaces)))","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In  homespace.jl:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"For a morphism the dual of the morphism is different with the adjoint of it. In the tensor category language, the dual of a morphism is called the transpose of the morphism, while the adjoint of a morphism is called the dagger of the morphism.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"dual(W::HomSpace) = HomSpace(dual(W.domain), dual(W.codomain))\nBase.adjoint(W::HomSpace{<:EuclideanSpace}) = HomSpace(W.domain, W.codomain)","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The sequence of the elementary spaces in a TensorMapSpace is defined as 1N_1 for codomain vectors, and N_1+1N_1+N_2 for domain dual vectors. Note that the sequence of the domain vectors are not reversed, and the dual is taken individually for each elementary space.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Base.getindex(W::TensorMapSpace{<:IndexSpace, N₁, N₂}, i) where {N₁, N₂} =\n    i <= N₁ ? codomain(W)[i] : dual(domain(W)[i-N₁])","category":"page"},{"location":"man/spaces/#ss_vectorspace_type","page":"Vector spaces","title":"VectorSpace type","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"From the Introduction, it should be clear that an important aspect in the definition of a tensor (map) is specifying the vector spaces and their structure in the domain and codomain of the map. The starting point is an abstract type VectorSpace","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"abstract type VectorSpace end","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"which is actually a too restricted name. Subtypes of VectorSpace will in general represent 𝕜-linear tensor categories, which can go beyond mathbfVect and mathbfSVect. The instances of it represent the objects of the category.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In order not to make the remaining discussion too abstract or complicated, we will simply refer to subtypes of VectorSpace instead of specific categories, and to spaces instead of objects from these categories.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"We define two abstract subtypes","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"abstract type ElementarySpace{𝕜} <: VectorSpace end\nconst IndexSpace = ElementarySpace\n\nabstract type CompositeSpace{S<:ElementarySpace} <: VectorSpace end","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The ElementarySpace is a super type for all categories that can be associated with the individual indices of a tensor, as hinted to by its alias IndexSpace. The parameter 𝕜 here could represent the field of vector spaces of Vect, or the field of the morphism space of 𝕜-linear tensor categories.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The CompositeSpace{S} where S<:ElementarySpace is a super type for all vector spaces that are composed of a number of elementary spaces of type S. One concrete subtype of it is the ProductSpace{S,N} which represents a homogeneous tensor product of N vector spaces of type S.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Throughout TensorLabXD.jl, the function spacetype returns the type of ElementarySpace associated with e.g. a composite space or a tensor. It works both on instances and type.","category":"page"},{"location":"man/spaces/#ss_fields","page":"Vector spaces","title":"Fields","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Vector spaces (linear categories) are defined over a field of scalars 𝕜. We define a type hierarchy to specify the scalar field, but so far only support real and complex numbers, via","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"abstract type Field end\n\nstruct RealNumbers <: Field end\nstruct ComplexNumbers <: Field end\n\nconst ℝ = RealNumbers()\nconst ℂ = ComplexNumbers()","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Note that ℝ and ℂ can be typed as \\bbR+TAB and \\bbC+TAB. One reason for defining this new type hierarchy instead of recycling the types from Julia's Number hierarchy is to introduce some syntactic sugar without committing type piracy.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Some examples:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"3 ∈ ℝ\n5.0 ∈ ℂ\n5.0+1.0*im ∈ ℝ\nFloat64 ⊆ ℝ\nComplexF64 ⊆ ℂ\nℝ ⊆ ℂ\nℂ ⊆ ℝ","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The field of a vector space or tensor a can be obtained with field(a).","category":"page"},{"location":"man/spaces/#ss_elementaryspaces","page":"Vector spaces","title":"Elementary spaces","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Vector spaces that are associated with the individual indices of a tensor should be implemented as subtypes of ElementarySpace. As the domain and codomain of a tensor map will be the tensor product of such objects which all have the same type, it is important that related vector spaces, e.g. the dual space, are objects of the same concrete type.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Every ElementarySpace should implement the following methods","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"dim(::ElementarySpace) -> ::Int returns the dimension of the space as an Int\ndual(::ElementarySpace) returns the dual space, using an instance of   the same concrete type. The dual of a space V can also be obtained as V'.\nconj(::ElementarySpace) returns the complex conjugate space, using an instance of   the same concrete type","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The GeneralSpace is one of the concrete type of the ElementarySpace. It is completely characterized by its field 𝕜, its dimension and whether its the dual and/or complex conjugate of 𝕜^d.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"struct GeneralSpace{𝕜} <: ElementarySpace{𝕜}\n    d::Int\n    dual::Bool\n    conj::Bool\nend","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The abstract type","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"abstract type InnerProductSpace{𝕜} <: ElementarySpace{𝕜} end","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"is defined to contain all vector spaces V which have an inner product and thus a canonical mapping from dual(V) to conj(V). This mapping is provided by the metric, but no further support for working with metrics is currently implemented.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The abstract type","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"abstract type EuclideanSpace{𝕜} <: InnerProductSpace{𝕜} end","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"is defined to contain all spaces V with a standard Euclidean inner product. The canonical mapping from dual(V) to conj(V) is identity. This subtype represents dagger categories.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"We have two concrete types","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"struct CartesianSpace <: EuclideanSpace{ℝ}\n    d::Int\nend\nstruct ComplexSpace <: EuclideanSpace{ℂ}\n  d::Int\n  dual::Bool\nend","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"to represent the Euclidean spaces ℝ^d and ℂ^d. They can be created using the syntax CartesianSpace(d) == ℝ^d == ℝ[](d) and ComplexSpace(d) == ℂ^d == ℂ[](d). The dual space of mathbbC^d can be created by ComplexSpace(d, true) == ComplexSpace(d; dual = true) == (ℂ^d)' == ℂ[](d)'. Note that the brackets are required because of the precedence rules, since d' == d for d::Integer.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Some examples:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"dim(ℝ^10)\n(ℝ^10)' == ℝ^10 == ℝ[](10)\nisdual((ℂ^5))\nisdual((ℂ^5)')\nisdual((ℝ^5)')\ndual(ℂ^5) == (ℂ^5)' == conj(ℂ^5) == ComplexSpace(5; dual = true)\ntypeof(ℝ^3)\nspacetype(ℝ^3)\nspacetype(ℝ[])\nfield(ℂ^5)","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Note that ℝ[] and ℂ[] are synonyms for CartesianSpace and ComplexSpace respectively. This is not very useful in itself, and is motivated by its generalization to GradedSpace. We refer to the subsection on graded spaces on the next page for further information about GradedSpace, which is another subtype of EuclideanSpace{ℂ} with an inner structure corresponding to the irreducible representations of a group, or more generally, the simple objects of a fusion category.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"note: Note\nFor ℂ^n the dual space is equal (or naturally isomorphic) to the conjugate space, but not to the space itself. This means that even for ℂ^n, arrows matter in the diagrammatic notation for categories or for tensors, and in particular that a contraction between two tensor indices will check that one is living in the space and the other in the dual space. This is in contrast with several other software packages, especially in the context of tensor networks, where arrows are only introduced when discussing symmetries. We believe that our more purist approach can be useful to detect errors (e.g. unintended contractions). Only with ℝ^n will their be no distinction between a space and its dual. When creating tensors with indices in ℝ^n that have complex data, a one-time warning will be printed, but most operations should continue to work nonetheless.","category":"page"},{"location":"man/spaces/#ss_compositespaces","page":"Vector spaces","title":"Composite spaces","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Composite spaces are vector spaces that are built up out of individual elementary vector spaces of the same type. The most prominent and currently only subtype is a tensor product of N elementary spaces of the same type S:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"struct ProductSpace{S<:ElementarySpace, N} <: CompositeSpace{S}\n    spaces::NTuple{N, S}\nend","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Given some V1::S, V2::S, V3::S of the same type S<:ElementarySpace, we can easily construct ProductSpace{S,3}((V1,V2,V3)) as ProductSpace(V1,V2,V3) or using V1 ⊗ V2 ⊗ V3, where ⊗ is simply obtained by typing \\otimes+TAB. For convenience, the regular multiplication operator * also acts as tensor product between vector spaces, and as a consequence so does raising a vector space to a positive integer power, i.e.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"V1 = ℂ^2\nV2 = ℂ^3\nV1 ⊗ V2 ⊗ V1' == V1 * V2 * V1' == ProductSpace(V1,V2,V1') == ProductSpace(V1,V2) ⊗ V1'\nV1^3\ndim(V1 ⊗ V2)\ndims(V1 ⊗ V2)\ndual(V1 ⊗ V2)\nspacetype(V1 ⊗ V2)\nspacetype(ProductSpace{ComplexSpace,3})","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Here, the new function dims gives the dimension of the individual spaces in a ProductSpace as a tuple.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The function one applied to a ProductSpace{S,N} or an instance V of S::ElementarySpace returns the multiplicative identity, which is ProductSpace{S,0}(()). Note that V ⊗ one(V) or ⊗(V) will yield a ProductSpace{S,1}(V) and not V itself.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In the future, other CompositeSpace types could be added. For example, the wave function of an N-particle quantum system in first quantization would require the introduction of a SymmetricSpace{S,N} or a AntiSymmetricSpace{S,N} for bosons or fermions respectively, which correspond to the symmetric (permutation invariant) or antisymmetric subspace of V^N, where V::S represents the Hilbert space of the single particle system. Other domains, like general relativity, might also benefit from tensors living in a subspace with certain symmetries under specific index permutations.","category":"page"},{"location":"man/spaces/#ss_homspaces","page":"Vector spaces","title":"Space of morphisms","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In a 𝕜-linear category C, the set of morphisms mathrmHom(WV) for VW  C form a vector space with field 𝕜, irrespective of whether or not C is a subcategory of mathbf(S)Vect, and we define tensor maps as the morphisms.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The space of morphisms is represented by the type","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"struct HomSpace{S<:ElementarySpace, P1<:CompositeSpace{S}, P2<:CompositeSpace{S}}\n    codomain::P1\n    domain::P2\nend","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"It can be created by domain → codomain or codomain ← domain (where the arrows are obtained as \\to+TAB or \\leftarrow+TAB, and as \\rightarrow+TAB respectively).","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Note that HomSpace is not a subtype of VectorSpace.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Some properties of HomSpace:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"W = ℂ^2 ⊗ ℂ^3 → ℂ^3 ⊗ dual(ℂ^4)\nfield(W)\ndual(W)\nadjoint(W)\nspacetype(W)\nspacetype(typeof(W))\nW[1]\nW[2]\nW[3]\nW[4]\ndim(W)","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The indexing W yields first the spaces in the codomain, followed by the dual of the individual spaces in the domain. This convention is useful in combination with the instances of type TensorMap, which represent morphisms living in such a HomSpace. The dim(::HomSpace) represent the number of linearly independent morphisms in this space.","category":"page"},{"location":"man/spaces/#Partial-order-among-vector-spaces","page":"Vector spaces","title":"Partial order among vector spaces","text":"","category":"section"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Vector spaces of the same spacetype can be given a partial order, based on whether there exist injective morphisms (a.k.a monomorphisms) or surjective morphisms (a.k.a. epimorphisms) between them.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"We define ismonomorphic(V1, V2), with Unicode synonym V1 ≾ V2 (obtained as \\precsim+TAB), to express whether there exist injective morphisms in V1 → V2.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"We define isepimorphic(V1, V2), with Unicode synonym V1 ≿ V2 (obtained as \\succsim+TAB), to express whether there exist surjective morphisms in V1 → V2.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"We define isisomorphic(V1, V2), with Unicode alternative V1 ≅ V2 (obtained as \\cong+TAB), to express whether there exist isomorphism in V1 → V2. V1 ≅ V2 if and only if V1 ≾ V2 && V1 ≿ V2.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The strict comparison operators ≺ and ≻ (\\prec+TAB and \\succ+TAB) are defined by","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"≺(V1::VectorSpace, V2::VectorSpace) = V1 ≾ V2 && !(V1 ≿ V2)\n≻(V1::VectorSpace, V2::VectorSpace) = V1 ≿ V2 && !(V1 ≾ V2)","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"However, as we expect these to be less commonly used, no ASCII alternative is provided.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"In the context of spacetype(V) <: EuclideanSpace, V1 ≾ V2 implies that there exists isometries WV1  V2 such that W^  W = mathrmid_V1, while V1 ≅ V2 implies that there exist unitaries UV1  V2 such that U^  U = mathrmid_V1 and U  U^ = mathrmid_V2.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Note that spaces that are isomorphic are not necessarily equal. One can be a dual space, and the other a normal space, or one can be an instance of ProductSpace, while the other is an ElementarySpace. There will exist (infinitely) many isomorphisms between the corresponding spaces, but in general none of those will be canonical.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"There are a number of convenience functions to create isomorphic spaces. The function fuse(V1, V2, ...) or fuse(V1 ⊗ V2 ⊗ ...) returns an elementary space that is isomorphic to V1 ⊗ V2 ⊗ .... The function flip(V::ElementarySpace) returns a space that is isomorphic to V but has isdual(flip(V)) == isdual(V'), i.e. if V is a normal space then flip(V) is a dual space. flip(V) is different from dual(V) in the case of GradedSpace. It is useful to flip a tensor index from a ket to a bra (or vice versa), by contracting that index with a unitary map from V to flip(V). (In the language of category, the we have flip(a)== overlinea^* .)","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Some examples:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"ℝ^3 ≾ ℝ^5\nℂ^3 ≾ (ℂ^5)'\n(ℂ^5) ≅ (ℂ^5)'\nfuse(ℝ^5, ℝ^3)\nfuse(ℂ^3, (ℂ^5)' ⊗ ℂ^2)\nfuse(ℂ^3, (ℂ^5)') ⊗ ℂ^2 ≅ fuse(ℂ^3, (ℂ^5)', ℂ^2) ≅ ℂ^3 ⊗ (ℂ^5)' ⊗ ℂ^2\nflip(ℂ^4)\nflip(ℂ^4) ≅ ℂ^4\nflip(ℂ^4) == ℂ^4","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"We define the direct sum V1 and V2 as V1 ⊕ V2, where ⊕ is obtained by typing \\oplus+TAB. This is possible only if isdual(V1) == isdual(V2).","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Applying oneunit to an elementary space returns the one-dimensional space, which is isomorphic to the scalar field of the space itself.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"Some examples:","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"ℝ^5 ⊕ ℝ^3\nℂ^5 ⊕ ℂ^3\nℂ^5 ⊕ (ℂ^3)'\noneunit(ℝ^3)\nℂ^5 ⊕ oneunit(ComplexSpace)\noneunit((ℂ^3)')\n(ℂ^5) ⊕ oneunit((ℂ^5))\n(ℂ^5)' ⊕ oneunit((ℂ^5)')","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"If V1 and V2 are two ElementarySpace instances with isdual(V1) == isdual(V2), we can define a unique infimum V::ElementarySpace with the same value of isdual that satisfies V ≾ V1 and V ≾ V2, as well as a unique supremum W::ElementarySpace that satisfies W ≿ V1 and W ≿ V2. For CartesianSpace and ComplexSpace, this simply amounts to the space with minimal or maximal dimension, i.e.","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"infimum(ℝ^5, ℝ^3)\nsupremum(ℂ^5, ℂ^3)\nsupremum(ℂ^5, (ℂ^3)')","category":"page"},{"location":"man/spaces/","page":"Vector spaces","title":"Vector spaces","text":"The names infimum and supremum are especially suited in the case of GradedSpace, as the infimum of two spaces might be different from either of those two spaces, and similar for the supremum.","category":"page"},{"location":"man/intro/#s_intro","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Before providing a typical \"user guide\" and discussing the implementation of TensorLabXD.jl, let us discuss some of the rationale behind this package.","category":"page"},{"location":"man/intro/#ss_whatistensor","page":"Introduction","title":"What is a tensor?","text":"","category":"section"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"At the very start we should ponder about the most suitable and sufficiently general definition of a tensor. A good starting point is the following:","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"A tensor t is an element from the tensor product of N vector spaces   V_1  V_2  V_N, where N is referred to as the rank or order of the   tensor, i.e.\nt  V_1  V_2    V_N","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"If you think of a tensor as an object with indices, a rank N tensor has N indices.   Each index labels a particular basis in its corresponding vector space. The tensor product is only defined for vector spaces over the same field of scalars, e.g. ℝ^5  ℂ^3 is not allowed.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Since the tensor product of vector spaces is itself a vector space, a tensor behaves as a vector, i.e., a tensor can be multiplied by scalars and tensors in the same tensor product space can be added. When all the vector spaces in the tensor product have an inner product, the tensor product space also has an inner product.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Aside from interpreting a tensor as a vector, we can also interpret it as a linear map, and call it as a tensor map:","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"A tensor map t is a linear map from a source or domain   W_1  W_2    W_N_2 to a target or codomain V_1  V_2    V_N_1, i.e.\ntW_1  W_2    W_N_2  V_1  V_2    V_N_1","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"A tensor of rank N is then just a special case of a tensor map with N_1 = N and N_2 = 0.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"A contraction between two tensor maps is just a composition of linear maps (i.e. matrix multiplication), where the contracted indices correspond to the domain of the first tensor and the codomain of the second tensor.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"We can decompose tensor maps using linear algebra factorisations (e.g. eigenvalue or singular value decomposition).","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"In order to allow for arbitrary tensor contractions or decompositions, we need to be able to reorganise the positions of vector spaces appear in the domain and the codomain of the tensor map. This amounts to defining canonical isomorphisms between the different ways to order and partition the tensor indices. For example, a tensor map W  V can also be denoted as a rank 2 tensor in V  W^*, where W^* is the dual space of W. This simple example introduces two new concepts:","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Typical vector spaces can appear in the domain and codomain in different related forms.\nIn general, every vector space V has a dual space V^*, a conjugate space  overlineV, and a conjugate dual space overlineV^*.\nThe spaces V^* and overlineV correspond respectively to the  representation spaces of the dual and complex conjugate representation of the general  linear group mathsfGL(V).\nFor complex vector spaces with an inner product overlineV  V  ℂ, the inner  product allows to define an isomorphism from the conjugate space to the dual space.\nIn spaces with a Euclidean inner product (the setting of quantum mechanics), the  conjugate and dual space are naturally isomorphic (because the dual and conjugate  representation of the unitary group are the same).\nIn cartesian space ℝ^d with a Euclidean inner product, these four different spaces  are all equivalent. The space is completely characterized by its dimension d. This  is the setting of much of classical mechanics. The tensors in ℝ^d can equally well  be represented as multidimensional arrays (i.e. using AbstractArray{<:Real,N} in  Julia) without loss of structure.\nIn general, the identification between maps W  V and tensors in  V  W^* is not an equivalence but an isomorphism, which needs to be defined.  Similarly, there is an isomorphism between between V  W and W  V that can be  non-trivial (e.g. in the case of fermions / super vector spaces). The correct formalism  here is provided by theory of monoidal categories.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"This brings us to our final formal definition of a tensor map:","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"A tensor map is a homomorphism between two objects from the category mathbfVect   (or some subcategory thereof). In practice, this will be mathbfFinVect, the   category of finite dimensional vector spaces. More generally, our tensor maps make sense   for any linear (a.k.a. mathbfVect-enriched) monoidal category.","category":"page"},{"location":"man/intro/#ss_symmetries","page":"Introduction","title":"Symmetries and block sparsity","text":"","category":"section"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"Physical problems often have some symmetries, i.e., the system is invariant under the action of a group mathsfG which acts on the vector spaces V of the system according to a certain representation. Having quantum mechanics in mind, TensorLabXD.jl is so far restricted to unitary representations.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"A general representation space V can be specified as the number of times every irreducible representation (irrep) a of mathsfG appears, i.e.,","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"V = bigoplus_a ℂ^n_a  R_a","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"with R_a the space associated with irrep a of mathsfG, which itself has dimension d_a (often called the quantum dimension), and n_a the number of times this irrep appears in V. The total dimension of V is given by _a n_a d_a.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"If the unitary irrep a for g  mathsfG is given by u_a(g), then there exists a specific basis for V such that the group action of mathsfG on V is given by the unitary representation","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"u(g) = bigoplus_a  𝟙_n_a  u_a(g)","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"with 𝟙_n_a the n_a  n_a identity matrix.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"The reason for implementing symmetries is to exploit the computation and memory gains by restricting to tensor maps that are equivariant under the symmetry. The symmetric tensors act as intertwiners between the symmetry action on the domain and the codomain. (This is the key point to understand the concept of symmetric tensor maps!!!)","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"We could change the basis of the domain (or codomain) from the tensor product of the uncoupled irreps a_1otimes a_2otimes otimes a_N, where a_iin W_i (or V_i), to coupled irreps. The basis change is implemented by a sequence of Clebsch–Gordan coefficients, also known as a fusion (or splitting) tree.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"The symmetric tensors should be block diagonal in the basis of coupled irreps because of Schur's lemma.","category":"page"},{"location":"man/intro/","page":"Introduction","title":"Introduction","text":"We implement the necessary machinery to manipulate these fusion trees for arbitrary groups mathsfG. Generally, this fits with the formalism of monoidal fusion categories, and only requires the topological data of the group, i.e., the fusion rules of the irreps, their quantum dimensions, and the F-symbol (6j-symbol or more precisely Racah's W-symbol in the case of mathsfSU_2).","category":"page"},{"location":"man/sectors/#s_sectorsrepfusion","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"using TensorLabXD\nimport LinearAlgebra.I","category":"page"},{"location":"man/sectors/#Types","page":"Sectors, representation spaces and fusion trees","title":"Types","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"# General Sector\nabstract type Sector end\nstruct SectorValues{I<:Sector} end  # Singleton type to represent an iterator over the possible values of type `I`, whose instance is obtained as `values(I)`.\nconst SectorDict{K, V} = SortedVectorDict{K, V}\n\nabstract type FusionStyle end\nstruct UniqueFusion <: FusionStyle end # unique fusion output when fusion two sectors\nabstract type MultipleFusion <: FusionStyle end\nstruct SimpleFusion <: MultipleFusion end # multiple fusion but multiplicity free\nstruct GenericFusion <: MultipleFusion end # multiple fusion with multiplicities\nconst MultiplicityFreeFusion = Union{UniqueFusion, SimpleFusion}\n\nabstract type BraidingStyle end # generic braiding\nabstract type HasBraiding <: BraidingStyle end\nstruct NoBraiding <: BraidingStyle end\nabstract type SymmetricBraiding <: HasBraiding end # symmetric braiding => actions of permutation group are well defined\nstruct Bosonic <: SymmetricBraiding end # all twists are one\nstruct Fermionic <: SymmetricBraiding end # twists one and minus one\nstruct Anyonic <: HasBraiding end\n\nstruct Trivial <: Sector end\n\n# Anyon category\nstruct FibonacciAnyon <: Sector\n    isone::Bool\n    function FibonacciAnyon(s::Symbol)\n        s in (:I, :τ, :tau) || throw(ArgumentError(\"Unknown FibonacciAnyon $s.\"))\n        new(s === :I)\n    end\nend\nconst _goldenratio = Float64(MathConstants.golden)\n\nstruct IsingAnyon <: Sector\n    s::Symbol\n    function IsingAnyon(s::Symbol)\n        s == :sigma && (s = :σ)\n        s == :psi && (s = :ψ)\n        if !(s in (:I, :σ, :ψ))\n            throw(ValueError(\"Unknown IsingAnyon $s.\"))\n        end\n        new(s)\n    end\nend\nconst all_isinganyons = (IsingAnyon(:I), IsingAnyon(:σ), IsingAnyon(:ψ))\n\n# Group\nabstract type Group end\nabstract type AbelianGroup <: Group end\n\nabstract type ℤ{N} <: AbelianGroup end\nabstract type U₁ <: AbelianGroup end\nabstract type SU{N} <: Group end\nabstract type CU₁ <: Group end\n\nconst ℤ₂ = ℤ{2}\nconst ℤ₃ = ℤ{3}\nconst ℤ₄ = ℤ{4}\nconst SU₂ = SU{2}\n\nconst GroupTuple = Tuple{Vararg{Group}}\nabstract type ProductGroup{T<:GroupTuple} <: Group end\n\n# Rep_G category\nabstract type AbstractIrrep{G<:Group} <: Sector end # irreps have integer quantum dimensions\nstruct IrrepTable end\nconst Irrep = IrrepTable()\n\nconst AbelianIrrep{G} = AbstractIrrep{G} where {G<:AbelianGroup}\n\nstruct ZNIrrep{N} <: AbstractIrrep{ℤ{N}}\n    n::Int8\n    function ZNIrrep{N}(n::Integer) where {N}\n        @assert N < 64\n        new{N}(mod(n, N))\n    end\nend\nBase.getindex(::IrrepTable, ::Type{ℤ{N}}) where N = ZNIrrep{N} # Irrep[Z{N}] = ZNIrrep{N}\nconst Z2Irrep = ZNIrrep{2}\nconst Z3Irrep = ZNIrrep{3}\nconst Z4Irrep = ZNIrrep{4}\n\nstruct U1Irrep <: AbstractIrrep{U₁}\n    charge::HalfInt\nend\n\nstruct SU2IrrepException <: Exception end\nstruct SU2Irrep <: AbstractIrrep{SU₂}\n    j::HalfInt\n    function SU2Irrep(j)\n        j >= zero(j) || error(\"Not a valid SU₂ irrep\")\n        new(j)\n    end\nend\nconst _su2one = SU2Irrep(zero(HalfInt))\n\nstruct CU1Irrep <: AbstractIrrep{CU₁}\n    j::HalfInt # value of the U1 charge\n    s::Int # rep of charge conjugation:\n    # if j == 0, s = 0 (trivial) or s = 1 (non-trivial),\n    # else s = 2 (two-dimensional representation)\n    # Let constructor take the actual half integer value j\n    function CU1Irrep(j::Real, s::Integer = ifelse(j>zero(j), 2, 0))\n        if ((j > zero(j) && s == 2) || (j == zero(j) && (s == 0 || s == 1)))\n            new(j, s)\n        else\n            error(\"Not a valid CU₁ irrep\")\n        end\n    end\nend\n\n# Fusion Trees\nstruct FusionTree{I<:Sector, N, M, L, T} # a splitting tree of simple objects\n    uncoupled::NTuple{N, I} # objects coming out of the splitting trees, before the possible ``Z`` isomorphism.\n    coupled::I\n    isdual::NTuple{N, Bool}\n    innerlines::NTuple{M, I} # M = N-2\n    vertices::NTuple{L, T} # L = N-1\n    function FusionTree{I, N, M, L, T}(uncoupled::NTuple{N, I},\n                                            coupled::I,\n                                            isdual::NTuple{N, Bool},\n                                            innerlines::NTuple{M, I},\n                                            vertices::NTuple{L, T}) where\n                                            {I<:Sector, N, M, L, T}\n        new{I, N, M, L, T}(uncoupled, coupled, isdual, innerlines, vertices)\n    end\nend\n\nstruct FusionTreeIterator{I<:Sector, N}\n    uncoupled::NTuple{N, I}\n    coupled::I\n    isdual::NTuple{N, Bool}\nend # iterate over fusion trees for fixed coupled and uncoupled sector labels\n\nfusiontreedict(I) = FusionStyle(I) isa UniqueFusion ? SingletonDict : FusionTreeDict\nconst FusionTreeDict{K, V} = Dict{K, V}\n\nconst transposecache = LRU{Any, Any}(; maxsize = 10^5)\nconst usetransposecache = Ref{Bool}(true)\nconst TransposeKey{I<:Sector, N₁, N₂} = Tuple{<:FusionTree{I}, <:FusionTree{I},\n                                                IndexTuple{N₁}, IndexTuple{N₂}}\n\nconst braidcache = LRU{Any, Any}(; maxsize = 10^5)\nconst usebraidcache_abelian = Ref{Bool}(false)\nconst usebraidcache_nonabelian = Ref{Bool}(true)    \n\nconst BraidKey{I<:Sector, N₁, N₂} = Tuple{<:FusionTree{I}, <:FusionTree{I},\n                                        IndexTuple, IndexTuple,\n                                        IndexTuple{N₁}, IndexTuple{N₂}}                                            ","category":"page"},{"location":"man/sectors/#Properties","page":"Sectors, representation spaces and fusion trees","title":"Properties","text":"","category":"section"},{"location":"man/sectors/#Sectors","page":"Sectors, representation spaces and fusion trees","title":"Sectors","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.values(::Type{I}) where {I<:Sector} # Return the iterator that generate all simple objects of sector `I`.\nBase.one(a::Sector) = one(typeof(a)) # Return the unit object of the sector.\ndual(a::Sector) = conj(a)\nBase.conj # Return `a̅`; this should be implemented\nBase.isless # give a canonical order for the simple objects in a sector\nFusionStyle(a::Sector) = FusionStyle(typeof(a))\nfusiontensor(a::I, b::I, c::I) where {I<:AbstractIrrep{G<:Group}} # Return the fusiontensor ``X^{ab}_{c,μ}: c → a ⊗ b`` as a rank-4 tensor with size `(dim(a),dim(b),dim(c),Int(Nsymbol(a,b,c)))`.\n⊗(a::I, b::I) where {I<:Sector}  # Return an iterator of elements of `c::I` that appear in the fusion product `a ⊗ b`.\nNsymbol(a::I, b::I, c::I) where {I<:Sector} -> Integer # Return an `Integer` representing the number of times `c` appears in the fusion product `a ⊗ b`. Could be a `Bool` if `FusionStyle(I) == UniqueFusion()` or `SimpleFusion()`.\nFsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I<:Sector} # Fsymbol(a,b,c,d,e,f)[μ,ν,κ,λ]\nvertex_ind2label(k::Int, a::I, b::I, c::I) where {I<:Sector} # Convert the index `k` of the fusion vertex (a,b)->c into a label.\nvertex_labeltype(I::Type{<:Sector}) -> Type # Return the type of labels for the fusion vertices of sectors of type `I`.\ndim(a::Sector) # Return the (quantum) dimension of the sector `a`.\nsqrtdim(a::Sector) # the square root of the quantum dimension of the sector `a`.\nisqrtdim(a::Sector) # inverse of `sqrtdim(a::Sector)`\nfrobeniusschur(a::Sector) # Return the Frobenius-Schur indicator of a sector `a`.\nBsymbol(a::I, b::I, c::I) where {I<:Sector}\nAsymbol(a::I, b::I, c::I) where {I<:Sector}\nBraidingStyle(a::Sector) = BraidingStyle(typeof(a))\nRsymbol(a::I, b::I, c::I) where {I<:Sector}\ntwist(a::Sector)\nBase.isreal(I::Type{<:Sector}) # whether topological data real\n×(a::Type{<:Group}, b::Type{<:Group}, c::Type{<:Group}...) = ×(×(a, b), c...) # Product of Groups","category":"page"},{"location":"man/sectors/#Fusion-trees","page":"Sectors, representation spaces and fusion trees","title":"Fusion trees","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"fusiontreetype(::Type{I}, N::Int) where {I<:Sector}  # Return the correct fusiontree type `FusionTree{I<:Sector, N, M, L, T}` based on `I` and `N`.\nsectortype(::Type{<:FusionTree{I}}) # also for instance\nFusionStyle(::Type{<:FusionTree{I}}) where {I<:Sector} # also for instance\nBraidingStyle(::Type{<:FusionTree{I}}) where {I<:Sector} # also for instance\nBase.length(::Type{<:FusionTree{<:Sector, N}}) where {N} # Return the number of the uncoupled objects in a fusion tree; also for instance\nBase.isequal(f1::FusionTree{I, N}, f2::FusionTree{I, N}) where {I<:Sector, N}\nfusiontrees(uncoupled::NTuple{N, I}, coupled::I = one(I), isdual::NTuple{N, Bool} = ntuple(n->false, Val(N))) where {N, I<:Sector} # return the FusionTreeIterator over all possible fusion trees from a set of N uncoupled sectors to a given coupled sector\nBase.length(iter::FusionTreeIterator) # number of fusiontrees with fixed uncoupled objects and coupled object\n\n # Planar manipulations on a splitting tree\nsplit(f::FusionTree{I, N}, M::Int) # Split a fusion tree into two. The first tree has as uncoupled sectors the first `M` uncoupled sectors of the input tree `f`\ninsertat(f::FusionTree{I, N₁}, i::Int, f2::FusionTree{I, N₂}) # Attach a fusion tree `f2` to the uncoupled leg `i` of the fusion tree `f1` and bring it into a linear combination of fusion trees in standard form.\nmerge(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}, c::I, μ = nothing) # Merge two fusion trees together to a linear combination of fusion trees whose uncoupled sectors are those of `f1` followed by those of `f2`, and where the two coupled sectors of `f1` and `f2` are further fused to `c`.\nelementary_trace(f::FusionTree{I, N}, i) where {I<:Sector, N} # Trace the ``i``th and ``i+1``th uncoupled sectors of splitting tree `f`.\nplanar_trace(f::FusionTree{I,N}, q1::IndexTuple{N₃}, q2::IndexTuple{N₃}) where {I<:Sector, N, N₃} # Take the traces between `q1[k]`th and `q2[k]`th sector of the splitting tree `f`, where `1<=k<=N₃`.\n\n# Planar manipulations on a fusion-splitting tree\nbendright(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}) where {I<:Sector, N₁, N₂} # map final splitting vertex (a, b)<-c to fusion vertex a<-(c, dual(b))\nbendleft(f1::FusionTree{I}, f2::FusionTree{I}) where I # map final fusion vertex c<-(a, b) to splitting vertex (c, dual(b))<-a\nfoldright(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}) where {I<:Sector, N₁, N₂} # map first splitting vertex (a, b)<-c to fusion vertex b<-(dual(a), c)\nfoldleft(f1::FusionTree{I}, f2::FusionTree{I}) where I # map first fusion vertex c<-(a, b) to splitting vertex (dual(a), c)<-b\ncycleclockwise(f1::FusionTree{I}, f2::FusionTree{I}) where {I<:Sector} # clockwise cyclic permutation while preserving (N₁, N₂): foldright & bendleft\ncycleanticlockwise(f1::FusionTree{I}, f2::FusionTree{I}) where {I<:Sector} # anticlockwise cyclic permutation while preserving (N₁, N₂): foldleft & bendright\nrepartition(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}, N::Int) where {I, N₁, N₂} # new tree has N outgoing sectors\nBase.transpose(f1::FusionTree{I}, f2::FusionTree{I}, p1::IndexTuple{N₁}, p2::IndexTuple{N₂}) where {I<:Sector, N₁, N₂} # Computes new trees and corresponding coefficients obtained from repartitioning and cyclic permutating the fusion-splitting tree such that sectors `p1` become outgoing and sectors `p2` become incoming.\nplanar_trace(f1::FusionTree{I}, f2::FusionTree{I}, p1::IndexTuple{N₁}, p2::IndexTuple{N₂}, q1::IndexTuple{N₃}, q2::IndexTuple{N₃}) where {I<:Sector, N₁, N₂, N₃} # Take the traces between `q1[k]`th and `q2[k]`th sector of the fusion-splitting tree and the result is transposed according to `p1` and `p2`.\n\n# Braiding manipulations on a splitting tree\nartin_braid(f::FusionTree, i; inv::Bool = false) # Perform an elementary braid (Artin generator) of neighbouring uncoupled indices `i` and `i+1` on a fusion tree `f`, and returns the result as a dictionary of output trees and corresponding coefficients.\nbraid(f::FusionTree{<:Sector, N}, levels::NTuple{N, Int}, p::NTuple{N, Int}) # general braiding according to permutation p and levels\npermute(f::FusionTree, p::NTuple{N, Int}) # permutation when braiding is symmetric\n\n# Braiding manipulations on a fusion-splitting tree\nbraid(f1::FusionTree{I}, f2::FusionTree{I}, levels1::IndexTuple, levels2::IndexTuple, p1::IndexTuple{N₁}, p2::IndexTuple{N₂}) where {I<:Sector, N₁, N₂} # Compute new trees and corresponding coefficients obtained from repartitioning and braiding the tree such that sectors `p1` become outgoing and sectors `p2` become incoming.\npermute(f1::FusionTree{I}, f2::FusionTree{I}, p1::NTuple{N₁, Int}, p2::NTuple{N₂, Int}) where {I, N₁, N₂} # permutation when braiding is symmetric","category":"page"},{"location":"man/sectors/#Others-structures","page":"Sectors, representation spaces and fusion trees","title":"Others structures","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SectorSet{I<:Sector, F, S} # behaves as an iterator that applies x->convert(I, f(x)) on the elements of set; if f is not provided it is just taken as the function identity.\n    f::F\n    set::S\nend","category":"page"},{"location":"man/sectors/#ss_general","page":"Sectors, representation spaces and fusion trees","title":"General arguments","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Symmetries in a physical system often result in tensors which are invariant under the action of the symmetry group, where this group acts as a tensor product of group actions on every tensor index separately. The group action on a single index, or thus, on the corresponding vector space, can be decomposed into irreducible representations (irreps). Here, we restrict to unitary representations, such that the corresponding vector spaces also have a natural Euclidean inner product. The Euclidean inner product between two vectors is invariant under the group action and thus transforms according to the trivial representation of the group.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The corresponding vector spaces will be canonically represented as V = _a ℂ^n_a  R_a, where a labels the different irreps, n_a is the number of times irrep a appears and R_a is the vector space associated with irrep a. Irreps are also known as spin sectors (in the case of mathsfSU_2) or charge sectors (in the case of mathsfU_1), and we henceforth refer to a as a sector. For practical reasons, we assume that there is a canonical order of the sectors, so that the vector space V is completely specified by the values of n_a.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"As discussed in the section on categories, the approach we follow does go beyond the case of irreps of groups, and sectors would more generally correspond to simple objects in a unitary ribbon fusion category. Nonetheless, every step can be appreciated by using the representation theory of mathsfSU_2 or mathsfSU_3 as example.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The gain in efficiency (both in memory occupation and computation time) obtained from using equivariant tensor maps is that, by Schur's lemma, they are block diagonal in the basis of coupled sectors. To exploit this block diagonal form, it is essential that we know the basis transform from the individual uncoupled sectors appearing in the tensor product form of the domain and codomain, to the coupled sectors that label the different blocks. We refer to the coupled sectors as block sectors. The transformation from the uncoupled sectors to the block sector is encoded in a fusion tree (or splitting tree). Essentially, it is a sequential application of pairwise fusion as described by the group's Clebsch–Gordan (CG) coefficients. However, it turns out that we do not need the actual CG coefficients, but only how they transform under transformations such as interchanging the order of the incoming irreps or interchanging incoming and outgoing irreps. This information is known as the topological data of the group, i.e. mainly the F-symbols, which are also known as recoupling coefficients or 6j-symbols. The F-symbol is actually Racah's W-coefficients in the case of mathsfSU_2.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Below, we describe how to specify a certain type of sector and what information about them needs to be implemented. Then, we describe how to build a space V composed of a direct sum of different sectors. Then, we explain the constructions and manipulations of fusion trees. Finally, we elaborate on the case of general fusion categories and the possibility of having fermionic or anyonic twists.","category":"page"},{"location":"man/sectors/#ss_representationtheory","page":"Sectors, representation spaces and fusion trees","title":"Representation theory and unitary fusion categories","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Let us labol the sectors as a, b, c, …. In general, they correspond to the simple objects of a tensor category.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"First, we need to specify the fusion rules a  b =  N^ab_c c with N^ab_c some non-negative integers.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"There should always exists a unique trivial sector u (called the identity object I or 1 in the language of categories) such that a  u = a = u  a.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We need to specify a unique sector bara such that N^abara_u = 1, whereas for all b neq bara, N^ab_u = 0. For unitary irreps of groups, bara corresponds to the complex conjugate of the representation a, or a representation isomorphic to it.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For example, for mathsfSU_2, the trivial sector corresponds to spin zero and all irreps are self-dual (i.e. a = bara), meaning that the conjugate representation is isomorphic to the non-conjugated one (they are not equal but related by a similarity transform).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The space of transformations R_c  R_a  R_b has dimension N^ab_c. We assume there exists a set of maps X^ab_cμ  R_c  R_a  R_b with μ = 1  N^ab_c, which form the basis of the morphism space from R_c to R_a  R_b, and satisfy","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(X^ab_cμ)^circ X^ab_cν = δ_μν mathrmid_R_c","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"sum_c sum_μ = 1^N^ab_c X^ab_cμcirc (X^ab_cμ)^dagger = mathrmid_R_a  R_b","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The tensors X^ab_cμ are the splitting tensors, and their hermitian conjugate are the fusion tensors. They are only determined up to a unitary basis transform within the space, i.e., acting on the multiplicity label μ = 1  N^ab_c. For mathsfSU_2, N^ab_c is zero or one and the entries of X^ab_c are precisely given by the CG coefficients.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The topological data of category describes the following transformation:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"F-move or recoupling: the transformation from (R_a  R_b)  R_c to   R_a  (R_b  R_c):\n(X^ab_eμ  mathrmid_c)  X^ec_dν = _fκλ F^abc_d_eμν^fκλ (mathrmid_a  X^bc_fκ)  X^af_dλ\nBraiding τ_ab R_a  R_b  R_b  R_a:\nτ_ab  X^ab_cμ = _ν R^ab_c^ν_μ X^ba_cν","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The dimensions of the spaces R_a on which representation a acts are denoted as d_a and referred to as quantum dimensions. In particular, d_u = 1 and d_a = d_bara. This information is also encoded in the F-symbol as d_a =  F^a bara a_a^u_u ^-1. Note that there are no multiplicity labels in this particular F-symbol as N^abara_u = 1.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Graphically:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: summary)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For the implementation, it will be useful to distinguish between the number of different possibilities regarding the fusion rules. If, for every a and b, there is a unique c such that a  b = c (i.e. N^ab_c = 1 and N^ab_c = 0 for all other c), the category is abelian. The representations of a group have this property if and only if the group multiplication law is commutative. In this case, all spaces R_a associated with the representation are one-dimensional and thus trivial. In all other cases, the category is non-abelian. We find it useful to further distinguish between categories which have all N^ab_c equal to zero or one (such that no multiplicity labels are needed), e.g. the representations of mathsfSU_2, and those where some N^ab_c are larger than one, e.g. the representations of mathsfSU_3.","category":"page"},{"location":"man/sectors/#ss_sectors","page":"Sectors, representation spaces and fusion trees","title":"Sectors","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We introduce an abstract type to represent sectors","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type Sector end","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Any concrete subtype of Sector should be such that its instances represent a consistent set of sectors, corresponding to the irreps of a group, or, more generally, the simple objects of an unitary fusion category.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Throughout TensorLabXD.jl, the method sectortype can be used to query the subtype of Sector associated with an object, e.g., a vector space, fusion tree, tensor map, or a sector. It works on both instances and types.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The data that needed to specify a sector type are:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"the fusion rules a  b =  N^ab_c c: Nsymbol(a,b,c)\nthe list of fusion outputs from a  b: while this information is contained in   N^ab_c, it might be costly or impossible to iterate over all possible values of   c and test Nsymbol(a,b,c); instead we implement for a ⊗ b to return an iterable   object which generates all c with N^ab_c  0 (just once even if N^ab_c1)\nthe identity object u, such that a  u = a = u  a: one(a)\nthe dual or conjugate representation overlinea for which   N^abara_u = 1: conj(a); dual(a) also works as alias, but conj(a) is the   method that should be defined\nthe F-symbol: Fsymbol(a,b,c,d,e,f)\nthe R-symbol: Rsymbol(a,b,c)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For practical reasons, we also require some additional methods to be defined:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"isreal(::Type{<:Sector}) returns whether the topological data of this type of sector   is real-valued or not. Note that this does not necessarily require that the   representation itself, or the Clebsch-Gordan coefficients, are real. There is a fallback   implementation that checks whether the F-symbol and R-symbol evaluated with all sectors   equal to the identity sector have real eltype.\nhash(a, h) creates a hash of sectors, because sectors and objects created from them   are used as keys in dictionaries.\nisless(a,b) associates a canonical order to sectors of the same type, in order to   unambiguously represent representation spaces V = _a ℂ^n_a  R_a.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The quantum dimensions d_a and Frobenius-Schur indicator χ_a are encoded in the F-symbol. These functions have default definitions, and should be overloaded if the value can be computed more efficiently.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We define a parametric type to represent an indexable iterator over the instances of a sector type as","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SectorValues{I<:Sector} end\nBase.IteratorEltype(::Type{<:SectorValues}) = HasEltype()\nBase.eltype(::Type{SectorValues{I}}) where {I<:Sector} = I\nBase.values(::Type{I}) where {I<:Sector} = SectorValues{I}()","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"An instance of the singleton type SectorValues{I<:Sector} is obtained as values(I). A new sector I<:Sector should implement","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.iterate(::SectorValues{I}[, state]) = ...\nBase.IteratorSize(::Type{SectorValues{I}}) = # HasLenght() or IsInfinite()\n# if previous function returns HasLength():\nBase.length(::SectorValues{I}) = ...\nBase.getindex(::SectorValues{I}, i::Int) = ...\nfindindex(::SectorValues{I}, c::I) = ...","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If the number of values in a sector I is finite (i.e. IteratorSize(values(I)) == HasLength()), the methods getindex and findindex provide a way to map the different sector instances from and to the standard range 1, 2, …, length(values(I)). This will be used to efficiently represent GradedSpace objects for this type of sector.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"It is useful to distinguish between three cases with respect to the fusion rules:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type FusionStyle end\nstruct UniqueFusion <: FusionStyle # unique fusion output when fusion two sectors\nend\nabstract type MultipleFusion <: FusionStyle end\nstruct SimpleFusion <: MultipleFusion # multiple fusion output but multiplicity free\nend\nstruct GenericFusion <: MultipleFusion # multiple fusion output with multiplicities\nend\nconst MultiplicityFreeFusion = Union{UniqueFusion, SimpleFusion}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"New sector types I<:Sector should then indicate which fusion style they have by defining FusionStyle(::Type{I}).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"In a similar manner, it is useful to distinguish between different styles of braiding:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type BraidingStyle end\nstruct NoBraiding <: BraidingStyle end\nabstract type HasBraiding <: BraidingStyle end\nstruct Anyonic <: HasBraiding end\nabstract type SymmetricBraiding <: HasBraiding end\nstruct Bosonic <: SymmetricBraiding end # all twists are one\nstruct Fermionic <: SymmetricBraiding end # twists one and minus one","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"New sector types I<:Sector should then indicate which braiding style they have by defining BraidingStyle(::Type{}). Note that Bosonic() braiding does not mean that all permutations are trivial and R^ab_c = 1, but that R^ab_c R^ba_c = 1. For example, for the irreps of mathsfSU_2, the R-symbol associated with the fusion of two spin-1/2 particles to spin zero is -1, i.e. the singlet of two spin-1/2 particles is antisymmetric. For a Bosonic() braiding style, all twists are +1.","category":"page"},{"location":"man/sectors/#sss_groups","page":"Sectors, representation spaces and fusion trees","title":"Existing group representations","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The first sector type is called Trivial, and corresponds to the case where there is actually no symmetry. Thus, the trivial symmetry group has only an identity operation and a trivial representation:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct Trivial <: Sector\nend\nBase.one(a::Sector) = one(typeof(a))\nBase.one(::Type{Trivial}) = Trivial()\nBase.conj(::Trivial) = Trivial()\n⊗(::Trivial, ::Trivial) = (Trivial(),)\nNsymbol(::Trivial, ::Trivial, ::Trivial) = true\nFsymbol(::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial) = 1\nRsymbol(::Trivial, ::Trivial, ::Trivial) = 1\nBase.isreal(::Type{Trivial}) = true\nFusionStyle(::Type{Trivial}) = UniqueFusion()\nBraidingStyle(::Type{Trivial}) = Bosonic()","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The Trivial sector type is special cased in the construction of tensors, so that most of these definitions are not actually used.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The most important class of sectors are irreducible representations of groups, for which we have an abstract supertype AbstractIrrep{G} that is parameterized on the type of group G. One can obtain a concrete type as Irrep[G] without of knowing its name.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type AbstractIrrep{G<:Group} <: Sector end","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"A number of groups have been defined:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"abstract type Group end\nabstract type SU{N} <: Group end\nconst SU₂ = SU{2}\nabstract type CU₁ <: Group end\n\nabstract type AbelianGroup <: Group end\nabstract type ℤ{N} <: AbelianGroup end\nconst ℤ₂ = ℤ{2}\nconst ℤ₃ = ℤ{3}\nconst ℤ₄ = ℤ{4}\nabstract type U₁ <: AbelianGroup end","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Groups themselves are abstract types without any functionality (at least for now). We also provide a number of convenient Unicode aliases.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For all group irreps, the braiding style is bosonic","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"BraidingStyle(::Type{<:AbstractIrrep}) = Bosonic()","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We gather some more common functionality for irreps of abelian groups (which exhaust all possibilities of fusion categories with abelian fusion):","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"const AbelianIrrep{G} = AbstractIrrep{G} where {G<:AbelianGroup}\n\nFusionStyle(::Type{<:AbelianIrrep}) = UniqueFusion()\nBase.isreal(::Type{<:AbelianIrrep}) = true\n\nNsymbol(a::I, b::I, c::I) where {I<:AbelianIrrep} = c == first(a ⊗ b)\nFsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I<:AbelianIrrep} =\n    Int(Nsymbol(a, b, e)*Nsymbol(e, c, d)*Nsymbol(b, c, f)*Nsymbol(a, f, d))\nfrobeniusschur(a::AbelianIrrep) = 1\nBsymbol(a::I, b::I, c::I) where {I<:AbelianIrrep} = Int(Nsymbol(a, b, c))\nRsymbol(a::I, b::I, c::I) where {I<:AbelianIrrep} = Int(Nsymbol(a, b, c))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"With these common definition, we implement the representation theory of the two most common Abelian groups ℤ_N and mathsfU_1.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct ZNIrrep{N} <: AbstractIrrep{ℤ{N}}\n    n::Int8\n    function ZNIrrep{N}(n::Integer) where {N}\n        @assert N < 64\n        new{N}(mod(n, N))\n    end\nend\nBase.getindex(::IrrepTable, ::Type{ℤ{N}}) where N = ZNIrrep{N}\nBase.convert(Z::Type{<:ZNIrrep}, n::Real) = Z(n)\n\nBase.one(::Type{ZNIrrep{N}}) where {N} =ZNIrrep{N}(0)\nBase.conj(c::ZNIrrep{N}) where {N} = ZNIrrep{N}(-c.n)\n⊗(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = (ZNIrrep{N}(c1.n+c2.n),)\nBase.hash(c::ZNIrrep{N}, h::UInt) where {N} = hash(c.n, h)\nBase.isless(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = isless(c1.n, c2.n)\n\nBase.IteratorSize(::Type{SectorValues{ZNIrrep{N}}}) where N = HasLength()\nBase.iterate(::SectorValues{ZNIrrep{N}}, i = 0) where N =\n    return i == N ? nothing : (ZNIrrep{N}(i), i+1)\nBase.length(::SectorValues{ZNIrrep{N}}) where N = N\nBase.getindex(::SectorValues{ZNIrrep{N}}, i::Int) where N =\n    1 <= i <= N ? ZNIrrep{N}(i-1) : throw(BoundsError(values(ZNIrrep{N}), i))\nfindindex(::SectorValues{ZNIrrep{N}}, c::ZNIrrep{N}) where N = c.n + 1","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The getindex definition just below the type definition provides the mechanism to get the concrete type as Irrep[G] for a given group G. Here, IrrepTable is the singleton type of which the constant Irrep is the only instance. The Base.convert definition allows to convert real numbers to the instance of corresponding sector, and thus to omit the type information of the sector whenever this is clear from the context.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Since sectors or objects made out of tuples of sectors (see the section on Fusion Trees below) are often used as keys in look-up tables (i.e. subtypes of AbstractDictionary in Julia), it is important that they can be hashed efficiently. We just hash the sectors above based on their numerical value.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For ZNIrrep{N}, we use an Int8 for compact storage, assuming that this type will not be used with N>64 (we need 2*(N-1) <= 127 in order for a ⊗ b to work correctly). We also define some aliases for the first (and most commonly used ℤ{N} irreps)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"const Z2Irrep = ZNIrrep{2}\nconst Z3Irrep = ZNIrrep{3}\nconst Z4Irrep = ZNIrrep{4}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"so that we can do","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"z = Z3Irrep(1)\nZNIrrep{3}(1) ⊗ Irrep[ℤ₃](1)\nconj(z)\none(z)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct U1Irrep <: AbstractIrrep{U₁}\n    charge::HalfInt\nend\nBase.getindex(::IrrepTable, ::Type{U₁}) = U1Irrep\nBase.convert(::Type{U1Irrep}, c::Real) = U1Irrep(c)\n\nBase.one(::Type{U1Irrep}) = U1Irrep(0)\nBase.conj(c::U1Irrep) = U1Irrep(-c.charge)\n⊗(c1::U1Irrep, c2::U1Irrep) = (U1Irrep(c1.charge+c2.charge),)\nBase.hash(c::U1Irrep, h::UInt) = hash(c.charge, h)\nBase.isless(c1::U1Irrep, c2::U1Irrep) where {N} =\n    isless(abs(c1.charge), abs(c2.charge)) || zero(HalfInt) < c1.charge == -c2.charge\n\nBase.IteratorSize(::Type{SectorValues{U1Irrep}}) = IsInfinite()\nBase.iterate(::SectorValues{U1Irrep}, i = 0) =\n    return i <= 0 ? (U1Irrep(half(i)), (-i + 1)) : (U1Irrep(half(i)), -i)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"In the definition of U1Irrep, HalfInt<:Number is a Julia type defined in HalfIntegers.jl, which is also used for SU2Irrep below, that stores integer or half integer numbers using twice their value. Strictly speaking, the linear representations of U₁ can only have integer charges, and fractional charges lead to a projective representation. It can be useful to allow half integers in order to describe spin 1/2 systems with an axis rotation symmetry. As a user, you should not worry about the details of HalfInt, and additional methods for automatic conversion and pretty printing are provided, as illustrated by the following example","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Irrep[U₁](0.5)\nU1Irrep(0.4)\nU1Irrep(1) ⊗ Irrep[U₁](1//2)\nu = first(U1Irrep(1) ⊗ Irrep[U₁](1//2))\nNsymbol(u, conj(u), one(u))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"A non-abelian representation category is that of mathsfSU_2:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SU2Irrep <: AbstractIrrep{SU{2}}\n    j::HalfInt\nend\n\nBase.one(::Type{SU2Irrep}) = SU2Irrep(zero(HalfInt))\nBase.conj(s::SU2Irrep) = s\n⊗(s1::SU2Irrep, s2::SU2Irrep) = SectorSet{SU2Irrep}(abs(s1.j-s2.j):(s1.j+s2.j))\ndim(s::SU2Irrep) = twice(s.j)+1\nFusionStyle(::Type{SU2Irrep}) = SimpleFusion()\nBase.isreal(::Type{SU2Irrep}) = true\nNsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep) = WignerSymbols.δ(sa.j, sb.j, sc.j)\nFsymbol(s1::SU2Irrep, s2::SU2Irrep, s3::SU2Irrep,\n        s4::SU2Irrep, s5::SU2Irrep, s6::SU2Irrep) =\n    WignerSymbols.racahW(s1.j, s2.j, s4.j, s3.j, s5.j, s6.j)*sqrt(dim(s5)*dim(s6))\nfunction Rsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep)\n    Nsymbol(sa, sb, sc) || return 0.\n    iseven(convert(Int, sa.j+sb.j-sc.j)) ? 1.0 : -1.0\nend\n\nBase.IteratorSize(::Type{SectorValues{SU2Irrep}}) = IsInfinite()\nBase.iterate(::SectorValues{SU2Irrep}, i = 0) = (SU2Irrep(half(i)), i+1)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The topological data (Nsymbol and Fsymbol) are provided by the package WignerSymbols.jl.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Some examples:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"s = SU2Irrep(3//2)\nconj(s)\ndim(s)\ncollect(s ⊗ s)\nfor s2 in s ⊗ s\n    @show s2\n    @show Nsymbol(s, s, s2)\n    @show Rsymbol(s, s, s2)\nend","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Another non-abelian representation theory is that of the semidirect product mathsfU₁  ℤ_2, where in the context of quantum systems, this occurs in the case of systems with particle hole symmetry and the non-trivial element of ℤ_2 acts as charge conjugation C. It has the effect of interchanging mathsfU_1 irreps n and -n, and turns them together in a joint 2-dimensional index, except for the case n=0. Irreps are therefore labeled by integers n  0, however for n=0 the ℤ₂ symmetry can be realized trivially or non-trivially, resulting in an even and odd one- dimensional irrep with mathsfU_1 charge 0. Given mathsfU_1  mathsfSO_2, this group is also simply known as mathsfO_2, and the two representations with n = 0 are the scalar and pseudo-scalar, respectively. However, because we also allow for half integer representations, we refer to it as Irrep[CU₁] or CU1Irrep in full.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct CU1Irrep <: AbstractIrrep{CU₁}\n    j::HalfInt # value of the U1 charge\n    s::Int # rep of charge conjugation:\n    # if j == 0, s = 0 (trivial) or s = 1 (non-trivial),\n    # else s = 2 (two-dimensional representation)\n    # Let constructor take the actual half integer value j\n    function CU1Irrep(j::Real, s::Int = ifelse(j>zero(j), 2, 0))\n        if ((j > zero(j) && s == 2) || (j == zero(j) && (s == 0 || s == 1)))\n            new(j, s)\n        else\n            error(\"Not a valid CU₁ irrep\")\n        end\n    end\nend\n\nBase.one(::Type{CU1Irrep}) = CU1Irrep(zero(HalfInt), 0)\nBase.conj(c::CU1Irrep) = c\ndim(c::CU1Irrep) = ifelse(c.j == zero(HalfInt), 1, 2)\n\nFusionStyle(::Type{CU1Irrep}) = SimpleFusion()\n...","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The rest of the implementation can be read in the source code, but is rather long due to all the different cases for the arguments of Fsymbol.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"So far, no sectors have been implemented with FusionStyle(G) == GenericFusion(), though an example would be the representation theory of mathsfSU_N for N>2. Such sectors are not yet fully supported; certain operations remain to be implemented. The topological data of the representation theory of such groups is not readily available and needs to be computed.","category":"page"},{"location":"man/sectors/#sss_productsectors","page":"Sectors, representation spaces and fusion trees","title":"Combining different sectors","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"It is also possible to define two or more different types of symmetries, e.g. when the total symmetry group is a direct product of individual simple groups. Such sectors are obtained using the binary operator ⊠, which can be entered as \\boxtimes+TAB.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Some examples","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"a = Z3Irrep(1) ⊠ Irrep[U₁](1)\ntypeof(a)\nconj(a)\none(a)\ndim(a)\ncollect(a ⊗ a)\nFusionStyle(a)\nb = Irrep[ℤ₃](1) ⊠ Irrep[SU₂](3//2)\ntypeof(b)\nconj(b)\none(b)\ndim(b)\ncollect(b ⊗ b)\nFusionStyle(b)\nc = Irrep[SU₂](1) ⊠ SU2Irrep(3//2)\ntypeof(c)\nconj(c)\none(c)\ndim(c)\ncollect(c ⊗ c)\nFusionStyle(c)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We refer to the source file of ProductSector for implementation details.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The symbol ⊠ refers to the Deligne tensor product within the literature on category theory. The category of representation of a product group G₁ × G₂ corresponds the Deligne tensor product of the categories of representations of the two groups separately. This definition also extends to general 𝕜-linear categories. Note that ⊠ also works in the type domain, i.e. Irrep[ℤ₃] ⊠ Irrep[CU₁] can be used to create ProductSector{Tuple{Irrep[ℤ₃], Irrep[CU₁]}}. Instances of this type can be constructed by giving a number of arguments, where the first argument is used to construct the first sector, and so forth. For representations of groups, we also enabled the notation Irrep[ℤ₃ × CU₁], with × obtained using \\times+TAB. However, this is merely for convience; as Irrep[ℤ₃] ⊠ Irrep[CU₁] is not a subtype of the abstract type AbstractIrrep{ℤ₃ × CU₁}.  ","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Some examples:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"a = Z3Irrep(1) ⊠ Irrep[CU₁](1.5)\na isa Irrep[ℤ₃] ⊠ CU1Irrep\na isa Irrep[ℤ₃ × CU₁]\na isa Irrep{ℤ₃ × CU₁}\na == Irrep[ℤ₃ × CU₁](1, 1.5)","category":"page"},{"location":"man/sectors/#sss_newsectors","page":"Sectors, representation spaces and fusion trees","title":"Defining a new type of sector","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"By now, it should be clear how to implement a new Sector subtype. Ideally, a new I<:Sector type is a struct I ... end (immutable) that has isbitstype(I) == true, and implements the following minimal set of methods","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Base.one(::Type{I}) = I(...)\nBase.conj(a::I) = I(...)\nBase.isreal(::Type{I}) = ... # true or false\nTensorLabXD.FusionStyle(::Type{I}) = ... # UniqueFusion(), SimpleFusion(), GenericFusion()\nTensorLabXD.BraidingStyle(::Type{I}) = ... # Bosonic(), Fermionic(), Anyonic()\nTensorLabXD.Nsymbol(a::I, b::I, c::I) = ... # Bool or Integer\nBase.:⊗(a::I, b::I) = ... # some iterable object that generates all possible fusion outputs\nTensorLabXD.Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I)\nTensorLabXD.Rsymbol(a::I, b::I, c::I)\nBase.hash(a::I, h::UInt)\nBase.isless(a::I, b::I)\nBase.iterate(::TensorLabXD.SectorValues{I}[, state]) = ...\nBase.IteratorSize(::Type{TensorLabXD.SectorValues{I}}) = ... # HasLenght() or IsInfinite()\n# if previous function returns HasLength():\nBase.length(::TensorLabXD.SectorValues{I}) = ...\nBase.getindex(::TensorLabXD.SectorValues{I}, i::Int) = ...\nTensorLabXD.findindex(::TensorLabXD.SectorValues{I}, c::I) = ...","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Additionally, suitable definitions can be given for","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TensorLabXD.dim(a::I) = ...\nTensorLabXD.frobeniusschur(a::I) = ...\nTensorLabXD.Bsymbol(a::I, b::I, c::I) = ...","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"There is a default implementation for these three functions that just relies on Fsymbol, and alternative definitions need to be given only if a more efficient version is available.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If FusionStyle(I) == GenericFusion(), then the multiple outputs c in the tensor product of a and b will be labeled as i=1, 2, …, Nsymbol(a,b,c). Optionally, a different label can be provided by defining","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TensorLabXD.vertex_ind2label(i::Int, a::I, b::I, c::I) = ...\n# some label, e.g. a `Char` or `Symbol`","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The following function will then automatically determine the corresponding label type (which should not vary, i.e. vertex_ind2label should be type stable)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"vertex_labeltype(I::Type{<:Sector}) =\n    typeof(vertex_ind2label(1, one(I), one(I), one(I)))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The following type, which already appeared in the implementation of SU2Irrep above, can be useful for providing the return type of a ⊗ b","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct SectorSet{I<:Sector,F,S}\n    f::F\n    set::S\nend\n...\nfunction Base.iterate(s::SectorSet{I}, args...) where {I<:Sector}\n    next = iterate(s.set, args...)\n    next === nothing && return nothing\n    val, state = next\n    return convert(I, s.f(val)), state\nend","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"That is, SectorSet(f, set) behaves as an iterator that applies x->convert(I, f(x)) on the elements of set; if f is not provided it is just taken as the function identity.","category":"page"},{"location":"man/sectors/#sss_generalsectors","page":"Sectors, representation spaces and fusion trees","title":"Generalizations","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The framework for sectors outlined above depends is in one-to-one correspondence to the topological data for specifying a unitary (spherical and braided, and hence ribbon) fusion category. For such general categories, the objects are not necessarily vector spaces and the fusion and splitting tensors X^ab_cμ do not necessarily exist as actual tensors. The morphism spaces c  a  b still behave as vector spaces, and the X^ab_cμ acts as generic basis for that space. As TensorLabXD.jl does not rely on the X^ab_cμ themselves it can also deal with such general fusion categories. When X^ab_cμ does exist, it is available as fusiontensor(a,b,c[,μ]) and can be useful for checking purposes.","category":"page"},{"location":"man/sectors/#ss_rep","page":"Sectors, representation spaces and fusion trees","title":"Graded spaces","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We introduce a type GradedSpace to represent general objects of a fusion category, which can be decomposed as a direct sum of simple objects represented by Sector:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct GradedSpace{I<:Sector, D} <: EuclideanSpace{ℂ}\n    dims::D\n    dual::Bool\nend","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Here, D is a type parameter to denote the data structure used to store the degeneracy or multiplicity dimensions n_a of the different sectors.","category":"page"},{"location":"man/sectors/#Implementation-details","page":"Sectors, representation spaces and fusion trees","title":"Implementation details","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The way in which the degeneracy dimensions n_a are stored depends on the IteratorSize of values(I). If it is Union{IsInfinite, SizeUnknown}, the sectors aand their corresponding degeneracy n_a are stored as key value pairs in a dictionary dims::SectorDict. Only sectors a for which n_aneq 0 are stored. Here, SectorDict is a constant type alias for a specific dictionary implementation, which currently resorts to SortedVectorDict implemented in TensorLabXD.jl. Hence, the sectors and their corresponding dimensions are stored as two matching lists (Vector instances), which are ordered based on the property isless(a::I, b::I). This ensures that the space V = _a ℂ^n_a  R_a has some unique canonical order in the direct sum decomposition.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If IteratorSize(values(I)) isa Union{HasLength, HasShape}, the degeneracy dimensions n_a are stored for all sectors a ∈ values(I) in a tuple NTuple{N, Int} with N = length(values(I)). The methods getindex(values(I), i) and findindex(values(I), a) are used to map between a sector a ∈ values(I) and a corresponding index i ∈ 1:N. As N is a compile time constant, these types can be created in a type stable manner.","category":"page"},{"location":"man/sectors/#Constructing-instances","page":"Sectors, representation spaces and fusion trees","title":"Constructing instances","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The method Vect[I] will return the concrete type GradedSpace{I,D} with the matching value of D. For consistency, Vect[Trivial] will just return a ComplexSpace, which is not even a type of GradedSpace. There is also the Unicode alias ℂ[I], and for the case of group irreps as sectors, one can use Rep[G] with G the group, as inspired by the categorical name mathbfRep_mathsfG.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Some illustrations:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"ℂ[]\nℂ[Trivial]\nVect[Trivial]\nVect[U1Irrep]\nℂ[Irrep[U₁]]\nRep[U₁]\nRep[ℤ₂ × SU₂]\nVect[Irrep[ℤ₂ × SU₂]]","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For some groups we have a number of alias, both in ASCII and using Unicode:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"# ASCII type aliases\nconst ZNSpace{N} = GradedSpace{ZNIrrep{N}, NTuple{N,Int}}\nconst Z2Space = ZNSpace{2}\nconst Z3Space = ZNSpace{3}\nconst Z4Space = ZNSpace{4}\nconst U1Space = Rep[U₁]\nconst CU1Space = Rep[CU₁]\nconst SU2Space = Rep[SU₂]\n\n# Unicode alternatives\nconst ℤ₂Space = Z2Space\nconst ℤ₃Space = Z3Space\nconst ℤ₄Space = Z4Space\nconst U₁Space = U1Space\nconst CU₁Space = CU1Space\nconst SU₂Space = SU2Space","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"To create specific instances of those types, one can e.g. use V = GradedSpace(a=>n_a, b=>n_b, c=>n_c) or V = GradedSpace(iterator) where iterator is any iterator (e.g. a dictionary or a generator) that yields Pair{I,Int} instances. With those constructions, I is inferred from the type of sectors. It is often more convenient to specify the sector type explicitly (using one of the many alias provided), since then the sectors are automatically converted to the correct type; compare","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Vect[Irrep[U₁]](0=>3, 1=>2, -1=>1) ==\n    GradedSpace(U1Irrep(0)=>3, U1Irrep(1)=>2, U1Irrep(-1)=>1) == U1Space(0=>3, 1=>2, -1=>1)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The Rep[G] also works with product groups:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Rep[ℤ₂ × SU₂]((0,0) => 3, (1,1/2) => 2, (0,1) => 1) == GradedSpace((Z2Irrep(0) ⊠ SU2Irrep(0)) => 3, (Z2Irrep(1) ⊠ SU2Irrep(1/2)) => 2, (Z2Irrep(0) ⊠ SU2Irrep(1)) => 1)","category":"page"},{"location":"man/sectors/#Methods","page":"Sectors, representation spaces and fusion trees","title":"Methods","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"There are a number of methods to work with instances V of GradedSpace.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The function sectors returns an iterator over the different sectors a with non-zero n_a, and for other ElementarySpace types it returns (Trivial(),).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The degeneracy dimensions n_a can be extracted as dim(V, a), it properly returns 0 if sector a is not present in the decomposition of V.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"With hassector(V, a) one can check if V contains a sector a with dim(V,a)>0.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The dim(V) returns the total dimension of the space V, i.e. _a n_a d_a.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If a representation space V has certain sectors a with dimensions n_a, then its dual V' will have sectors dual(a), and dim(V', dual(a)) == n_a.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Other methods for ElementarySpace, such as dual, fuse and flip also work. In fact, GradedSpace is the reason flip exists. The existence of flip originates from the non-trivial isomorphism between R_overlinea and R_a^*, i.e. the representation space of the dual overlinea of sector a and the dual of the representation space of sector a. If V = GradedSpace(a=>n_a,...), then flip(V) = dual(GradedSpace(dual(a)=>n_a,....)). Hence, flip(V) to be isomorphic to V.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For two spaces V1 = GradedSpace(a=>n1_a, ...) and V2 = GradedSpace(a=>n2_a, ...), we have infimum(V1,V2) = GradedSpace(a=>min(n1_a,n2_a), ....) and similarly for supremum. They act on the degeneracy dimensions of every sector separately. Therefore, it can be that the return value of infimum(V1,V2) or supremum(V1,V2) is neither equal to V1 or V2.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For W a ProductSpace{Vect[I], N}, sectors(W) returns an iterator that generates all possible combinations of sectors as represented as NTuple{I,N}. The function dims(W, as) returns the corresponding tuple with degeneracy dimensions, while dim(W, as) returns the product of these dimensions. hassector(W, as) is equivalent to dim(W, as)>0. The function blocksectors(W) which returns a list (of type Vector) with all possible \"block sectors\" that can result from fusing the individual uncoupled sectors in W. Correspondingly, blockdim(W, a) counts the total degeneracy dimension of the coupled sector a in W.","category":"page"},{"location":"man/sectors/#Examples","page":"Sectors, representation spaces and fusion trees","title":"Examples","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Let's start with an example involving mathsfU_1:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"V1 = Rep[U₁](0=>3, 1=>2, -1=>1)\nV1 == U1Space(0=>3, 1=>2, -1=>1) == U₁Space(-1=>1, 1=>2,0=>3) # order doesn't matter\n(sectors(V1)...,)\ndim(V1, U1Irrep(1))\ndim(V1', Irrep[U₁](1)) == dim(V1, conj(U1Irrep(1))) == dim(V1, U1Irrep(-1))\nhassector(V1, Irrep[U₁](1))\nhassector(V1, Irrep[U₁](2))\ndual(V1)\nflip(V1)\ndual(V1) ≅ V1\nflip(V1) ≅ V1\nV2 = U1Space(0=>2, 1=>1, -1=>1, 2=>1, -2=>1)\ninfimum(V1, V2)\nsupremum(V1, V2)\n⊕(V1,V2)\nW = ⊗(V1,V2)\ncollect(sectors(W))\ndims(W, (Irrep[U₁](0), Irrep[U₁](0)))\ndim(W, (Irrep[U₁](0), Irrep[U₁](0)))\nhassector(W, (Irrep[U₁](0), Irrep[U₁](0)))\nhassector(W, (Irrep[U₁](2), Irrep[U₁](0)))\nfuse(W)\n(blocksectors(W)...,)\nblockdim(W, Irrep[U₁](0))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and then with mathsfSU_2:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"V1 = ℂ[Irrep[SU₂]](0=>3, 1//2=>2, 1=>1)\nV1 == SU2Space(0=>3, 1/2=>2, 1=>1) == SU₂Space(0=>3, 0.5=>2, 1=>1)\n(sectors(V1)...,)\ndim(V1, SU2Irrep(1))\ndim(V1', SU2Irrep(1)) == dim(V1, conj(SU2Irrep(1))) == dim(V1, Irrep[SU₂](1))\ndim(V1)\nhassector(V1, Irrep[SU₂](1))\nhassector(V1, Irrep[SU₂](2))\ndual(V1)\nflip(V1)\nV2 = SU2Space(0=>2, 1//2=>1, 1=>1, 3//2=>1, 2=>1)\ninfimum(V1, V2)\nsupremum(V1, V2)\n⊕(V1,V2)\nW = ⊗(V1,V2)\ncollect(sectors(W))\ndims(W, (Irrep[SU₂](0), Irrep[SU₂](0)))\ndim(W, (Irrep[SU₂](0), Irrep[SU₂](0)))\nhassector(W, (SU2Irrep(0), SU2Irrep(0)))\nhassector(W, (SU2Irrep(2), SU2Irrep(0)))\nfuse(W)\n(blocksectors(W)...,)\nblockdim(W, SU2Irrep(0))","category":"page"},{"location":"man/sectors/#ss_fusiontrees","page":"Sectors, representation spaces and fusion trees","title":"Fusion trees","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The gain in efficiency obtained from using symmetric equivariant tensor maps is that, by Schur's lemma, they are block diagonal in the basis of coupled sectors. To exploit this block diagonal form, it is essential that we know the basis transform from the individual uncoupled sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The basis of the map from R_c to R_a_1  R_a_2    R_a_N are written as X^a_1a_2a_N_cα R_c  R_a_1  R_a_2    R_a_N, which satisfy","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(X^a_1a_2a_N_cα)^  X^a_1a_2a_N_cα = δ_cc δ_αα mathrmid_c","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"and","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"_cα X^a_1a_2a_N_cα  (X^a_1a_2a_N_cα)^  = mathrmid_a_1  a_2    a_N = mathrmid_a_1  mathrmid_a_2    mathrmid_a_N","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Fusion-splitting trees provide a particular way to construct such a basis. The following subsections discuss the canonical representation of fusion-splitting trees and possible manipulations that can be performed.","category":"page"},{"location":"man/sectors/#Canonical-representation","page":"Sectors, representation spaces and fusion trees","title":"Canonical representation","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"In the canonical representation of a tensor map, the domain takes the form (((W_1  W_2)  W_3)   ) W_N_2), and the codomain takes the form (((V_1  V_2)  V_3)   ) V_N_1).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Graphically, a fusion-splitting tree representation of a tensor map with N_1=4 and N_2=3 is","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: double fusion tree)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We can separate this tree into the fusion part ((b_1b_2)b_3)  c and the splitting part c(((a_1a_2)a_3)a_4). The fusion tree can be considered to be the adjoint of a splitting tree c((b_1b_2)b_3).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"A splitting tree which goes from one coupled sector c to N uncoupled sectors a_1, a_2, …,a_N needs N-2 additional labels e_1, …, e_N-2 to represent the sectors of the internal lines. If FusionStyle(I) isa UniqueFusion, the internal sectors are completely fixed by the coupled and uncoupled sectors. If FusionStyle(I) isa MultipleFusion, they can take different values that satisfy the fusion rules.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If FusionStyle(I) isa GenericFusion, we also need N-1 additional labels μ_1, …, μ_N-1 on vertices of the splitting tree to represent the multiplicity of the fusion rule.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"In our notation of the splitting basis X^a_1a_2a_N_cα used above, α is a collective label, i.e. α = (e_1  e_N-2 μ₁  μ_N-1). The orthogonality condition (X^a_1a_2a_N_cα)^  X^a_1a_2a_N_cα = δ_cc δ_αα mathrmid_c, forces all internal lines e_k and vertex labels μ_l to be the same.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We represent splitting trees by a specific immutable type called FusionTree, defined as","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"struct FusionTree{I<:Sector,N,M,L,T}\n    uncoupled::NTuple{N,I}\n    coupled::I\n    isdual::NTuple{N,Bool}\n    innerlines::NTuple{M,I} # M = N-2\n    vertices::NTuple{L,T} # L = N-1\nend","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The uncoupled field is a list of N outgoing uncoupled sectors of the splitting tree in sequence a_1a_2a_N.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The coupled field is the single input sector of the splitting tree.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The isdual field indicates whether an isomorphism Z is present or not for each uncoupled sectors. The presence of these isomorphisms will be important when we start to bend lines, e.g., to move uncoupled sectors from the incoming to the outgoing part of the fusion-splitting tree. In category language, a^* is the dual space of a on which the conjugated irrep acts, while bara is the space in the chosen set of simple objects and the corresponding irrep on it is isomorphic to the complex conjugate of irrep on a. In our package, we define dual(a) as bara. To obtain a^*, we need use the isomorphisms Z_a a^*  bara and its adjoint Z_a^baraa^*.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Note that the field uncoupled contains the sectors coming out of the splitting trees before the possible Z isomorphism. For example, the splitting tree in the following graph has uncoupled = (a₁, a₂, a₃, a₄):","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: extended double fusion tree)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Note that we can still represent a fusion tree as the adjoint of its corresponding splitting tree, since we use the Z isomorphism in the fusion part, and the Z^dagger isomorphisms in the splitting part. The presence of the Z isomorphisms do not affect the orthonormality since Z_a^dagger circ Z_a = mathrmid_a^* and Z_acirc Z_a^dagger = mathrmid_bara.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The innerlines is a list of sectors on the inner lines of the splitting tree in the order that follows the sequence of the fusion. For example, the first inner line is the fusion of the first two uncoupled sector, and the second inner line is the fusion of the first inner line and the third uncoupled sector.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The vertices is a list of labels on the vertices of the splitting tree in the order that follows the sequence of the fusion. For example, the first vertex label is the label for the fusion of the first two uncoupled sector, and the second vertex label is the label for fusion of the first inner line and the third uncoupled sector.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The type T of the vertex labels is defined by the function vertex_ind2label for the sector I, and can be Nothing when FusionStyle(I) isa MultiplicityFreeFusion.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The FusionTree type has a number of basic properties and capabilities, such as checking for equality with == and support for hash(f::FusionTree, h::UInt), as splitting and fusion trees are used as keys in AbstractDictionary instances to look up certain parts of the data of a tensor map.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The FusionTree instances are not checked for consistency (i.e. valid fusion rules etc) upon creation, hence, they are assumed to be created correctly. They can be created by the method","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"fusiontrees(uncoupled::NTuple{N, I}, coupled::I = one(I),\n    isdual::NTuple{N, Bool} = ntuple(n->false, Val(N))) where {N, I<:Sector}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"which returns an iterator FusionTreeIterator over all possible splitting trees with fixed uncoupled and coupled sectors. The FusionTreeIterator conforms to the complete interface of an iterator, and has a custom length function that computes the number of possible fusion trees without iterating over all of them explicitly. For example:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"s = Irrep[SU₂](1/2)\ncollect(fusiontrees((s,s,s,s)))\ncollect(fusiontrees((s,s,s,s,s), s, (true, false, false, true, false)))\niter = fusiontrees(ntuple(n->s, 16))\nsum(n->1, iter)\nlength(iter)\n@elapsed sum(n->1, iter)\n@elapsed length(iter)\ns2 = s ⊠ s\ncollect(fusiontrees((s2,s2,s2,s2)))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Note that FusionTree instances are shown in a way that can be copy pasted as valid code. We use contact to determine how to print a sector. In isolation, s2 is printed as (Irrep[SU₂](1/2) ⊠ Irrep[SU₂](1/2)). Within the fusion tree, it is printed as (1/2, 1/2), because it will be converted back into a ProductSector, namely Irrep[SU₂] ⊠ Irrep[SU₂] by the constructor of FusionTree{Irrep[SU₂] ⊠ Irrep[SU₂]}.","category":"page"},{"location":"man/sectors/#Planar-manipulations-on-a-splitting-tree","page":"Sectors, representation spaces and fusion trees","title":"Planar manipulations on a splitting tree","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We now discuss elementary planar manipulations (without braiding) on splitting trees. These manipulations are used as low-level methods by the TensorMap methods. As such, they are not exported by TensorLabXD.jl, nor do they overload similarly named methods from Base.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"split(f::FusionTree{I,N}, M::Int)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Split a fusion tree f into two trees f1 and f2 such that f1 has the first M uncoupled sectors of f and f2 has the remaining N-M uncoupled sectors of f. This function is type stable if M is a compile time constant. Diagrammatically, for example, M=4:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: split)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"insertat(f1::FusionTree{I,N₁}, i::Int, f2::FusionTree{I,N₂})","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Insert a fusion tree f2 at the ith uncoupled sector of fusion tree f1 and recouple this into a linear combination of trees in canonical form with N₁+N₂-1 uncoupled sectors. This requires that the coupled sector f2 matches with the ith uncoupled sector of f1, and that f1.isdual[i] == false, i.e. that there is no Z-isomorphism on the ith uncoupled sector of f1. Diagrammatically, for example, i=3:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: insertat)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"merge(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, c::I, μ=nothing)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Merge two fusion trees f1 and f2 by fusing the coupled sectors of f1 and f2 into a sector c with vertex label μ and reexpressing the result as a linear combination of fusion trees with N₁+N₂ uncoupled sectors in canonical form. Diagrammatically, it is:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: merge)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"elementary_trace(f::FusionTree{I, N}, i) where {I<:Sector, N}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Take the trace of the ith and (i+1mathrmmodN)th outgoing sectors of the splitting tree f by an evaluation map. Diagrammatically, it is:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: elementary-trace)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"planar_trace(f::FusionTree{I,N},q1::IndexTuple{N₃},\n                q2::IndexTuple{N₃}) where {I<:Sector, N, N₃}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Take the traces between q1[k]th and q2[k]th sector of the splitting tree f, where 1<=k<=N₃. All the traces must be planar, i.e., no tracing lines cross with the outgoing lines nor cross with each other. Diagrammatically, for example, q1 = (1,4,5) and q2 = (2,7,6):","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: planar-trace-splitting)","category":"page"},{"location":"man/sectors/#Planar-manipulations-on-a-fusion-splitting-tree","page":"Sectors, representation spaces and fusion trees","title":"Planar manipulations on a fusion-splitting tree","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"A fusion-splitting tree can be represented by two separate splitting trees f1 and f2, where f1 represents the splitting part and f2 represents the fusion part. Note the f2 is still a splitting tree, i.e., an instance of the FusionTree type, and the true fusion tree is the adjoint of it. We should always have f1.coupled == f2.coupled.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The order of the sectors in a fusion-splitting trees is (f1.uncoupled..., f2.uncoupled...). In other words, we label the uncoupled sectors of f1 from 1 to N₁, followed by the uncoupled sectors of f2 from N₁+1 to N₁+N₂.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"By successively applying the left coevaluation maps, we can establish isomorphisms between","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"mathrmHom((((b_1  b_2)  )  b_N_2) (((a_1  a_2)  )  a_N_1))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":" mathrmHom((((b_1  b_2)  )  b_N_2-1) ((((a_1  a_2)  )  a_N_1)  b_N_2^*))","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":" mathrmHom(1 (((((((a_1  a_2)  )  a_N_1)  b_N_2^*)  )  b_2^*)  b_1^*) )","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"where the last morphism space is labeled by the basis of only splitting trees. We can then use the manipulations from the previous subsection on the splitting trees, and then again use the left evaluation maps to bring this back to a fusion-splitting tree with N₂′ incoming and N₁′ outgoing sectors (with N₁′ + N₂′ == N₁ + N₂).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"To realize this process using this package, we first need to fix the relations between the between the (co)evaluation maps and the fusion tensors.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: coevaluation to fusion)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Then, applying the right evaluation on the second uncoupled sector of a splitting tensor thus yields a linear combination of fusion tensors with corresponding Z ismorphism:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: line bending)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"If we bend a line on which a Z isomorphism is already present, we obtain the relation","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: dual line bending)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Hence, bending an isdual sector from the splitting tree to the fusion tree yields an additional Frobenius-Schur factor, and leads to a normal sector on the fusion side.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"On a general fusion-splitting tree, we have some functions to bend the lines:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"bendright(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}) where {I<:Sector, N₁, N₂}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"which bends the last uncoupled space of the splitting tress f1 upward from right hand side to be the last uncoupled space of new fusion tree constructed from f2. That is, map final splitting vertex c → (a, b) of f1 to fusion vertex (c, dual(b)) → a. Graphically:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: line bendright)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Taking the adjoint we get a related function:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"bendleft(f1::FusionTree{I}, f2::FusionTree{I}) where I","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"which bends the last uncoupled space of fusion tree f2 downward from right hand side to be the last uncoupled space of the splitting tree constructed from f1. That is, map final fusion vertex (a, b) → c of f2 to splitting vertex a → (c, dual(b)).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We could also bend the lines from the left hand side:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"foldright(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}) where {I<:Sector, N₁, N₂}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"which bends the first uncoupled space of the splitting tree f1 upward from left hand side to be the first uncoupled space of new fusion tree constructed from f2. That is, map first splitting vertex c → (a, b) of f1 to fusion vertex (dual(a), c) → b. Graphically:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: line foldright)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Taking the adjoint we get a related function","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"foldleft(f1::FusionTree{I}, f2::FusionTree{I}) where I","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"which bends the first uncoupled space of the fusion tree f2 downward from left hand side to be the first uncoupled space of new splitting tree constructed from f1. That is, map first fusion vertex (a, b) → c of f2 to splitting vertex b → (dual(a), c).","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The cyclic permutations of all lines of a fusion-splitting tree can be realized through the bending of lines:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"cycleclockwise(f1::FusionTree{I}, f2::FusionTree{I}) where {I<:Sector}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"which is clockwise cyclic permutation with one foldright and one bendleft.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"cycleanticlockwise(f1::FusionTree{I}, f2::FusionTree{I}) where {I<:Sector}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"which is anticlockwise cyclic permutation with one foldleft and one bendright.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"A more general function for repartition of incoming and outgoing sectors is given by","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"repartition(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, N::Int)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"which takes a splitting tree f1 with N₁ outgoing sectors, a fusion tree f2 with N₂ incoming sectors, and applies line bending such that the resulting fusion-splitting trees have N outgoing sectors, corresponding to the first N sectors out of the list (a_1 a_2  a_N_1 b_N_2^*  b_1^*) and N₁+N₂-N incoming sectors, corresponding to the dual of the last N₁+N₂-N sectors from the previous list in reverse order. This return values are correctly inferred if N is a compile time constant.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Graphically, for N₁ = 4, N₂ = 3, N = 2 and some particular choice of isdual in both the fusion and splitting tree:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: repartition)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The result is returned as a dictionary with keys (f1′, f2′) and the corresponding coeff as value. Note that the summation is only over the κ_j labels, such that, in the case of FusionStyle(I) isa MultiplicityFreeFusion, the linear combination simplifies to a single term with a scalar coefficient.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The transpose of the fusion-splitting tree that can be realized by repartition and cyclic permutations without braiding is given by","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"transpose(f1::FusionTree{I}, f2::FusionTree{I},\n        p1::NTuple{N₁, Int}, p2::NTuple{N₂, Int}) where {I, N₁, N₂}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"which computes new trees and corresponding coefficients obtained from repartitioning and permuting the tree such that sectors p1 become outgoing and sectors p2 become incoming. It is required that the linearized permutation is cyclic to avoid braiding.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The general planar trace of a fusion-splitting tree is given by","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"planar_trace(f1::FusionTree{I}, f2::FusionTree{I},\n            p1::IndexTuple{N₁}, p2::IndexTuple{N₂},\n            q1::IndexTuple{N₃}, q2::IndexTuple{N₃}) where {I<:Sector, N₁, N₂, N₃}","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"which takes the traces between q1[k]th and q2[k]th sector of the fusion-splitting tree and then transposes according to p1 and p2. We need to make sure that the traces are planar without any crossings between lines.","category":"page"},{"location":"man/sectors/#Braiding-manipulations-on-a-splitting-tree","page":"Sectors, representation spaces and fusion trees","title":"Braiding manipulations on a splitting tree","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"An elementary braid of two neighbouring sectors of a splitting tree, which is called Artin braid or Artin generator of the braid group, can be computed in two different ways:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: artin braid)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"While the upper path is the most intuitive, it requires two F-moves (one forward and one reverse) and one R-move. The lower path requires only one (reverse) F-move, and two R-moves. The R-move is less expensive to compute than F-move, thus the lower path is computationally more efficient. The final result should be the same, provided the pentagon and hexagon equations are satisfied. We always assume that these are satisfied for any subtype of Sector, and it is up to the user to verify that they are when implementing new custom Sector types.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"This Artin braid of a splitting tree is implemented by","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"artin_braid(f::FusionTree, i; inv = false)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"where i denotes the position of the first sector (labeled b in the above graph) which is braided with the sector at position i+1 in the splitting tree f. The keyword argument inv allows to select the inverse braiding operation. The result is returned as a dictionary with possible output fusion trees as keys and corresponding coefficients as values.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"With the elementary artin_braid, we can then compute a more general braid by","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"braid(f::FusionTree{I,N}, levels::NTuple{N,Int}, p::NTuple{N,Int})","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The braid is specified by a permutation p, such that the new sector at position i was originally at position p[i]. Every uncoupled sector is assigned a level which can be thought as the depth in the third dimension. The permutation is decomposed into swaps between neighbouring sectors, and when two sectors are swapped, their respective level will determine whether the left sector is braided over or under its right neighbor (shallower level goes over deeper level). This interface does not allow to specify the most general braid, and will never wind one line around another, but can be used as a building block for arbitrary braids than the elementary Artin generators. For example, a braid with levels=(1,2,3,4,5) and permutation=(5,3,1,4,2) is shown in the following:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Image: braid interface)","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The first sector or space goes to position 3, and crosses over all other lines, and so forth. We sketch this operation both as a general braid on the left hand side, and as a composition of Artin braids on the right hand side.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"When BraidingStyle(I) == SymmetricBraiding(), there is no distinction between applying the braiding or its inverse, and we can use the simplified permute method without levels parameter:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"permute(f::FusionTree{I,N}, p::NTuple{N,Int})","category":"page"},{"location":"man/sectors/#Braiding-manipulations-on-a-fusion-splitting-tree","page":"Sectors, representation spaces and fusion trees","title":"Braiding manipulations on a fusion-splitting tree","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"We can now perform arbitrary combinations of braids or permutations with line bendings, to completely reshuffle where sectors appear in a fusion-splitting tree.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"braid(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, levels1::NTuple{N₁,Int},\n    levels2::NTuple{N₂,Int}, p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int})","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"where we have splitting tree f1 with N₁ outgoing sectors, a fusion tree f2 with N₂ incoming sectors, levels1 and levels2 assign a level or depth to the corresponding uncoupled sectors in f1 and f2, and we represent the new configuration as a pair p1 and p2. Together, (p1..., p2...) represents a permutation of length N₁+N₂ = N₁′+N₂′, where p1 indicates which of the original sectors should appear as outgoing sectors in the new splitting tree and p2 indicates which appear as incoming sectors in the new fusion tree.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"This routine is implemented by first making all sectors outgoing using the repartition function, such that only splitting trees remain. Then, braiding the uncoupling sectors of this splitting tree such that the new outgoing sectors appear first, followed by the new incoming sectors in reverse order. Then, bring everything to final form by repartition. The result is returned as a dictionary where the keys are (f1′,f2′) and the values are the corresponding coefficients.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"When BraidingStyle(I) isa SymmetricBraiding, the levels are not needed and we can use the simplified permute method:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"permute(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int})","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The braid and permute routines for fusion-splitting trees will be the main access point for corresponding manipulations on tensors. As a consequence, results from this routine are memorized, i.e. they are stored in some package wide 'least-recently used' cache (from LRUCache.jl) that can be accessed as TensorLabXD.braidcache. By default, this cache stores up to 10^5 different braid or permute results, where each result corresponds to one particular combination of (f1, f2, p1, p2, levels1, levels2). This should be sufficient for most algorithms. While there are currently no (official) access methods to change the default settings of this cache (one can always resort to resize!(TensorLabXD.permutecache) and other methods from LRUCache.jl), this might change in the future. The use of this cache is however controlled by two constants of type RefValue{Bool}, namely usebraidcache_abelian and usebraidcache_nonabelian. The default values are given by TensorLabXD.usebraidcache_abelian[] = false and TensorLabXD.usebraidcache_nonabelian[] = true, and respectively reflect that the cache is likely not going to help (or even slow down) fusion trees with FusionStyle(f) isa UniqueFusion, but is probably useful for fusion trees with FusionStyle(f) isa MultipleFusion. One can change these values and test the effect on their application.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"The existence of braidcache also implies that potential inefficiencies in the fusion tree manipulations (which we nonetheless try to avoid) will not seriously affect performance of tensor manipulations.","category":"page"},{"location":"man/sectors/#Inspecting-fusion-trees-as-tensors","page":"Sectors, representation spaces and fusion trees","title":"Inspecting fusion trees as tensors","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"For those cases where the fusion and splitting tensors have an explicit representation as a tensor, this explicit representation can be created, which can be useful for checking purposes. The splitting tensor X^ab_cμ, i.e. the Clebsch-Gordan coefficients of the group, are encoded via the routine fusiontensor(a,b,c[,μ = nothing]), where the last argument is only necessary if FusionStyle(I) == GenericFusion(). We can then convert a FusionTree{I,N} into an Array, which will yield a rank N+1 array where the first N dimensions correspond to the uncoupled sectors, and the last dimension to the coupled sector.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Some examples:","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"s = Irrep[SU₂](1/2)\niter = fusiontrees((s, s, s, s), SU2Irrep(1))\nf = first(iter)\nconvert(Array, f)\n\nI ≈ convert(Array, FusionTree((SU₂(1/2),), SU₂(1/2), (false,), ()))\nZ = adjoint(convert(Array, FusionTree((SU2Irrep(1/2),), SU2Irrep(1/2), (true,), ())))\ntranspose(Z) ≈ frobeniusschur(SU2Irrep(1/2)) * Z\n\nI ≈ convert(Array, FusionTree((Irrep[SU₂](1),), Irrep[SU₂](1), (false,), ()))\nZ = adjoint(convert(Array, FusionTree((Irrep[SU₂](1),), Irrep[SU₂](1), (true,), ())))\ntranspose(Z) ≈ frobeniusschur(Irrep[SU₂](1)) * Z\n\n#check orthogonality\nfor f1 in iter\n  for f2 in iter\n    dotproduct  = dot(convert(Array, f1), convert(Array, f2))\n    println(\"< $f1, $f2> = $dotproduct\")\n  end\nend","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"Note that we take the adjoint when computing Z, because convert(Array, f) assumes f to be splitting tree, which is built using Z^. Further note that the normalization (squared) of a fusion tree is given by the dimension of the coupled sector, as we are also tracing over the mathrmid_c when checking the orthogonality by computing dot of the corresponding tensors.","category":"page"},{"location":"man/sectors/#Fermions","page":"Sectors, representation spaces and fusion trees","title":"Fermions","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"TODO","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"(Support for fermionic sectors and corresponding super vector spaces is on its way. This section will be completed when the implementation is finished.)","category":"page"},{"location":"man/sectors/#Anyons","page":"Sectors, representation spaces and fusion trees","title":"Anyons","text":"","category":"section"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"One example of a Sector subtype that has anyonic braiding style is the Fibonacci fusion category. It has two (isomorphism classes of) simple objects, namely the identity 𝟙 and a non-trivial object known as τ, with fusion rules τ ⊗ τ = 𝟙 ⊕ τ.","category":"page"},{"location":"man/sectors/","page":"Sectors, representation spaces and fusion trees","title":"Sectors, representation spaces and fusion trees","text":"𝟙 = FibonacciAnyon(:I)\nτ = FibonacciAnyon(:τ)\ncollect(τ ⊗ τ)\nFusionStyle(τ)\nBraidingStyle(τ)\ndim(𝟙)\ndim(τ)\nF𝟙 = Fsymbol(τ,τ,τ,𝟙,τ,τ)\nFτ = [Fsymbol(τ,τ,τ,τ,𝟙,𝟙) Fsymbol(τ,τ,τ,τ,𝟙,τ); Fsymbol(τ,τ,τ,τ,τ,𝟙) Fsymbol(τ,τ,τ,τ,τ,τ)]\nFτ'*Fτ\npolar(x) = rationalize.((abs(x), angle(x)/(2pi)))\nRsymbol(τ,τ,𝟙) |> polar\nRsymbol(τ,τ,τ) |> polar\ntwist(τ) |> polar","category":"page"},{"location":"index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"index/","page":"Index","title":"Index","text":"","category":"page"},{"location":"#TensorLabXD.jl","page":"Home","title":"TensorLabXD.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for large-scale tensor computations, with a hint of category theory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TensorLabXD","category":"page"},{"location":"#Package-summary","page":"Home","title":"Package summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TensorLabXD.jl aims to be a generic package for working with tensors as they appear throughout the physical sciences. TensorLabXD implements a parametric type Tensor (which is actually a specific case of the type TensorMap) and defines for these types a number of vector space operations (scalar multiplication, addition, norms and inner products), index operations (permutations) and linear algebra operations (multiplication, factorizations). Finally, tensor contractions can be performed using the @tensor macro from TensorContractionsXS.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, most effort is oriented towards tensors as they appear in the context of quantum many body physics and in particular the field of tensor networks. Such tensors often have large dimensions and take on a specific structure when symmetries are present. To deal with generic symmetries, we employ notations and concepts from category theory all the way down to the definition of a tensor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the same time, TensorLabXD.jl focuses on computational efficiency and performance. The underlying storage of a tensor's data can be any DenseArray. Currently, certain operations are already multithreaded, either by distributing the different blocks in case of a structured tensor (i.e. with symmetries) or by using multithreading provided by the package StridedTensorXD.jl. In the future, we also plan to investigate using CuArrays as underlying storage for the tensors data, so as to leverage GPUs for the different operations defined on tensors.","category":"page"},{"location":"#Contents-of-the-manual","page":"Home","title":"Contents of the manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"man/intro.md\", \"man/categories.md\", \"man/spaces.md\", \"man/sectors.md\", \"man/tensors.md\"]\nDepth = 3","category":"page"},{"location":"#Library-outline","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = []\nDepth = 2","category":"page"},{"location":"man/categories/#s_categories","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The purpose of this page is to explain how certain concepts and terminology from the theory of monoidal categories apply in the context of tensors. In particular, we are interested in the category mathbfVect, but our concept of tensors can be extended to morphisms of any category that shares similar properties. These properties are reviewed below.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In particular, we will as example also study the more general case of mathbfSVect, i.e. the category of super vector spaces, which contains mathbfVect as a subcategory and which is useful to describe fermions.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In the end, the goal of identifying tensor manipulations in TensorLabXD.jl with concepts from category theory is to put the diagrammatic formulation of tensor networks in the most general context on a firmer footing. The following exposition is mostly based on [turaev], combined with input from [selinger], [kassel], [kitaev], and nLab, to which  we refer for further information. Furthermore, we recommend the nice introduction of [beer].","category":"page"},{"location":"man/categories/#ss_categoryfunctor","page":"Optional introduction to category theory","title":"Categories, functors and natural transformations","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"To start, a category C consists of","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"a class mathrmOb(C) of objects V, W, …\nfor each pair of objects V and W, a set mathrmHom_C(WV) of morphisms   fWV; for a given map f, W is called the domain or source, and V   the codomain or target.\ncomposition of morphisms fWV and gXW into (f  g)XV that is   associative, such that for hYX we have f  (g  h) = (f  g)  h\nfor each object V, an identity morphism mathrmid_VVV such that   f  mathrmid_W = f = mathrmid_V  f.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The morphisms in mathrmHom_C(VV) are known as endomorphism and this set is also denoted as mathrmEnd_C(V). When the category C is clear, we can drop the subscript in mathrmHom(WV). A morphism fWV is an isomorphism if there exists a morphism f^-1VW called its inverse, such that f^-1  f = mathrmid_W and f  f^-1 = mathrmid_V.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Throughout this manual, we associate a graphical representation to morphisms and compositions thereof, which is sometimes referred to as the Penrose graphical calculus. To morphisms, we associate boxes with an incoming and outgoing line denoting the object in its source and target. The flow from source to target, and thus the direction of morphism composition f  g (sometimes known as the flow of time) can be chosen left to right (like the arrow in fWV), right to left (like the composition order f  g, or the matrix product), bottom to top (quantum field theory convention) or top to bottom (quantum circuit convention). Throughout this manual, we stick to the top to bottom convention (which is not very common in manuscripts on category theory):","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: composition)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The direction of the arrows, which become important once we introduce duals, are also subject to convention, and are here chosen to follow the arrow in fWV, i.e. the source comes in and the target goes out. Strangely enough, this is opposite to the most common convention.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In the case of interest, i.e. the category mathbf(Fin)Vect_𝕜 (or some subcategory thereof), the objects are (finite-dimensional) vector spaces over a field 𝕜, and the morphisms are linear maps between these vector spaces with \"matrix multiplication\" as composition. More importantly, the morphism spaces mathrmHom(WV) are themselves vector spaces. More general categories where the morphism spaces are vector spaces over a field 𝕜 (or modules over a ring 𝕜) and the composition of morphisms is a bilinear operation are called 𝕜-linear categories (or 𝕜-algebroids, or mathbfVect_𝕜-enriched categories). In that case, the endomorphisms mathrmEnd(V) are a 𝕜-algebra with mathrmid_V as the identity.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"We also introduce some definitions which will be useful further on. A functor F between two categories C and D is, colloquially speaking, a mapping between categories that preserves morphism composition and identities. More specifically, FCD assigns to every object V  mathrmOb(C) an object F(V)  mathrmOb(D), and to each morphism f  mathrmHom_C(WV) a morphism F(f)  mathrmHom_D(F(W) F(V)) such that F(f) _D F(g) = F(f _C g) and F(mathrmid_V) = mathrmid_F(V) (where we denoted the possibly different composition laws in C and D explicitly with a subscript). In particular, every category C has an identity functor 1_C that acts trivially on objects and morphisms. Functors can also be composed. A 𝕜-linear functor between two 𝕜-linear categories has a linear action on morphisms.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Given two categories C and D, and two functors F and G that map from C to D, a natural transformation φFG is a family of morphisms φ_V  mathrmHom_D(F(V)G(V)) in D, labeled by the objects V of C, such that φ_V  F(f) = G(f)  φ_W for all morphisms f  mathrmHom_C(WV). If all morphisms φ_V are isomorphisms, φ is called a natural isomorphism and the two functors F and G are said to be isomorphic.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The product of two categories C and C, denoted C  C, is the category with objects mathrmOb(CC) = mathrmOb(C)  mathrmOb(C), whose elements are denoted as tuples (VV), and morphisms mathrmHom_CC((WW) (VV)) = mathrmHom_C(WV)  mathrmHom_C(WV). Composition acts as (ff)  (gg) = (fg fg) and the identity is given by mathrmid_VV = (mathrmid_V mathrmid_V). In a similar fashion, we can define the product of functors FCD and FCD as a functor FF (CC)(DD) mapping objects (VV) to (F(V) F(V)) and morphisms (ff) to (F(f) F(f)).","category":"page"},{"location":"man/categories/#ss_monoidalcategory","page":"Optional introduction to category theory","title":"Monoidal categories","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The next property of the category mathbfVect that we want to highlight and generalize is that which allows to take tensor products. Indeed, a category C is said to be a tensor category (a.k.a. a monoidal category), if it has","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"a binary operation on objects  mathrmOb(C)  mathrmOb(C)  mathrmOb(C)\na binary operation on morphisms, also denoted as , such that    mathrmHom_C(W_1V_1)  mathrmHom_C(W_2V_2)  mathrmHom_C(W_1  W_2 V_1  V_2)\nan identity or unit object I\nthree families of natural isomorphisms:\n V  mathrmOb(C), a left unitor (a.k.a. left unitality constraint)   λ_V I  V  V\n V  mathrmOb(C), a right unitor (a.k.a. right unitality constraint)   ρ_V V  I  V\n V_1 V_2 V_3  mathrmOb(C), an associator (a.k.a. associativity   constraint) α_V_1V_2V_3(V_1  V_2)  V_3  V_1  (V_2  V_3)\nthat satisfy certain consistency conditions (coherence axioms), which are known as the   pentagon equation (stating that the two possible mappings from   (((V_1  V_2)  V_3)  V_4) to (V_1  (V_2  (V_3  V_4))) are compatible) and   the triangle equation (expressing compatibility between the two possible ways to map   ((V_1  I)  V_2) to (V_1  (I  V_2))).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In terms of functors and natural transformations,  is a functor from the product category C  C to C. The left (or right) unitor λ (or ρ) is a natural isomorphism between a nameless functor CC that maps objects I  V  V (or V  IV) and the identity functor 1_C. Similarly, the associator α is a natural isomorphism between the two functors (  1_C) and (1_C  ) from C  C  C to C.  In a k-linear category, the tensor product of morphisms is also a bilinear operation. A monoidal category is said to be strict if I  V = V = V  I and (V_1V_2)V_3 = V_1(V_2V_3), and the left and right unitor and associator are just the identity morphisms for these objects.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For the category mathbfVect, the identity object I is just the scalar field 𝕜 over which the vector spaces are defined, and which can be identified with a one-dimensional vector space. This is not automatically a strict category, especially if one considers how to represent tensor maps on a computer. The distinction between V, I  V and V  I amounts to adding or removing an extra factor I to the tensor product structure of the domain or codomain, and so the left and right unitor are analogous to removing extra dimensions of size 1 from a multidimensional array. The fact that arrays with and without additional dimensions 1 are not automatically identical and an actual operation is required to insert or remove them, has led to some discussion in several programming languages that provide native support for multidimensional arrays.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For what concerns the associator, the distinction between (V_1  V_2)  V_3 and V_1  (V_2  V_3) is typically absent for simple tensors or multidimensional arrays. However, this grouping can be taken to indicate how to build the fusion tree for coupling irreps to a joint irrep in the case of symmetric tensors. As such, going from one to the other requires a recoupling (F-move) which has a non-trivial action on the reduced blocks. We elaborate on this in the context of Fusion categories below. However, we can already note that we will always represent tensor products using a canonical order (((V_1  V_2)  V_3)   V_N). A similar approach can be followed to turn any tensor category into a strict tensor category (see Section XI.5 of [kassel]).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The different natural isomorphisms involving the unit object have various relations, such as λ_VW  α_IVW = λ_V  mathrmid_W and λ_I = ρ_I  I  I  I. The last relation defines an isomorphism between I  I and I, which can also be used to state that for f g  mathrmEnd_C(I), f  g = ρ_I  (f  g)  λ_I^-1 = g  f. Hence, the tensor product of morphisms in mathrmEnd_C(I) can be related to morphism composition in mathrmEnd_C(I), and the monoid of endomorphisms mathrmEnd_C(I) is commutative. In the case of a 𝕜-linear category, it is an abelian 𝕜-algebra. In the case of mathbfVect, mathrmEnd(I) is indeed isomorphic to the field of scalars 𝕜. We return to the general case where mathrmEnd_C(I) is isomorphic to 𝕜 itself in the section on pre-fusion categories.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The Mac Lane's coherence theorem states that the triangle and pentagon condition are sufficient to ensure that any consistent diagram made of associators and left and right unitors (involving all possible objects in C) commutes. For what concerns the graphical notation, the natural isomorphisms will not be represented and we make no distinction between (V_1  V_2)  V_3 and V_1  (V_2  V_3). Similarly, the identity object I can be added or removed at will, and when drawn, is often represented by a dotted or dashed line. Note that any consistent way of inserting the associator or left or right unitor to convert a graphical representation to a diagram of compositions and tensor products of morphisms gives rise to the same result, by virtue of Mac Lane's coherence theorem. Using the horizontal direction (left to right) to stack tensor products, this gives rise to the following graphical notation for the tensor product of two morphisms, and for a general morphism t between a tensor product of objects in source and target:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: tensorproduct)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Another relevant example is the category mathbfSVect_𝕜, which has as objects super vector spaces over 𝕜, which are vector spaces with a ℤ₂ grading, i.e. they are decomposed as a direct sum V = V_0  V_1. Furthermore, the morphisms between two super vector spaces are restricted to be grading preserving, i.e. f mathrmHom_mathbfSVect(WV) has f(W_0)  V_0 and f(W_1)  V_1. The graded tensor product between two super vector spaces is defined as V_mathrmgW = (V _mathrmg W)_0  (V _mathrmg W)_1 with (V _mathrmg W)_0 = (V_0  W_0)  (V_1  W_1) and (V _mathrmg W)_1 = (V_0  W_1)  (V_1  W_0). The unit object I is again isomorphic to 𝕜, i.e. I_0 = 𝕜 and I_1 = 0, a zero-dimensional vector space. In particular, the category mathbfSVect_𝕜 contains mathbfVect_𝕜 as a (monoidal) subcategory, by only selecting those objects V for which V_1 = 0.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"We generalize the notion of a functor between monoidal categories. A monoidal functor between two tensor categories (C _C I_C α_C λ_C ρ_C) and (D _D I_D α_D λ_D ρ_D) is a functor FCD together with two monoidal constraints, namely","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"a morphism F_0I_D  F(I_C);\na natural transformation   F_2=F_2(XY) F(X) _D F(Y)  F(X _C Y)  XY mathrmOb(C)   between the functors _D(FF) and F _C from CC to D.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A monoidal natural transformation φ between two monoidal functors FCD and GCD is a natural transformation φFG that furthermore satisfies","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"φ_I_C F_0 = G_0;\n XY  mathrmOb(C): φ_X  Y F_2(XY) = G_2(XY)(φ_X  φ_Y).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For further reference, we also define the following categories which can be associated with the category mathcalC = (C  I α λ ρ)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathcalC^mathrmop = (C^mathrmop  I α^mathrmop λ^mathrmop ρ^mathrmop)   where the opposite category C^mathrmop has the same objects as C but has   mathrmHom_C^mathrmop(XY) = mathrmHom_C(YX) and a composition law   g ^mathrmop f = f  g, with  the composition law of C. And   α^mathrmop_XYZ = (α_XYZ)^-1,   λ^mathrmop_X = (λ_X)^-1 and ρ^mathrmop_X = (ρ_X)^-1;\nmathcalC^mathrmop = (C ^mathrmop I α^mathrmop λ^mathrmop ρ^mathrmop)   where the functor ^mathrmopCC  C is the opposite monoidal product, which   acts as X ^mathrmop Y = Y  X on objects and similar on morphisms.   And α^mathrmop_XYZ = (α_ZYX)^-1,   λ^mathrmop_X = ρ_X and ρ^mathrmop_X = λ_X;\nmathcalC^mathrmrev = (C^mathrmop ^mathrmop I α^mathrmrev λ^mathrmrev ρ^mathrmrev)   with α^mathrmrev_XYZ = α_ZYX, λ^mathrmrev_X = (ρ_X)^-1,   ρ^mathrmrev_X = (λ_X)^-1. mathcalC^mathrmrev is obtained by   composing the previous two transformations.","category":"page"},{"location":"man/categories/#ss_dual","page":"Optional introduction to category theory","title":"Duality: rigid, pivotal and spherical categories","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The duality in a monoidal category is defined via an exact paring, i.e. two families of non-degenerate morphisms, the evaluation (or co-unit) ϵ_V ^V  V  I and the coevaluation (or unit) η_V I  V  ^V which satisfy the \"snake rules\":","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"ρ_V  (mathrmid_V  ϵ_V)  (η_V  mathrmid_V)  λ_V^-1 = mathrmid_V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"λ_^V^-1  (ϵ_V  mathrmid_^V)  (mathrmid_^V  η_V)  ρ_^V^-1 = mathrmid_^V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and can be used to define an isomorphism between mathrmHom(W  V U) and mathrmHom(W U  ^V) for any triple of objects U V W  mathrmOb(C). Note that if there are different duals (with corresponding exact pairings) associated to an object V, a mixed snake composition using the evaluation of one and coevaluation of the other duality can be used to construct an isomorphism between the two associated dual objects. Hence, duality is unique up to isomorphisms.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Graphically, we represent the exact pairing and snake rules as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: left dual)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note that we denote the dual objects ^V as a line V with arrows pointing in the opposite (i.e. upward) direction. This notation is related to quantum field theory, where anti-particles are (to some extent) interpreted as particles running backwards in time.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Using a bra-ket notation and a generic basis n for V and dual basis m for ^V (such that mn = δ_mn), the evaluation is given by ϵ_V^V  V  ℂ m  n  δ_mn and the coevaluation or unit is η_Vℂ V  ^Vα  α _n n  n. Note that this does not require an inner product, i.e. no relation or mapping from n to n was defined.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For a general tensor map tW_1  W_2    W_N_2  V_1  V_2    V_N_1, by successively applying η_W_N_2, η_W_N_2-1, …, η_W_1, we obtain a tensor in V_1  V_2    V_N_1  ^W_N_2    ^W_1. Hence, we can define ^(W_1  W_2    W_N_2) = ^W_N_2    ^W_1. Indeed, it can be shown that for any category which has duals for objects V and W, an exact pairing between V  W and ^W  ^V can be constructed out of the evaluation and coevaluation of V and W, such that ^W  ^V is at least isomorphic to ^(V  W). For example, a map from t  mathrmHom(W_1  W_2  W_3 V_1  V_2) to a morphism in mathrmHom(I V_1  V_2  ^W_3  ^W_2  ^W_1) is:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: transpose)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"These exact pairings are known as the left evaluation and coevaluation, and ^V is the left dual of V. Likewise, we can also define a right dual V^ of V and associated pairings, the right evaluation tildeϵ_V V  V^  I and coevaluation tildeη_V I  V^  V, satisfying","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: right dual)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note that the graphical notation, at least the lines with opposite arrows, do not allow to distinguish between the right dual V^ and the left dual ^V. We come back to this point below.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"One could choose tildeϵ_^V = ϵ_V and thus define V as the right dual of ^V. While there might be other choices, this choice must at least be isomorphic, such that (^V)^  V.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"If objects V and W have left (respectively right) duals, than for a morphism f  mathrmHom(WV), we can define the left (respectively right) transpose ^f  mathrmHom(^V ^W) (respectively   f^  mathrmHom(V^ W^)) as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: transpose)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note that ^f is defined using the left evaluation and coevaluation, while f^ is defined using the right evaluation and coevaluation.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A left (or right) duality in a (monoidal) category is now defined as an association of a left (or right) dual with every object of the category, with corresponding exact pairings, and a category admitting such a duality is a left (or right) rigid category (or left or right autonomous category). Given that left (or right) morphism transposition satisfies ^(f  g)= ^g  ^f= ^f ^mathrmop ^g and recalling ^(V  W) = ^W  ^V (and similar for right duality), we can define duality in a functorial way. A (left or right) rigid category mathcalC is a category which admits a (left or right) duality functor, i.e. a functor from mathcalC to mathcalC^mathrmrev that maps objects to its (left or right) dual, and morphisms to its (left or right) transpose. The snake rules can now be read as the functioral requirement that ^(mathrmid_V) = mathrmid_^V.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In all of this, left and right duality can be completely distinct. Equivalently, the left dual of the left dual of an object V, i.e. ^V is not necessarily V itself, nor do the exact pairings enable us to construct an isomorphism between ^V and V. For finite-dimensional vector spaces, however, ^V and V, or thus ^V and V^ are known to be isomorphic. The categorical generalization is that of a pivotal category (or sovereign category), i.e. a monoidal category with two-sided duals X^* = ^X = X^ such that the left and right duality functor coincide, and thus also the left and right transpose of morphisms, i.e. f^* = ^f = f^  mathrmHom(V^*W^*) for any fmathrmHom(WV). Given that tildeϵ_X and tildeη_X can be interpreted as an exact pairing ϵ_X^* and η_X^*, this can be used to recognize X as a left dual of X^*, which is then not necessarily equal but at least isomorphic to X^** with the isomorphism given by the mixed snake composition, i.e. δ_X X  X^** given by δ_X = (tildeϵ_X  mathrmid_X^**)  (mathrmid_X  η_X^*). A more formal statement is that δ is a natural isomorphism between the double dual functor and the identity functor of a category C. In a similar manner, such a δ can be used to define a natural isomorphism between left and right dual functor (which is a slight generalization of the above definition of a pivotal category), and as such it is often called the pivotal structure.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Hence, in a pivotal category, left and right duals are the same or isomorphic, and so are objects and their double duals. As such, we will not distinguish between them in the graphical representation and suppress the natural isomorphism δ. Note, as already suggested by the graphical notation above, that we can interpret transposing a morphism as rotating its graphical notation by 180 degrees (either way).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In a pivotal category, we can define a map mathrmEnd(V)rightarrow mathrmEnd(I), known as the trace of f. In fact, we can define a left trace as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathrmtr_mathrml(f) = ϵ_V  (mathrmid_V^*  f)  tildeη_V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and a right trace as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathrmtr_mathrmr(f) = tildeϵ_V  (f  mathrmid_V^*)  η_V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"They are graphically represented as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: trace)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and they do not need to coincide. Note that mathrmtr_mathrml(f) = mathrmtr_mathrmr(f^*) and that mathrmtr_mathrmlmathrmr(fg) = mathrmtr_mathrmlmathrmr(gf). The (left or right) trace of the identity morphism mathrmid_V defines the corresponding (left or right) dimension of the object V, i.e. mathrmdim_mathrmlmathrmr(V) = tr_mathrmlmathrmr(mathrmid_V). In a spherical category, both definitions of the trace coincide for all V and we simply refer to the trace mathrmtr(f) of an endomorphism. The particular value mathrmdim(V) = mathrmtr(mathrmid_V) is known as the (quantum) dimension of the object V, referred to as dim(V) in TensorLabXD.jl.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"We conclude this section by studying the example of mathbfSVect. Let us, in every super vector space V, define a basis n that is compatible with the grading, such that n=01 indicates that n  V_n (note that n is not the absolute value of n, but just a notation to denote which subspace the basis vector nrangle belongs to). We define a dual basis m for V^* (such that mn = δ_mn), and then define the left evaluation by ϵ_VV^*  V  ℂ m _mathrmg n  mn = δ_mn and the left coevaluation by η_Vℂ V  V^*α  α _n n _mathrmg n. Note that this does not require an inner product and satisfies the snake rules. For the right evaluation and coevaluation, there are two natural choices, namely tildeϵ_VV  V^*  ℂ n _mathrmg m  (1)^n δ_mn and tildeη_Vℂ  V^*  V α  _n (1)^n n _mathrmg n. The resulting trace of an endomorphism f  mathrmEnd(V) is given by mathrmtr^mathrml(f) = mathrmtr^mathrmr(f) = mathrmtr(f) = _n ( 1)^n nfn and is known as either the regular trace (in the case of +1) or the supertrace (in the case of -1). Correspondingly mathrmdim(V) = mathrmdim(V_0)  mathrmdim(V_1), which can be negative in the case of the supertrace. Both are valid choices to make mathbfSVect into a spherical category.","category":"page"},{"location":"man/categories/#ss_braiding","page":"Optional introduction to category theory","title":"Braidings, twists and ribbons","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"While duality and the pivotal structure allow to move vector spaces back and forth between the domain (source) and codomain (target) of a tensor map, reordering vector spaces within the domain or codomain of a tensor map , i.e. within a tensor product V_1  V_2    V_N requires additional structure.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"We need a braided tensor category C, which is endowed with a braiding τ, i.e., a natural isomorphism τ_VWVW  WV with VW  mathrmOb(C) between the functors  and ^mathrmop such that","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"τ_VV(f  g) = (g  f)τ_WW","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"for any morphisms f  mathrmHom(WV) and g  mathrmHom(WV).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A valid braiding needs to satisfy a coherence condition with the associator α known as the hexagon equation, which expresses that the braiding is -multiplicative, i.e.,","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"τ_UVW = (mathrmid_V  τ_UW)(τ_UVmathrmid_W)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"τ_UVW = (τ_UWmathrmid_V)(mathrmid_U  τ_VW)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(where the associator has been omitted).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"We also have λ_V  τ_VI = ρ_V, ρ_V  τ_IV = λ_V and τ_VI = τ_IV^-1 for any V  mathrmOb(C).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The braiding isomorphism τ_VW and its inverse are graphically represented as the lines V and W crossing over and under each other:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: braiding)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"such that we have","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: braiding relations)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"where the expression on the right hand side, τ_WVτ_VW can generically not be simplified. Hence, for general braidings, there is no unique choice to identify a tensor in VW with another tensor in WV, as the isomorphisms τ_VW, τ_WV^-1, τ_VW  τ_WV  τ_VW, … mapping from VW to WV can all be different. In order for there to be a unique map from V_1  V_2    V_N to any permutation of the objects in this tensor product, the braiding needs to be symmetric, i.e. τ_VW = τ_WV^-1 or, equivalently τ_WV  τ_VW = mathrmid_VW. The resulting category is then referred to as a symmetric tensor category. In a graphical representation, it means that there is no distinction between over- and under- crossings and, as such, lines can just cross, where the crossing represents the action of τ_VW = τ_WV^-1.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"From the definition of the braiding, we know that","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: braidingdefinition)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"then we could abtain","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: braidingandfusion)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"This relation can also be obtained from the hexagon equation.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The braiding also satisfy the Yang-Baxter equation, i.e., a line can be moved over or under a crossing between two other lines:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: YangBaxter)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In the case of the category mathbfVect a valid braiding consists of just flipping the the objects/morphisms involved, e.g. for a simple cartesian tensor, permuting the tensor indices is equivalent to applying Julia's function permutedims on the underlying data. Less trivial braiding implementations arise in the context of tensors with symmetries, where the fusion tree needs to be reordered, or in the case of mathbfSVect.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The braiding of a space and a dual space also follows naturally, it is given by τ_V^*W = λ_W  V^*  (ϵ_V  mathrmid_W  V^*)  (mathrmid_V^*  τ_VW^-1  mathrmid_V^*)  (mathrmid_V^* W  η_V)  ρ_V^*  W^-1, i.e.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: braiding dual)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Balanced categories C are braided categories that come with a twist θ, a natural transformation from the identity functor 1_C to itself, such that θ_V  f = f  θ_W for all morphisms f  mathrmHom(WV), and for which main requirement is that","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"θ_VW = τ_WV  (θ_W  θ_V)  τ_VW = (θ_V  θ_W)  τ_WV  τ_VW","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In particular, a braided pivotal category is balanced, as we can even define two such twists, namely a left twist given by","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"θ^mathrml_V = (ϵ_V  mathrmid_V)(mathrmid_V*  τ_VV) (tildeη_V  mathrmid_V)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and a right twist given by","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"θ^mathrmr_V = (mathrmid_V  tildeϵ_V)(τ_VV  mathrmid_V*)(mathrmid_V  ϵ_V)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"where we omitted the necessary left and right unitors and associators. Graphically, the twists and their inverse (for which we refer to [turaev]) are then represented as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: twists)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The graphical representation also makes it straightforward to verify that (θ^mathrml_V)^* = θ^mathrmr_V^*, (θ^mathrmr_V)^* = θ^mathrml_V^* and mathrmtr_mathrml( θ^mathrmr_V ) = mathrmtr_mathrmr( θ^mathrml_V ).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"When θ^mathrml = θ^mathrmr, or thus, equivalently, θ_V^* = θ_V^* for either θ^mathrml or θ^mathrmr, the category is said to be tortile or also a ribbon category, because its graphical representation is compatible with the isotopy of a ribbon, i.e. where the lines representing objects are depicted as ribbons. For convenience, we continue to denote them as lines. Ribbon categories are necessarily spherical, i.e. one can prove the equivalence of the left and right trace.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Alternatively, one can start from a balanced and rigid category (e.g. with a left duality), and use the twist θ, which should satisfy θ_V^* = θ_V^*, to define a pivotal structure, or, to define the exact pairing for the right dual functor as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"tildeη_V = τ_VV^*  (θ_V  mathrmid_V^*)  η_V = (mathrmid_V^*  θ_V)  τ_VV^*  η_V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"tildeϵ_V = ϵ_V  (mathrmid_V^*  θ_V)  τ_VV^* = ϵ_V  τ_VV^*  (θ_V  mathrmid_V^*)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"or graphically","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: pivotal from twist)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"where we have drawn θ as θ^mathrml on the left and as θ^mathrmr on the right, but in this case the starting assumption was that they are one and the same, and we defined the pivotal structure so as to make it compatible with the graphical representation. This construction of the pivotal structure can than be used to define the trace, which is spherical, i.e.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathrmtr(f) = ϵ_V  τ_VV^*  (( θ_V  f)  mathrmid_V^*)  η_V = ϵ_V  (mathrmid_V^*  (f  θ_V))  τ_VV^*  η_V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and graphically","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: spherical trace)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A ribbon category where the braiding is symmetric, is known as a compact closed category. For a symmetric braiding, the trivial twist θ_V = mathrmid_V is always a valid choice, but it might not be the choice that one necessarily want to use. Let us study the case of mathbfSVect again. Reinvoking our basis m  V and n  W, the braiding τ_VW is given by the Koszul sign rule, i.e. τ_VWm _mathrmg n  (-1)^m n n _mathrmg m. Hence, braiding amounts to flipping the two spaces, but picks up an additional minus sign if both m  V_1 and n  W_1. This braiding is symmetric, i.e. τ_WV  τ_VW = mathrmid_VW. Between spaces and dual spaces, we similarly obtain the braiding rule m _mathrmg n  (-1)^m n n _mathrmg m. Combining the braiding and the pivotal structure gives rise to a ribbon category, and thus, a compact closed category, where the resulting twist is given by θ_V  n  (1)^n n for tildeϵ_VV  V^*  ℂ n _mathrmg m  (1)^n δ_mn and corresponding tildeη_V. Hence, if the right (co)evaluation contains a minus sign, the twist is θ_V = mathrmid_V, which, as mentioned above, is always a valid twist for a symmetric category. However, if the right (co)evaluation contains no minus sign, the twist acts as the parity endomorphism, i.e. as +1 on V_0 and as -1 on V_1, which, as we will see in the next section, corresponds to a choice bearing additional structure.","category":"page"},{"location":"man/categories/#ss_adjoints","page":"Optional introduction to category theory","title":"Adjoints and dagger categories","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A final aspect of categories as they are relevant to physics, and in particular quantum physics, is the notion of an adjoint or dagger. A dagger category C is a category together with an involutive functor CC^mathrmop, i.e. it acts as the identity on objects, whereas on morphisms fWV it defines a morphism f^VW such that","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathrmid_V^ = mathrmid_V\n(f  g)^ = f^ ^mathrmop g^ = g^  f^\n(f^)^ = f","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Sometimes also the symbol * is used instead of , however we have already used * to denote dual objects and transposed morphisms in the case of a pivotal category.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"If the category is ℂ-linear, the dagger functor is often assumed to be antilinear, i.e., (λ f)^ = barλ f^ for λ  ℂ and f  mathrmHom(VW).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In a dagger category, a morphism fWV is said to be unitary if it is an isomorphism and f^-1 = f^. An endomorphism fVV is hermitian or self-adjoint if f^ = f. We will also use the term isometry for a morphism fWV which has a left inverse f^, i.e. such that f^  f = mathrmid_W, but for which f  f^ is not necessarily the identity (but rather some orthogonal projector, i.e. a hermitian idempotent in mathrmEnd(V)).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In the graphical representation, the dagger of a morphism can be represented by mirroring the morphism around a horizontal axis, and then reversing all arrows (bringing them back to their original orientation before the mirror operation):","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: dagger)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"where for completeness we have also depicted the graphical representation of the transpose, which is a very different operation. In particular, the dagger does not reverse the order of the tensor product. Note that, for readibility, we have not mirrored or rotated the label in the box, but this implies that we need to use a type of box for which the action of mirroring or rotating can be observed.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A dagger monoidal category is one in which the associator and left and right unitor are unitary morphisms. Similarly, a dagger braided category also has a unitary braiding, and a dagger balanced category in addition has a unitary twist.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"There is more to be said about the interplay between the dagger and duals. Given a left evaluation ϵ_V V^*  V  I and coevaluation η_V I  V  V^*, we can define a right evaluation tildeϵ_V = (η_V)^ and coevaluation tildeη_V = (ϵ_V)^. Hence, left rigid dagger categories are automatically pivotal dagger categories.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The (right) twist defined via the pivotal structure now becomes","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"θ_V = (mathrmid_V  (η_V)^)  (τ_VV  mathrmid_V^*)  (mathrmid_V  η_V)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and is itself unitary. Even for a symmetric category, the twist defined as such must not be the identity, as we discuss for the mathbfSVect example below.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The dagger allows to define two Hermitian forms on the morphisms, namely  f g _mathrmlmathrmr = mathrmtr_mathrmlmathrmr(f^ g), which coincide for a spherical category. For a unitary 𝕜-linear category, these Hermitian forms should be positive definite and thus define an inner product on each of the homomorphism spaces mathrmHom(WV). In particular then, dimensions of objects are positive, as they satisfy mathrmdim_mathrmlmathrmr(V) =  mathrmid_V mathrmid_V _mathrmlmathrmr.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"This concludes the most important categorical definitions and structures that we want to discuss for the category mathbfVect, but which can also be realized in other categories. In particular, the interface of TensorLabXD.jl could in principle represent morphisms from any 𝕜-linear monoidal category, but assumes categories with duals to be pivotal and in fact spherical, and categories with a braiding to be ribbon categories. A dagger ribbon category where the braiding is symmetric, i.e. a dagger category which is also a compact closed category and where the right (co)evaluation is given via the dagger of the left (co)evaluation is called a dagger compact category. This is the playground of quantum mechanics of bosonic and fermionic systems. However, we also allow for non-symmetric braiding in TensorLabXD.jl, though this functionality is currently much more limited.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Again studying the category mathbfSVect_ℂ (now explicitly over the complex numbers) and using the conventional adjoint or the complex Euclidean inner product to define the dagger functor, the right (co)evaluation that is obtained from applying the dagger to the left (co)evaluation is the definition we gave above with the +1 sign. This choice gives rise to a regular trace (versus the supertrace) of endomorphisms, to positive dimensions, and a non-trivial twist that acts as the parity endomorphism. The resulting category is then a dagger compact category, that can be used for the quantum mechanical description of fermionic systems. The bosonic version is obtained by restricting to the subcategory mathbfVect.","category":"page"},{"location":"man/categories/#ss_fusion","page":"Optional introduction to category theory","title":"Direct sums, simple objects and fusion categories","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"These last two section on fusion categories is also applicable, in a straightforward manner, to mathbfVect and mathbfSVect, but is rather meant to provide the background of working with symmetries. We first need two new concepts:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"An object V  mathrmOb(C) is a direct sum of objects   V_1 V_2  V_k  mathrmOb(C) if there exists a family morphisms   x_α  mathrmHom(V_αV) and y^α  mathrmHom(VV_α) such that   mathrmid_V = _α=1^k x_α  y^α and y^α  x_β = δ^α_β mathrmid_V_α.   The morphisms x_α and y^α are known as inclusions and projections   respectively, and in the context of dagger categories it is natural to assume   y^α = x_α^ in order to obtain an orthogonal direct sum decomposition.\nA simple object V  mathrmOb(C) of a 𝕜-linear category C is an   object for which mathrmEnd_C(V)  𝕜, i.e. the algebra of endomorphisms on V is   isomorphic to the field (or ring) 𝕜. As mathrmEnd_C(V) always contains the identity   morphism mathrmid_V, and this must be the only linearly independent endomorphism   if V is a simple object, the isomorphism between mathrmEnd_C(V) and 𝕜   is typically of the form k  𝕜  k mathrmid_V  mathrmEnd_C(V). In particular, for   mathbfSVect and its subcategory mathbfVect, the unit object I is a   simple object. (Remind that I = mathbbk in mathbfVect and   I = I_0oplus I_1 = mathbbkoplus 0 in mathbfSVect.)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In particular, for a pivotal 𝕜-linear category where I is simple, it holds that the left and right dimensions of any simple object V are invertible in 𝕜, and that any endomorphism f  mathrmEnd(V) can be written as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"f = (mathrmdim_mathrml(V))^-1 mathrmtr_mathrml(f) mathrmid_V = (mathrmdim_mathrmr(V))^-1 mathrmtr_mathrmr(f) mathrmid_V","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"since f = k mathrmid_V and mathrmtr(f) = k mathrmtr(mathrmid_V).","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Strictly speaking, this holds only if the category is non-degenerate, which means that I is simple and that any non-degenerate pairing eV  W  I induces a non-degenerate pairing mathrmHom(IV)  mathrmHom(IW)  mathrmEnd(I). This property is always satisfied for a pre-fusion category C, i.e. a monoidal 𝕜- linear category having a set mathcalS  mathrmOb(C) of simple objects mathcalS=I V_1 V_2 ldots such that","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"the monoidal unit I  mathcalS;\nmathrmHom_C(V_iV_j) = 0 (the singleton set containing only the zero   homomorphism) for any distinct V_i V_j  mathcalS;\nevery object V  mathrmOb(C) can be written as a direct sum of a finite family of   elements from mathcalS.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note that in the direct sum decomposition of an object V, a particular simple object V_i might appear multiple times. This number is known as the multiplicity index N^V_i, and equal to the rank of mathrmHom(VV_i) or, equivalently, of mathrmHom(V_iV). Hence, we can choose inclusion and projection maps x_iμV_iV and y^iμVV_i for μ = 1ldots N^V_i, such that mathrmid_V = sum_isum_μ=1^N_V^i x_iμ  y^iμ and y^iμ  x_jν = δ^i_j δ^μ_ν. In particular, for a simple object V, it either appears in mathcalS or is isomorphic to an object S. We thus have N^V_i = 1 for one particular object V_i and N^V_j= 0 for all other j, with x_i and y^i = (x_i)^-1 representing the isomorphism between V and V_i.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The homomorphisms between two general objects W and V in a pre-fusion category can be decomposed as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathrmHom(WV)  _V_i  mathcalS mathrmHom(WV_i)  mathrmHom(V_iV)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and thus that the rank of mathrmHom(WV) is given by _i N^W_i N^V_i.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A fusion category is a pre-fusion category that has (left or right) duals, i.e. that is rigid, and that only has a finite number of isomorphism classes of simple objects. Note that the duality functor maps mathrmEnd(V) to mathrmEnd(V^*), such that, if V is a simple object, so must be V^*. Henceforth, we will be sloppy about the distinction between a pre-fusion or fusion category, only use the latter term, even when it is not fully justified.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Before continuing, let us use some examples to sketch the relevance of the concept of fusion categories. As mentioned, the categories mathbfVect_𝕜 and mathbfSVect_𝕜 have I  𝕜 as simple object. For mathbfVect, this is the only simple object, i.e. any other vector space V over 𝕜, can be thought of as a direct sum over N^V_I = mathrmdim(V) multiple copies of 𝕜. In mathbfSVect, the object J = 0  𝕜 is another simple object with J_0=0 (the zero dimensional space) and J_1  𝕜. Clearly, there are no non-zero grading preserving morphisms between I and J, i.e. mathrmHom(IJ) = 0, whereas mathrmHom(JJ)  𝕜. Any other super vector space V=V_0  V_1 can be written as a direct sum over N^V_I = mathrmdim(V_0) copies of I and N^V_J = mathrmdim(V_1) copies of J.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A more representative example is that of the category C = mathbfRep_mathsfG, the category of representations of a group mathsfG. Colloquially, this could be thought of as a subcategory of mathbfVect containing as objects vector spaces V on which a representation of mathsfG is defined, denoted as u_V(g) for g  mathsfG, and as morphisms the equivariant transformations, i.e. intertwiners between the representations on the source and target:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"mathrmHom_C(WV) = f  mathrmHom_mathbfVect(WV) u_V(g)  f = f  u_W(g)  g  G","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note that the u_V(g) is itself generally not an element from mathrmEnd_C(V). Simple objects V_a are those corresponding to the irreducible representations (irreps) a of the group mathsfG, for which Schur's lemma implies mathrmEnd_C(V_a)  𝕜 and mathrmHom_C(V_a V_b) = 0 if a and b are not equivalent irreps. On the dual space V^*, the group acts with the contragradient representation, i.e. u_V^*(g) = ((u_V(g))^-1)^* = u_V(g^-1)^*, where one should remind that ^* denotes the transpose of the representation matrix. (The form of the representation on the dual space can be determined by the requirement that applying the symmetry operation on the all legs of the evaluation map leave it invariant: langle motimes nrangle =sum_k langle m (u_V(g))^-1_mku_V(g)_knnrangle = sum_k u_V(g^-1)^*_kmlangle mu_V(g)_knnrangle.) For a finite group or compact Lie group, we can introduce a dagger and restrict to unitary representations, such that u_V(g)^-1 = u_V(g)^ and the contragradient representation becomes the complex conjugated representation, denoted as u_V^*(g) = baru_V(g), where the overline means complex conjugate. The resulting category can then be given the structure of a unitary ribbon (pre-)fusion category. (Note that the number of isomorphism classes of simple objects, i.e. the number of non-equivalent irreps, is finite only in the case of a finite group). This example is very relevant to working with symmetries in TensorLabXD.jl.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Fusion categories have a number of simplifying properties. A pivotal fusion category is spherical as soon as mathrmdim_mathrml(V_i) = mathrmdim_mathrmr(V_i) for all isomorphism classes of simple objects. Note that all isomorphic simple objects have the same dimension. A braided pivotal fusion category is spherical if and only if it is a ribbon category.","category":"page"},{"location":"man/categories/#ss_topologicalfusion","page":"Optional introduction to category theory","title":"Topological data of a unitary pivotal fusion category","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"More explicitly, the different structures (monoidal structure, duals and pivotal structure, braiding and twists) in a fusion category can be characterized in terms of the simple objects, which we will henceforth denoted with just a instead of V_a. This gives rise to what is known as the topological data of a unitary pivotal fusion category, most importantly the N, F and R symbols, which will be introduced in this final section.","category":"page"},{"location":"man/categories/#Monoidal-structure","page":"Optional introduction to category theory","title":"Monoidal structure","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Starting with the tensor product, we start by characterizing how the object a  b can be decomposed as a direct sum over simple objects c, which gives rise to the multiplicity indices N_c^ab, as well as the inclusion maps, which we henceforth denote as X_cμ^abcab for μ=1N^c_ab. In the context of a unitary fusion category, on which we now focus, the corresponding projection maps are Y^cμ_ab = (X_cμ^ab)^abc such that","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(X_cμ^ab)^  X_cμ^ab = δ_cc δ_μμ mathrmid_c","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Graphically, we represent these relations as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: fusion)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and also refer to the inclusion and projection maps as splitting and fusion tensor, respectively.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For both (ab)c and a(bc), which are isomorphic via the associator α_abc, we must thus obtain a direct sum decomposition with the same multiplicity indices, leading to the associativity constraint","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"N_d^abc= _e N_e^ab N_d^ec = _f N_f^bc N_d^af","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The corresponding inclusion maps can be chosen as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"X_d(eμν)^abc = (X_eμ^ab  mathrmid_c)  X_dν^ec  d(ab)c","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"tildeX_d(fκλ)^abc = (mathrmid_a  X_fκ^bc)  X_dλ^af  da(bc)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"that satisfy","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(X_d(eμν)^abc)^  X_d(eμν)^abc = δ_ee δ_μμ δ_νν δ_dd mathrmid_d","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"_deμν X_d(eμν)^abc  (X_d(eμν)^abc)^ = mathrmid_(ab)c","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and similar for tildeX_d(fκλ)^abc.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Applying the associator leads to a relation","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"α_abc  X_d(eμν)^abc = _fκλ F^abc_d_(eμν)^(fκλ) tildeX_d(fκλ)^abc","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"which defines the F-symbol, i.e. the matrix elements of the associator","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(tildeX_d(fκλ)^abc)^  α_abc  X_d(eμν)^abc = δ_dd F^abc_d_(eμν)^(fκλ) mathrmid_d","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note that the left hand side represents a map in mathrmHom(dd), which must be zero if d is different from d, hence the δ_dd on the right hand side. In a strict category, or in the graphical notation, the associator α is omitted and these relations thus represent a unitary basis transform between the basis of inclusion maps X_d(eμν)^abc and tildeX_d(fκλ)^abc, which is also called an F-move, i.e. graphically:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: Fmove)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The matrix F^abc_d is thus a unitary matrix. The pentagon coherence equation can also be rewritten in terms of these matrix elements, and as such yields the celebrated pentagon equation for the F-symbols. In a similar fashion, the unitors result in N^a1_b = N^1a_b = δ^a_b (where we have now written 1 instead of I for the unit object) and the triangle equation leads to additional relations between the F- symbols involving the unit object. In particular, if we identify X^1a_a1a(1a) with λ_a^ and X^a1_a1a(a1) with ρ_a^, the triangle equation and its collaries imply that F^1ab_c_(11μ)^(cν1) = δ^ν_μ, and similar relations for F^a1b_c and F^ab1_c, which are graphically represented as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: Fmove1)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"In the case of group representations, i.e. the category mathbfRep_mathsfG, the splitting and fusion tensors are known as the Clebsch-Gordan coefficients, especially in the case of mathsfSU_2. An F-move amounts to a recoupling and the F-symbols can thus be identified with the 6j-symbols (strictly speaking, Racah's W-symbol for mathsfSU_2).","category":"page"},{"location":"man/categories/#Duality-and-pivotal-structure","page":"Optional introduction to category theory","title":"Duality and pivotal structure","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Next up is duality. Since we are assuming a dagger category, it can be assumed pivotal, where the left dual objects are identical to the right dual objects, and the left and right (co)evaluation are related via the dagger. We have already pointed out above that the dual object a^* of a simple object a is simple, and thus, it must be isomorphic to one of the representives bara of the different isomorphism classes of simple objects that we have chosen. Note that it can happen that bara=a. Duality implies an isomorphism between mathrmHom(WV) and mathrmHom(IVW^*), and thus, for a simple object a, mathrmEnd(a)  𝕜 is isomorphic to mathrmHom(1aa^*), such that the latter is also isomorphic to 𝕜, or thus N^abara_1 = 1. Also, all possible duals of a must be isomorphic, and thus there is a single representive bara, meaning that N^ab_1 = δ^bbara, i.e. for all other b  bara, mathrmHom(1ab)  mathrmHom(b^*a) = 0. Note that also barbara=a.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Let us now be careful about the isomorphism between a^* and bara. If bara  a, we can basically choose the representative of that isomorphism class as bara = a^*. However, this choice might not be valid if bara=a, as in that case the choice is already fixed, and a^* might be different from a. To give a concrete example, the j=12 representation of mathsfSU_2 has a dual (contragradient, but because of unitarity, complex conjugated) representation which is isomorphic to itself, but not equal. In the context of tensors in quantum physics, we would like to be able to represent this representation and its conjugate, so we need to take the distinction and the isomorphism between them into account. This means that mathrmHom(a^*bara) is isomorphic to 𝕜 and contains a single linearly independent element, Z_a, which is a unitary isomorphism such that Z_a^dagger  Z_a = mathrmid_a^* and Z_a  Z_a^dagger = mathrmid_bara. Using the transpose, we obtain Z_a^*  mathrmHom(bara^*a), and thus it is proportional to Z_bara, i.e. Z_a^* = χ_a Z_bara with χ_a a complex phase (assuming 𝕜 = ℂ). Since both of Z^*_a and Z_overlinea are unitary, we have overlinechi_achi_a = 1. Do the transpose for again, we get (Z_a^*)^* = chi_aZ_overlinea^* =  chi_achi_overlineaZ_a = Z_a, thus overlinechi_a=chi_overlinea, where bar of a scalar quantity denotes its complex conjugate. If aand bara are distinct, we can essentially choose Z_bara such that χ_a is 1. However, for a=bara, the value of χ_a cannot be changed, but must satisfy overlinechi_a=chi_a, thus χ_a = 1. This value is a topological invariant known as the Frobenius-Schur indicator. Graphically, we represent this isomorphism and its relations as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: Zisomorphism)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"We can now discuss the relation between the exact pairing and the fusion and splitting tensors. Given that the (left) coevaluation η_a  mathrmHom(1 aa^*), we can define the splitting tensor as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"X^abara_1 = frac1sqrtd_a(mathrmid_a  Z_a)  η_a = frac1sqrtd_a(Z_a^*  mathrmid_bara)  tildeη_bara  mathrmHom(1 abara)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The prefactor takes care of normalization, i.e. with η_a^ = tildeϵ_a, we find η_a^  η_a = tildeϵ_a  η_a = mathrmtr(mathrmid_a) = d_a mathrmid_1, and thus (X^abara_1)^  X^abara_1 = mathrmid_1. Here, we have denoted d_a = mathrmdim(a) = mathrmtr(mathrmid_a) for the quantum dimension of the simple objects a. With this information, we can then compute F^abaraa_a, which has a single element (it's a 1  1 matrix), and find F^abaraa_a = fracχ_ad_a, where we've used tildeη_a = ϵ_a^ and the snake rules. Hence, from the F-symbol we can get the quantum dimensions as d_a = F^abaraa_a^-1 and the Frobenius-Schur indicator as χ_a = F^abaraa_aF^abaraa_a. Graphically:","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: ZtoF)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"With these definitions, we can now also evaluate the action of the evaluation map on the splitting tensors, namely","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: splittingfusionrelation)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"where again bar denotes complex conjugation in the second line, and we introduced two new families of matrices A^ab_c and B^ab_c, whose entries are composed out of entries of the F-symbol, namely","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"A^ab_c^nu_mu = sqrtfracd_a d_bd_c χ_bara   overlineF^baraab_b_(111)^(cμν)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"and","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"B^ab_c^nu_mu = sqrtfracd_a d_bd_c F^abbarb_a^(111)_(cμν)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Composing the left hand side of first graphical equation with its dagger, and noting that the resulting element f  mathrmEnd(a) must satisfy f = d_a^-1 mathrmtr(f) mathrmid_a, i.e.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: Brelation)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"allows to conclude that _ν B^ab_c^ν_μ overlineB^ab_c^ν_μ = delta_μμ, i.e. B^ab_c is a unitary matrix. The same result follows for A^ab_c in analogue fashion.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"note: Note\nIn the context of fusion categories, one often resorts to the so-called isotopic normalization convention, where splitting tensors are normalized as (X^ab_cμ)^  X^ab_cmu = sqrtfracd_a d_bd_c δ_cc δ_μμ mathrmid_c. This kills some of the quantum dimensions in formulas like the ones above and essentially allows to rotate the graphical notation of splitting and fusion tensors (up to a unitary transformation). Nonetheless, for our implementation of tensors and manipulations thereof (in particular orthonormal factorizations such as the singular value decomposition), we find it more convenient to work with the original normalization convention.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Let us again study in more detail the example mathbfRep_mathsfG. The quantum dimension d_a of an irrep a is just the normal vector space dimension (over 𝕜) of the space on which the irrep acts. The dual of an irrep a is its contragradient representation, which in the case of unitary representations amounts to the complex conjugate representation. This representation can be isomorphic to an already defined irrep bara, for example a itself. If that happens, it does not automatically imply that the irrep a is real-valued. For example, all irreps of mathsfSU_2 are self- dual, with the isomorphism given by a π rotation over the y-axis (in the standard basis). The resulting Frobenius-Schur indicator is +1 for integer spin irreps, and -1 for half-integer spin irreps. The value χ_a=+1 indicates that the representation can be made real, e.g. the integer spin representations can be written as tensor representations of mathsfSO_3 by a change of basis. The value χ_a=-1 indicates that the representation is quaternionic and cannot be made real.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The (co)evaluation expresses that the standard contraction of a vector with a dual vector yields a scalar, i.e. a representation and its dual (the contragradient) yields the trivial representation when correctly contracted. The coevaluation together with the isomorphism between the conjugate of irrep a and some irrep bara yields a way to define the Clebsch-Gordan coefficients (i.e. the splitting and fusion tensor) for fusing a  bara to the trivial irrep, i.e. to what is called a singlet in the case of mathsfSU_2.","category":"page"},{"location":"man/categories/#Braidings-and-twists","page":"Optional introduction to category theory","title":"Braidings and twists","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Finally, we can study the braiding structure of a pivotal fusion category. Not all fusion categories have a braiding structure. The existence of a braiding isomorphism τ_VWVWWV requires at the very least that N^ab_c = N^ba_c at the level of the simple objects. We can then express τ_ab in terms of its matrix elements as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"τ_ab  X^ab_cμ = _ν R^ab_c^ν_μ X^ba_cν","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"or graphically","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: braidingR)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The hexagon coherence axiom for the braiding and the associator can then be reexpressed in terms of the F-symbols and R-symbols.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"We can now compute the twist, which for simple objects needs to be scalars (or in fact complex phases because of unitarity) multiplying the identity morphism, i.e.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"θ_a =  mathrmid_a sum_bμ fracd_bd_a R^aa_b^μ_μ","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"or graphically","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: simpletwist)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Henceforth, we reserve θ_a for the scalar value itself, that is, θ_a is the value of the 8-type braiding and called as topological spin","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: topologicalspin)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"Note that θ_a = θ_bara as our category is spherical and thus a ribbon category.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The defining relation of a twist implies","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"R^ba_c^κ_μ R^ab_c^μ_ν = fractheta_cθ_a θ_b δ^κ_ν","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"or graphically","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: twistproperty)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"If a = bara, we can furthermore relate the twist, the braiding and the Frobenius- Schur indicator via θ_a χ_a R^aa_1 =1, because of","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: twistfrobeniusschur)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"For the example of mathbfRep_mathsfG, the braiding acts simply as the swap of the two vector spaces on which the representations are acting and is thus symmetric, i.e. τ_ba  τ_ab = mathrmid_ab. All the twists are simply θ_a = 1. For an irrep that is self-dual, i.e. bara=a, the final expression simplifies to R^aa_1 = χ_a and thus states that the fusion from a  a to the trivial sector is either symmetric under swaps if χ_a=1 or antisymmetric if χ_a=-1. For the case of mathsfSU_2, the coupling of two spin j states to a singlet is symmetric for integer j and antisymmetric for half-integer j.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"With this, we conclude our exposition of unitary fusion categories. There are many fusion categories that do not originate from the representation theory of groups, but are related to quantum groups and the representation theory of quasi-triangular Hopf algebras. They have non-integer quantum dimensions and generically admit for braidings which are not symmetric. A particular class of interesting fusion categories are modular fusion categories, which provide the mathematical structure for the theory of anyons and topological sectors in topological quantum states of matter. Thereto, one defines the modular S matrix, defined as","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"S_ab = frac1D mathrmtr(τ_ab  τ_ba) = frac1D _c N^ab_c d_c fracθ_cθ_a θ_b","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"or graphically","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"(Image: Smatrix)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"The normalization constant is given by D = sqrtsum_a d_a^2, and thus truly requires a fusion category with a finite number of (isomorphism classes of) simple objects. For a modular fusion category, the symmetric matrix S is non-degenerate, and in fact (for a unitary fusion category) unitary. Note, however, that for a symmetric braiding S_ab = fracd_a d_bD and thus S is a rank 1 matrix. In particular, mathbfRep_mathsfG is never a modular category and the properties associated with this are not of (direct) importance for TensorLabXD.jl. We refer to the references for further information about modular categories.","category":"page"},{"location":"man/categories/#Bibliography","page":"Optional introduction to category theory","title":"Bibliography","text":"","category":"section"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"[turaev]:   Turaev, V. G., & Virelizier, A. (2017). Monoidal categories and topological field theory (Vol. 322).\n        Birkhäuser.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"[selinger]: Selinger, P. (2010). A survey of graphical languages for monoidal categories.\n        In New structures for physics (pp. 289-355). Springer, Berlin, Heidelberg.\n        [https://arxiv.org/abs/0908.3347](https://arxiv.org/abs/0908.3347)","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"[kassel]:   Kassel, C. (2012). Quantum groups (Vol. 155).\n        Springer Science & Business Media.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"[kitaev]:   Kitaev, A. (2006). Anyons in an exactly solved model and beyond.\n        Annals of Physics, 321(1), 2-111.","category":"page"},{"location":"man/categories/","page":"Optional introduction to category theory","title":"Optional introduction to category theory","text":"[beer]:     From categories to anyons: a travelogue\n        Kerstin Beer, Dmytro Bondarenko, Alexander Hahn, Maria Kalabakov, Nicole Knust, Laura Niermann, Tobias J. Osborne, Christin Schridde, Stefan Seckmeyer, Deniz E. Stiegemann, and Ramona Wolf\n        [https://arxiv.org/abs/1811.06670](https://arxiv.org/abs/1811.06670)","category":"page"},{"location":"man/tutorial/#s_tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Before discussing at length all aspects of this package, both its usage and implementation, we start with a short tutorial to sketch the main capabilities. Thereto, we start by loading TensorLabXD.jl","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"using TensorLabXD","category":"page"},{"location":"man/tutorial/#Cartesian-tensors","page":"Tutorial","title":"Cartesian tensors","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The most important objects in TensorLabXD.jl are tensors, which we now create with random normally distributed entries in the following manner","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A = Tensor(randn, ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The tensor is created by specifying the vector space associated to each of the tensor indices, in this case ℝ^n (\\bbR+TAB). The tensor lives in the tensor product of the index spaces, which can be obtained by typing ⊗ (\\otimes+TAB) or *. The tensor A is printed as an instance of a parametric type TensorMap.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Briefly sidetracking into the nature of ℝ^n:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"V = ℝ^3\ntypeof(V)\nV == CartesianSpace(3)\nsupertype(CartesianSpace)\nsupertype(EuclideanSpace)\nsupertype(InnerProductSpace)\nsupertype(ElementarySpace)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"We have seen that ℝ^n can also be created using the longer syntax CartesianSpace(n). It is subtype of EuclideanSpace{ℝ}, a space with a standard Euclidean inner product over the real numbers. Furthermore,","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"W = ℝ^3 ⊗ ℝ^2 ⊗ ℝ^4\ntypeof(W)\nsupertype(ProductSpace)\nsupertype(CompositeSpace)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The tensor product of a number of CartesianSpaces is some generic parametric ProductSpace type, specifically ProductSpace{CartesianSpace,N} for the tensor product of N instances of CartesianSpace.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Tensors behave like vectors (but not VectorSpace instance), so we can compute linear combinations provided they live in the same space.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"B = Tensor(randn, ℝ^3 * ℝ^2 * ℝ^4);\nC = 0.5*A + 2.5*B","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Tensors also have inner product and norm, which they inherit from the Euclidean inner product on the individual ℝ^n spaces:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"scalarBA = dot(B,A)\nscalarAA = dot(A,A)\nnormA² = norm(A)^2","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"If two tensors live in different spaces, these operations have no meaning and are thus not allowed","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"B′ = Tensor(randn, ℝ^4 * ℝ^2 * ℝ^3);\nspace(B′) == space(A)\nC′ = 0.5*A + 2.5*B′\nscalarBA′ = dot(B′,A)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"However, in this particular case, we can reorder the indices of B′ to match space of A, using the routine permute (we deliberately choose not to overload permutedims from Julia Base):","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"space(permute(B′,(3,2,1))) == space(A)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"We can contract two tensors using Einstein summation convention, which takes the interface from TensorContractionsXS.jl. TensorLabXD.jl reexports the @tensor macro","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"@tensor D[a,b,c,d] := A[a,b,e]*B[d,c,e]\n@tensor d = A[a,b,c]*A[a,b,c]\nd ≈ scalarAA ≈ normA²","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The := is to create a new tensor D. The = write the contraction result in an existing tensor d, which would yield an error if no tensor d exists. If the contraction yields a scalar, regular assignment with = can be used.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"We can also factorize a tensor. With a plain Julia Array, one would apply permutedims and reshape to cast the array into a matrix before applying e.g. the singular value decomposition. With TensorLabXD.jl, one just specifies which indices go to the left (rows) and right (columns)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"U, S, Vd = tsvd(A, (1,3), (2,));\n@tensor A′[a,b,c] := U[a,c,d]*S[d,e]*Vd[e,b];\nA ≈ A′\nU","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The tsvd routine returns the decomposition of the linear map as three factors, U, S and Vd, each of them a TensorMap, such that Vd is what is commonly called V'.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that U is printed as TensorMap((ℝ^3 ⊗ ℝ^4) ← ProductSpace(ℝ^2)), which is a linear map between two ProductSpace instances, with","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"codomain(U)\ndomain(U)\ncodomain(A)\ndomain(A)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Hence, a Tensor instance such as A is just a specific case of TensorMap with an empty domain, i.e. a ProductSpace{CartesianSpace,0} instance. For example, we can represent a vector v and matrix m as","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"v = Tensor(randn, ℝ^3)\nm1 = TensorMap(randn, ℝ^4, ℝ^3)\nm2 = TensorMap(randn, ℝ^4 → ℝ^2) # alternative syntax for TensorMap(randn, ℝ^2, ℝ^4)\nw = m1 * v # matrix vector product\nm3 = m2 * m1 # matrix matrix product","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that for the construction of m1, in accordance with how one specifies the dimensions of a matrix (e.g. randn(4,3)), the first space is the codomain and the second the domain. This is somewhat opposite to the general notation for a function f:domain→codomain, so that we also support this more mathematical notation, as illustrated in the construction of m2. There is a third syntax which mixes both like TensorMap(randn, codomain←domain).","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This 'matrix vector' or 'matrix matrix' product can be computed between any two TensorMap instances for which the domain of the first matches with the codomain of the second, e.g.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"v′ = v ⊗ v\nm1′ = m1 ⊗ m1\nw′ = m1′ * v′\nw′ ≈ w ⊗ w","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Another example involves checking that U from the singular value decomposition is a left isometric tensor","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"codomain(U)\ndomain(U)\nspace(U)\nU'*U # should be the identity on the corresponding domain = codomain\nU'*U ≈ one(U'*U)\nP = U*U' # should be a projector\nP*P ≈ P","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, the adjoint of a TensorMap results in a new tensor map (actually a simple wrapper of type AdjointTensorMap <: AbstractTensorMap) with domain and codomain interchanged.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Our original tensor A living in ℝ^4 * ℝ^2 * ℝ^3 is isomorphic to a linear map ℝ^3 → ℝ^4 * ℝ^2. This is where the full power of permute emerges. It allows to specify a permutation where some indices go to the codomain, and others go to the domain, as","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A2 = permute(A,(1,2),(3,))\ncodomain(A2)\ndomain(A2)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In fact, tsvd(A, (1,3),(2,)) is a shorthand for tsvd(permute(A,(1,3),(2,))), where tsvd(A::TensorMap) will just compute the singular value decomposition according to the given codomain and domain of A.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The @tensor macro treats all indices at the same footing and thus does not distinguish between codomain and domain. The linear numbering is first all indices in the codomain, followed by all indices in the domain. However, when @tensor creates a new tensor (using :=), the default syntax creates a Tensor, i.e. with all indices in the codomain.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"@tensor A′[a,b,c] := U[a,c,d]*S[d,e]*Vd[e,b];\ncodomain(A′)\ndomain(A′)\n@tensor A2′[(a,b);(c,)] := U[a,c,d]*S[d,e]*Vd[e,b];\ncodomain(A2′)\ndomain(A2′)\n@tensor A2′′[a b; c] := U[a,c,d]*S[d,e]*Vd[e,b];\nA2 ≈ A2′ == A2′′","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"As illustrated for A2′ and A2′′, additional syntax is available that enables one to immediately specify the desired codomain and domain indices.","category":"page"},{"location":"man/tutorial/#Complex-tensors","page":"Tutorial","title":"Complex tensors","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"To create a complex tensor, we work with complex vector spaces","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A = Tensor(randn, ComplexF64, ℂ^3 ⊗ ℂ^2 ⊗ ℂ^4)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"where ℂ is obtained as \\bbC+TAB and we also have the non-Unicode alternative ℂ^n == ComplexSpace(n). Most functionality works exactly the same with real tensors","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"B = Tensor(randn, ℂ^3 * ℂ^2 * ℂ^4);\nC = im*A + (2.5-0.8im)*B\nscalarBA = dot(B,A)\nscalarAA = dot(A,A)\nnormA² = norm(A)^2\nU,S,Vd = tsvd(A,(1,3),(2,));\n@tensor A′[a,b,c] := U[a,c,d]*S[d,e]*Vd[e,b];\nA′ ≈ A\npermute(A,(1,3),(2,)) ≈ U*S*Vd","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"However, trying the following","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"@tensor D[a,b,c,d] := A[a,b,e]*B[d,c,e]\n@tensor d = A[a,b,c]*A[a,b,c]","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"we obtain SpaceMismatch errors. The reason for this is that, with ComplexSpace, an index in a space ℂ^n can only be contracted with an index in the dual space dual(ℂ^n) == (ℂ^n)'. Because of the complex Euclidean inner product, the dual space is equivalent to the complex conjugate space, but not the the space itself.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"dual(ℂ^3) == conj(ℂ^3) == (ℂ^3)'\n(ℂ^3)' == ℂ^3\n@tensor d = conj(A[a,b,c])*A[a,b,c]\nd ≈ normA²","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"This might seem overly strict or puristic, but we believe that it can help to catch errors, e.g. unintended contractions. In particular, contracting two indices both living in ℂ^n would represent an operation that is not invariant under arbitrary unitary basis changes.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"It also makes clear the isomorphism between linear maps ℂ^n → ℂ^m and tensors in ℂ^m ⊗ (ℂ^n)':","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"m = TensorMap(randn, ComplexF64, ℂ^3, ℂ^4)\nm2 = permute(m, (1,2), ())\ncodomain(m2)\nspace(m, 1)\nspace(m, 2)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Hence, spaces become their corresponding dual space if they are 'permuted' from the domain to the codomain or vice versa. Also, spaces in the domain are reported as their dual when probing them with space(A, i). Generalizing matrix vector and matrix matrix multiplication to arbitrary tensor contractions require that the two indices to be contracted have spaces which are each others dual. Knowing this, all the other functionality of tensors with CartesianSpace indices remains the same for tensors with ComplexSpace indices.","category":"page"},{"location":"man/tutorial/#Symmetries","page":"Tutorial","title":"Symmetries","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"So far, the functionality that we have illustrated seems to be just a wrapper around dense multidimensional arrays, e.g. Julia's Base Array. More power becomes visible when involving symmetries. With symmetries, we imply that there is some symmetry action defined on every vector space associated with each of the indices of a TensorMap, and the TensorMap is then required to be equivariant, i.e. it acts as an intertwiner between the tensor product representation on the domain and that on the codomain. By Schur's lemma, this means that the tensor is block diagonal in some basis corresponding to the irreducible representations that can be coupled to by combining the different representations on the different spaces in the domain or codomain. For Abelian symmetries, this does not require a basis change and it just imposes that the tensor has some block sparsity. Let's clarify all of this with some examples.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"We start with a simple ℤ₂ symmetry:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"V1 = ℤ₂Space(0=>3,1=>2)\ndim(V1)\nV2 = ℤ₂Space(0=>1,1=>1)\ndim(V2)\nA = Tensor(randn, V1*V1*V2')\nconvert(Array, A)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, we create a space 5-dimensional space V1, which has a three-dimensional subspace associated with charge 0 (the trivial irrep of ℤ₂) and a two-dimensional subspace with charge 1 (the non-trivial irrep). Similar for V2, where both subspaces are one- dimensional. Representing the tensor as a dense Array, we see that it is zero in those regions where the charges don't add to zero (modulo 2). The Tensor(Map) type in TensorLabXD.jl won't store these zero blocks, and only stores the non-zero information, which we can recognize in the full Array representation.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"From there on, the resulting tensors support all of the same operations as the ones we encountered in the previous examples.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"B = Tensor(randn, V1'*V1*V2);\n@tensor C[a,b] := A[a,c,d]*B[c,b,d]\nU,S,V = tsvd(A,(1,3),(2,));\nU'*U # should be the identity on the corresponding domain = codomain\nU'*U ≈ one(U'*U)\nP = U*U' # should be a projector\nP*P ≈ P","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"We also support other abelian symmetries, e.g.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"V = U₁Space(0=>2,1=>1,-1=>1)\ndim(V)\nA = TensorMap(randn, V*V, V)\ndim(A)\nconvert(Array, A)\n\nV = Rep[U₁ × ℤ₂]((0, 0)=>2, (-1, 0)=>1, (1, 1)=>1)\ndim(V)\nA = TensorMap(randn, V*V, V)\ndim(A)\nconvert(Array, A)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, the dim of a TensorMap returns the number of linearly independent components, i.e. the number of non-zero entries in the case of an abelian symmetry. Note that we can use × (obtained as \\times+TAB) to combine different symmetries.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The general space associated with symmetries is a GradedSpace. The concrete type of GradedSpace can be obtained as Vect[I], or if I == Irrep[G] for some G<:Group, as Rep[G]. The ℤ₂Space (or Z2Space) and U₁Space (or U1Space) are just convenient synonyms, e.g.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Rep[U₁](0=>3,1=>2,-1=>1) == U1Space(-1=>1,1=>2,0=>3)\nV = U₁Space(1=>2,0=>3,-1=>1)\nfor s in sectors(V)\n  @show s, dim(V, s)\nend\nU₁Space(-1=>1,0=>3,1=>2) == GradedSpace(Irrep[U₁](1)=>2, Irrep[U₁](0)=>3, Irrep[U₁](-1)=>1)\nsupertype(GradedSpace)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Generally, GradedSpace supports a grading that is derived from the fusion ring of a (unitary) pre-fusion category. The order in which the charges and their corresponding subspace dimensionality are specified is irrelevant. We can probe the subspace dimension of a certain sector s in a space V with dim(V, s).","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The GradedSpace is a subtype of EuclideanSpace{ℂ}, i.e., it has the standard Euclidean inner product and we assume all representations to be unitary.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"TensorLabXD.jl also allows for non-abelian symmetries such as SU₂. In this case, the vector space is characterized via the spin quantum number (i.e. the irrep label of SU₂) for each of its subspaces, and is created using SU₂Space (or SU2Space or Rep[SU₂])","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"V = SU₂Space(0=>2,1/2=>1,1=>1)\ndim(V)\nV == Rep[SU₂](0=>2, 1=>1, 1//2=>1)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"V has a two-dimensional subspace with spin zero, and two one-dimensional subspaces with spin 1/2 and spin 1. A subspace with spin j has an additional 2j+1 dimensional degeneracy on which the irreducible representation acts. This brings the total dimension to 2*1 + 1*2 + 1*3. Creating a tensor with SU₂ symmetry yields","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"A = TensorMap(randn, V*V, V)\ndim(A)\nconvert(Array, A)\nnorm(A) ≈ norm(convert(Array, A))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In this case, the full Array representation of the tensor has again many zeros, but it is less obvious to recognize the dense blocks, as there are additional zeros and the numbers in the original tensor data do not match with those in the Array. The reason is of course that the original tensor data now needs to be transformed with a construction known as fusion trees, which are made up out of the Clebsch-Gordan coefficients of the group. Indeed, note that the non-zero blocks are also no longer labeled by a list of sectors, but by pair of fusion trees. This will be explained further in the manual. However, the Clebsch-Gordan coefficients of the group are only needed to actually convert a tensor to an Array. For working with tensors with SU₂Space indices, e.g. contracting or factorizing them, the Clebsch-Gordan coefficients are never needed explicitly. Instead, recoupling relations are used to symbolically manipulate the basis of fusion trees, and this only requires what is known as the topological data of the group (or its representation theory).","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In fact, this formalism extends beyond the case of group representations on vector spaces, and can also deal with super vector spaces (to describe fermions) and more general (unitary) fusion categories. Preliminary support for these generalizations is present in TensorLabXD.jl and will be extended in the near future.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"All of these concepts will be explained throughout the remainder of this manual, including several details regarding their implementation. However, to just use tensors and their manipulations (contractions, factorizations, ...) in higher level algorithms (e.g. tensoer network algorithms), one does not need to know or understand most of these details, and one can immediately refer to the general interface of the TensorMap type, discussed on the last page. Adhering to this interface should yield code and algorithms that are oblivious to the underlying symmetries and can thus work with arbitrary symmetric tensors.","category":"page"}]
}
