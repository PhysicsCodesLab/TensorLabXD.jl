<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial ¬∑ TensorLabXD.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorLabXD.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Cartesian-tensors"><span>Cartesian tensors</span></a></li><li><a class="tocitem" href="#Complex-tensors"><span>Complex tensors</span></a></li><li><a class="tocitem" href="#Symmetries"><span>Symmetries</span></a></li></ul></li><li><a class="tocitem" href="../categories/">Optional introduction to category theory</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li><a class="tocitem" href="../sectors/">Sectors, representation spaces and fusion trees</a></li><li><a class="tocitem" href="../tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PhysicsCodesLab/TensorLabXD.jl/blob/master/docs/src/man/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="s_tutorial"><a class="docs-heading-anchor" href="#s_tutorial">Tutorial</a><a id="s_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#s_tutorial" title="Permalink"></a></h1><p>Before discussing at length all aspects of this package, both its usage and implementation, we start with a short tutorial to sketch the main capabilities. Thereto, we start by loading TensorLabXD.jl</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using TensorLabXD</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><h2 id="Cartesian-tensors"><a class="docs-heading-anchor" href="#Cartesian-tensors">Cartesian tensors</a><a id="Cartesian-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Cartesian-tensors" title="Permalink"></a></h2><p>The most important objects in TensorLabXD.jl are tensors, which we now create with random normally distributed entries in the following manner</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = Tensor(randn, ‚Ñù^3 ‚äó ‚Ñù^2 ‚äó ‚Ñù^4)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚Ñù^3 ‚äó ‚Ñù^2 ‚äó ‚Ñù^4) ‚Üê ProductSpace{CartesianSpace, 0}()):
[:, :, 1] =
 -0.5507605320092969   -0.919629089885813
  0.13554612347510797   1.7588897080814283
 -0.28991887860263776  -0.6796794431806901

[:, :, 2] =
 -0.5812814772190394   1.0278641526698287
 -2.4385976720929086  -0.4691526857926431
 -2.2294998788983063  -0.48848081402963955

[:, :, 3] =
 -0.9947213409440684  -0.6538344221686033
  0.6554577227993095   0.5351503946975269
 -0.8842899347931931   0.8946110904852927

[:, :, 4] =
  0.5360607393870641  -0.5904062067081328
  0.6990892901001455   1.2028391078467375
 -0.3542212367807085   1.1108183312024404</code></pre><p>The tensor is created by specifying the vector space associated to each of the tensor indices, in this case <code>‚Ñù^n</code> (<code>\bbR+TAB</code>). The tensor lives in the tensor product of the index spaces, which can be obtained by typing <code>‚äó</code> (<code>\otimes+TAB</code>) or <code>*</code>. The tensor <code>A</code> is printed as an instance of a parametric type <code>TensorMap</code>.</p><p>Briefly sidetracking into the nature of <code>‚Ñù^n</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V = ‚Ñù^3</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(V)</code><code class="nohighlight hljs ansi" style="display:block;">CartesianSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V == CartesianSpace(3)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supertype(CartesianSpace)</code><code class="nohighlight hljs ansi" style="display:block;">EuclideanSpace{‚Ñù}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supertype(EuclideanSpace)</code><code class="nohighlight hljs ansi" style="display:block;">InnerProductSpace{ùïú} where ùïú</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supertype(InnerProductSpace)</code><code class="nohighlight hljs ansi" style="display:block;">ElementarySpace{ùïú} where ùïú</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supertype(ElementarySpace)</code><code class="nohighlight hljs ansi" style="display:block;">VectorSpace</code></pre><p>We have seen that <code>‚Ñù^n</code> can also be created using the longer syntax <code>CartesianSpace(n)</code>. It is subtype of <code>EuclideanSpace{‚Ñù}</code>, a space with a standard Euclidean inner product over the real numbers. Furthermore,</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; W = ‚Ñù^3 ‚äó ‚Ñù^2 ‚äó ‚Ñù^4</code><code class="nohighlight hljs ansi" style="display:block;">(‚Ñù^3 ‚äó ‚Ñù^2 ‚äó ‚Ñù^4)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(W)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSpace{CartesianSpace,3}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supertype(ProductSpace)</code><code class="nohighlight hljs ansi" style="display:block;">CompositeSpace{S} where S&lt;:ElementarySpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supertype(CompositeSpace)</code><code class="nohighlight hljs ansi" style="display:block;">VectorSpace</code></pre><p>The tensor product of a number of <code>CartesianSpace</code>s is some generic parametric <code>ProductSpace</code> type, specifically <code>ProductSpace{CartesianSpace,N}</code> for the tensor product of <code>N</code> instances of <code>CartesianSpace</code>.</p><p>Tensors behave like vectors (but not <code>VectorSpace</code> instance), so we can compute linear combinations provided they live in the same space.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = Tensor(randn, ‚Ñù^3 * ‚Ñù^2 * ‚Ñù^4);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; C = 0.5*A + 2.5*B</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚Ñù^3 ‚äó ‚Ñù^2 ‚äó ‚Ñù^4) ‚Üê ProductSpace{CartesianSpace, 0}()):
[:, :, 1] =
  0.2275752351312052  1.9271897965829519
 -1.4051908165195834  1.3748691324680453
 -4.833761431114894   5.143652227913992

[:, :, 2] =
  2.8477528323481165  1.2680976268029167
 -0.8948117191557922  3.663808498380515
  6.35798849771765    0.007369532900853931

[:, :, 3] =
 -1.5532776890855085    -1.705586657480394
 -0.009025764964163074   1.8527225703340882
  1.7663751532104688    -1.6886121649802048

[:, :, 4] =
 -0.5875945338769732   -4.559300738859033
 -1.2305715167046103    2.2447149130735267
  0.40328490873884915  -2.1092939281384124</code></pre><p>Tensors also have inner product and norm, which they inherit from the Euclidean inner product on the individual <code>‚Ñù^n</code> spaces:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; scalarBA = dot(B,A)</code><code class="nohighlight hljs ansi" style="display:block;">-10.455989994365968</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; scalarAA = dot(A,A)</code><code class="nohighlight hljs ansi" style="display:block;">25.22383349243945</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; normA¬≤ = norm(A)^2</code><code class="nohighlight hljs ansi" style="display:block;">25.223833492439447</code></pre><p>If two tensors live in different spaces, these operations have no meaning and are thus not allowed</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B‚Ä≤ = Tensor(randn, ‚Ñù^4 * ‚Ñù^2 * ‚Ñù^3);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; space(B‚Ä≤) == space(A)</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; C‚Ä≤ = 0.5*A + 2.5*B‚Ä≤</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; scalarBA‚Ä≤ = dot(B‚Ä≤,A)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch()</code></pre><p>However, in this particular case, we can reorder the indices of <code>B‚Ä≤</code> to match space of <code>A</code>, using the routine <code>permute</code> (we deliberately choose not to overload <code>permutedims</code> from Julia Base):</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; space(permute(B‚Ä≤,(3,2,1))) == space(A)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>We can contract two tensors using Einstein summation convention, which takes the interface from <a href="https://github.com/PhysicsCodesLab/TensorContractionsXS.jl">TensorContractionsXS.jl</a>. TensorLabXD.jl reexports the <code>@tensor</code> macro</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @tensor D[a,b,c,d] := A[a,b,e]*B[d,c,e]</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚Ñù^3 ‚äó ‚Ñù^2 ‚äó ‚Ñù^2 ‚äó ‚Ñù^3) ‚Üê ProductSpace{CartesianSpace, 0}()):
[:, :, 1, 1] =
 -0.6038487264674836   1.5835483544797557
 -3.550149103481492   -0.8727984093037531
 -2.3624188312647023  -1.507988985698669

[:, :, 2, 1] =
 -1.0669894628642882    0.7995969420844645
 -2.160080678112999    -0.8088641272549192
  0.14245113108189664  -3.1843215920555874

[:, :, 1, 2] =
  0.044228317637078934   1.136480504804949
 -0.926527511170293     -1.9295419575002317
  0.2244381902628825    -0.4855395535301781

[:, :, 2, 2] =
 -1.2939171334620936  0.6179071028870382
 -2.9006528339969133  0.7469484447827401
 -4.3275605457475335  0.4009908520331167

[:, :, 1, 3] =
 -1.4588368794370843   4.082497228704178
 -6.802084649887696   -3.9491712089458773
 -6.983863104051389    0.8628294226002257

[:, :, 2, 3] =
 -0.9880587691011552  -0.725745642313056
 -1.253271395780404    2.0714271110518263
  0.2727731163263721  -3.488296039544006</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @tensor d = A[a,b,c]*A[a,b,c]</code><code class="nohighlight hljs ansi" style="display:block;">25.22383349243945</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d ‚âà scalarAA ‚âà normA¬≤</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>The <code>:=</code> is to create a new tensor <code>D</code>. The <code>=</code> write the contraction result in an existing tensor <code>d</code>, which would yield an error if no tensor <code>d</code> exists. If the contraction yields a scalar, regular assignment with <code>=</code> can be used.</p><p>We can also factorize a tensor. With a plain Julia <code>Array</code>, one would apply <code>permutedims</code> and <code>reshape</code> to cast the array into a matrix before applying e.g. the singular value decomposition. With TensorLabXD.jl, one just specifies which indices go to the left (rows) and right (columns)</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; U, S, Vd = tsvd(A, (1,3), (2,));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @tensor A‚Ä≤[a,b,c] := U[a,c,d]*S[d,e]*Vd[e,b];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A ‚âà A‚Ä≤</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚Ñù^3 ‚äó ‚Ñù^4) ‚Üê ProductSpace(‚Ñù^2)):
[:, :, 1] =
 -0.22489374599252301  -0.013749071756579842  ‚Ä¶  0.05267965645364004
  0.22682653277918227  -0.5926557348189674       0.2894377436229445
 -0.14026795864617125  -0.5485021017868097       0.04582771574549339

[:, :, 2] =
  0.1909913282624529   -0.3934908445464964   ‚Ä¶   0.25643036051201135
 -0.5033447648166127   -0.22709460615045873     -0.25301058565608653
  0.15877654217985282  -0.18988887992458264     -0.384039266015325</code></pre><p>The <code>tsvd</code> routine returns the decomposition of the linear map as three factors, <code>U</code>, <code>S</code> and <code>Vd</code>, each of them a <code>TensorMap</code>, such that <code>Vd</code> is what is commonly called <code>V&#39;</code>.</p><p>Notice that <code>U</code> is printed as <code>TensorMap((‚Ñù^3 ‚äó ‚Ñù^4) ‚Üê ProductSpace(‚Ñù^2))</code>, which is a linear map between two <code>ProductSpace</code> instances, with</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; codomain(U)</code><code class="nohighlight hljs ansi" style="display:block;">(‚Ñù^3 ‚äó ‚Ñù^4)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(U)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSpace(‚Ñù^2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; codomain(A)</code><code class="nohighlight hljs ansi" style="display:block;">(‚Ñù^3 ‚äó ‚Ñù^2 ‚äó ‚Ñù^4)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(A)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSpace{CartesianSpace, 0}()</code></pre><p>Hence, a <code>Tensor</code> instance such as <code>A</code> is just a specific case of <code>TensorMap</code> with an empty domain, i.e. a <code>ProductSpace{CartesianSpace,0}</code> instance. For example, we can represent a vector <code>v</code> and matrix <code>m</code> as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = Tensor(randn, ‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(ProductSpace(‚Ñù^3) ‚Üê ProductSpace{CartesianSpace, 0}()):
 -1.3158384494790083
 -0.8590325571176078
 -0.724237779152545</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m1 = TensorMap(randn, ‚Ñù^4, ‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(ProductSpace(‚Ñù^4) ‚Üê ProductSpace(‚Ñù^3)):
 -1.7014807467506596    0.407395738101822   -0.4095365348240949
 -0.23085376825015733  -0.4548826553715345   0.9551697010954312
  0.38708887472655956   1.0821444778749845  -0.5999440142939461
  0.5368684487918179   -0.7701231937594717  -1.659328679592581</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m2 = TensorMap(randn, ‚Ñù^4 ‚Üí ‚Ñù^2) # alternative syntax for TensorMap(randn, ‚Ñù^2, ‚Ñù^4)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(ProductSpace(‚Ñù^2) ‚Üê ProductSpace(‚Ñù^4)):
 0.9550749961089623  -1.1063259927303946  ‚Ä¶  1.786992881907752
 1.938993328218406   -0.9049909826728328     0.8867745457864471</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; w = m1 * v # matrix vector product</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(ProductSpace(‚Ñù^4) ‚Üê ProductSpace{CartesianSpace, 0}()):
  2.185509415425181
  0.0027552920677748906
 -1.0044416422023066
  1.1568772669906076</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m3 = m2 * m1 # matrix matrix product</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(ProductSpace(‚Ñù^2) ‚Üê ProductSpace(‚Ñù^3)):
 -0.19601852622283192   0.11507599527641375  -4.745129035871821
 -3.2030478807761718   -1.1276221854504285   -2.2172461834414237</code></pre><p>Note that for the construction of <code>m1</code>, in accordance with how one specifies the dimensions of a matrix (e.g. <code>randn(4,3)</code>), the first space is the codomain and the second the domain. This is somewhat opposite to the general notation for a function <code>f:domain‚Üícodomain</code>, so that we also support this more mathematical notation, as illustrated in the construction of <code>m2</code>. There is a third syntax which mixes both like <code>TensorMap(randn, codomain‚Üêdomain)</code>.</p><p>This &#39;matrix vector&#39; or &#39;matrix matrix&#39; product can be computed between any two <code>TensorMap</code> instances for which the domain of the first matches with the codomain of the second, e.g.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v‚Ä≤ = v ‚äó v</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚Ñù^3 ‚äó ‚Ñù^3) ‚Üê ProductSpace{CartesianSpace, 0}()):
 1.7314308251273207  1.1303480680096207  0.9529799163742052
 1.1303480680096207  0.7379369341880162  0.622143831386588
 0.9529799163742052  0.622143831386588   0.5245203607518105</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m1‚Ä≤ = m1 ‚äó m1</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚Ñù^4 ‚äó ‚Ñù^4) ‚Üê (‚Ñù^3 ‚äó ‚Ñù^3)):
[:, :, 1, 1] =
  2.895036731563182    0.3927932419924814    ‚Ä¶  -0.9134713291571707
  0.3927932419924814   0.053293462315297344     -0.1239381044582078
 -0.6586242676286191  -0.08936092537833937       0.20781580371901837
 -0.9134713291571707  -0.1239381044582078        0.28822773130813284

[:, :, 2, 1] =
 -0.6931760046885242  -0.0940488413098598   ‚Ä¶   0.2187179179591229
  0.7739740801454814   0.10501137510415641     -0.24421214557161883
 -1.8412479943068312  -0.24981713050853915      0.5809692272053747
  1.3103497868078688   0.17778584129622008     -0.4134548444122482

[:, :, 3, 1] =
  0.6968185290941785   0.09454305230025409  ‚Ä¶  -0.21986724417458817
 -1.6252028562934586  -0.2205045248162567       0.5128004757600485
  1.0207931894494517   0.1384993364388837      -0.32209101231592707
  2.8233158008579706   0.38306227844950524     -0.8908412142486445

[:, :, 1, 2] =
 -0.6931760046885242    0.7739740801454814   ‚Ä¶   1.3103497868078688
 -0.0940488413098598    0.10501137510415641      0.17778584129622008
  0.15769835783023045  -0.17608001520039668     -0.2981061204731781
  0.2187179179591229   -0.24421214557161883     -0.4134548444122482

[:, :, 2, 2] =
  0.16597128742352835  -0.18531725513480302  ‚Ä¶  -0.31374490695097246
 -0.18531725513480302   0.2069182301578582       0.35031568334051527
  0.4408610482966901   -0.4922487535914157      -0.833384561410259
 -0.31374490695097246   0.35031568334051527      0.5930897335662888

[:, :, 3, 2] =
 -0.16684343888432468   0.1862910664324412   ‚Ä¶   0.3153935841599191
  0.3891320653902699   -0.43449012996472464     -0.7355983407898934
 -0.2444146345230522    0.272904126296288        0.4620308003649319
 -0.6760034321761412    0.7547998359072154       1.2778875022245255

[:, :, 1, 3] =
  0.6968185290941785   -1.6252028562934586  ‚Ä¶   2.8233158008579706
  0.09454305230025409  -0.2205045248162567      0.38306227844950524
 -0.15852703642447338   0.3697355647699347     -0.6423076713850001
 -0.21986724417458817   0.5128004757600485     -0.8908412142486445

[:, :, 2, 3] =
 -0.16684343888432468   0.3891320653902699   ‚Ä¶  -0.6760034321761412
  0.1862910664324412   -0.43449012996472464      0.7547998359072154
 -0.44317769964795056   1.0336316174739204      -1.795633367600701
  0.3153935841599191   -0.7355983407898934       1.2778875022245255

[:, :, 3, 3] =
  0.16772017335572711  -0.3911768895555894  ‚Ä¶   0.6795557175745864
 -0.3911768895555894    0.9123491578907353     -1.5849404789055221
  0.24569899270239995  -0.5730483448071415      0.995504309067846
  0.6795557175745864   -1.5849404789055221      2.7533716669184582</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; w‚Ä≤ = m1‚Ä≤ * v‚Ä≤</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚Ñù^4 ‚äó ‚Ñù^4) ‚Üê ProductSpace{CartesianSpace, 0}()):
  4.776451404912116       0.006021716756368367   ‚Ä¶   2.5283661594993236
  0.0060217167563680896   7.591634378800727e-6       0.0031875347571281853
 -2.195216666278272      -0.00276753008930275       -1.162015701882562
  2.5283661594993236      0.0031875347571281853      1.3383650108796576</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; w‚Ä≤ ‚âà w ‚äó w</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Another example involves checking that <code>U</code> from the singular value decomposition is a left isometric tensor</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; codomain(U)</code><code class="nohighlight hljs ansi" style="display:block;">(‚Ñù^3 ‚äó ‚Ñù^4)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(U)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSpace(‚Ñù^2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; space(U)</code><code class="nohighlight hljs ansi" style="display:block;">(‚Ñù^3 ‚äó ‚Ñù^4) ‚Üê ‚Ñù^2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U&#39;*U # should be the identity on the corresponding domain = codomain</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(ProductSpace(‚Ñù^2) ‚Üê ProductSpace(‚Ñù^2)):
 1.0                     1.2267774793543141e-16
 1.2267774793543141e-16  0.9999999999999996</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U&#39;*U ‚âà one(U&#39;*U)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = U*U&#39; # should be a projector</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚Ñù^3 ‚äó ‚Ñù^4) ‚Üê (‚Ñù^3 ‚äó ‚Ñù^4)):
[:, :, 1, 1] =
  0.08705488445800551  -0.07206125880779249  ‚Ä¶   0.0371286498835504
 -0.14714635385348296   0.08991146781747422     -0.11341556621390457
  0.06187032935051123   0.08708756295654231     -0.08365453618548896

[:, :, 2, 1] =
 -0.14714635385348296   0.19494290233026937   ‚Ä¶  -0.11712373568237992
  0.30480622824091663  -0.020123164336760906      0.1930037135745987
 -0.11173583600163775  -0.028835256363467093      0.20369909590056853

[:, :, 3, 1] =
  0.06187032935051123   -0.06054856144794751   ‚Ä¶   0.03332585807909654
 -0.11173583600163775    0.04707331379073778      -0.08077098737851718
  0.044885090569354594   0.046787370377939744     -0.06740458685623933

[:, :, 1, 2] =
 -0.07206125880779249  0.1550240817160826   ‚Ä¶  -0.10162729550192696
  0.19494290233026937  0.09750811459107252      0.09557784872288273
 -0.06054856144794751  0.08226093048761397      0.1504858465711619

[:, :, 2, 2] =
  0.08991146781747422   0.09750811459107252  ‚Ä¶  -0.08945485223103816
 -0.020123164336760906  0.4028127801564422      -0.11407959932973419
  0.04707331379073778   0.3681956565830346       0.06005318731184134

[:, :, 3, 2] =
  0.08708756295654231   0.08226093048761397  ‚Ä¶  -0.07758817622251139
 -0.028835256363467093  0.3681956565830346      -0.1107133139943199
  0.046787370377939744  0.33691234238356027      0.04778818766421731

[:, :, 1, 3] =
  0.07461306334158951  -0.013699796855959307  ‚Ä¶  -0.0039035462114742486
 -0.08925843391039065   0.1637052656535076       -0.09635158934887988
  0.04832398053144572   0.15242335944488153      -0.03075920994890478

[:, :, 2, 3] =
 -0.057722592139489236   0.021089131079250926  ‚Ä¶  -0.0047779917631594095
  0.0770976026274142    -0.1077348450076228        0.07472663396705127
 -0.03841139700679601   -0.10094109230186314       0.032731986599970654

[:, :, 3, 3] =
 -0.054740187844074625  0.15847263475346055  ‚Ä¶  -0.10746087168830255
  0.17930550216366015   0.14746164922915161      0.07332816450984118
 -0.04997914824188099   0.12837321207641494      0.14899171094591096

[:, :, 1, 4] =
  0.0371286498835504   -0.10162729550192696  ‚Ä¶   0.06853167599639365
 -0.11712373568237992  -0.08945485223103816     -0.049632114794371934
  0.03332585807909654  -0.07758817622251139     -0.09606513911355036

[:, :, 2, 4] =
 -0.11341556621390457   0.09557784872288273  ‚Ä¶  -0.049632114794371934
  0.1930037135745987   -0.11407959932973419      0.14778856388757725
 -0.08077098737851718  -0.1107133139943199       0.11043027025024028

[:, :, 3, 4] =
 -0.08365453618548896  0.1504858465711619   ‚Ä¶  -0.09606513911355036
  0.20369909590056853  0.06005318731184134      0.11043027025024028
 -0.06740458685623933  0.04778818766421731      0.1495863373720393</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P*P ‚âà P</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>Here, the adjoint of a <code>TensorMap</code> results in a new tensor map (actually a simple wrapper of type <code>AdjointTensorMap &lt;: AbstractTensorMap</code>) with domain and codomain interchanged.</p><p>Our original tensor <code>A</code> living in <code>‚Ñù^4 * ‚Ñù^2 * ‚Ñù^3</code> is isomorphic to a linear map <code>‚Ñù^3 ‚Üí ‚Ñù^4 * ‚Ñù^2</code>. This is where the full power of <code>permute</code> emerges. It allows to specify a permutation where some indices go to the codomain, and others go to the domain, as</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A2 = permute(A,(1,2),(3,))</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚Ñù^3 ‚äó ‚Ñù^2) ‚Üê ProductSpace(‚Ñù^4)):
[:, :, 1] =
 -0.5507605320092969   -0.919629089885813
  0.13554612347510797   1.7588897080814283
 -0.28991887860263776  -0.6796794431806901

[:, :, 2] =
 -0.5812814772190394   1.0278641526698287
 -2.4385976720929086  -0.4691526857926431
 -2.2294998788983063  -0.48848081402963955

[:, :, 3] =
 -0.9947213409440684  -0.6538344221686033
  0.6554577227993095   0.5351503946975269
 -0.8842899347931931   0.8946110904852927

[:, :, 4] =
  0.5360607393870641  -0.5904062067081328
  0.6990892901001455   1.2028391078467375
 -0.3542212367807085   1.1108183312024404</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; codomain(A2)</code><code class="nohighlight hljs ansi" style="display:block;">(‚Ñù^3 ‚äó ‚Ñù^2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(A2)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSpace(‚Ñù^4)</code></pre><p>In fact, <code>tsvd(A, (1,3),(2,))</code> is a shorthand for <code>tsvd(permute(A,(1,3),(2,)))</code>, where <code>tsvd(A::TensorMap)</code> will just compute the singular value decomposition according to the given codomain and domain of <code>A</code>.</p><p>The <code>@tensor</code> macro treats all indices at the same footing and thus does not distinguish between codomain and domain. The linear numbering is first all indices in the codomain, followed by all indices in the domain. However, when <code>@tensor</code> creates a new tensor (using <code>:=</code>), the default syntax creates a <code>Tensor</code>, i.e. with all indices in the codomain.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @tensor A‚Ä≤[a,b,c] := U[a,c,d]*S[d,e]*Vd[e,b];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; codomain(A‚Ä≤)</code><code class="nohighlight hljs ansi" style="display:block;">(‚Ñù^3 ‚äó ‚Ñù^2 ‚äó ‚Ñù^4)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(A‚Ä≤)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSpace{CartesianSpace, 0}()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @tensor A2‚Ä≤[(a,b);(c,)] := U[a,c,d]*S[d,e]*Vd[e,b];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; codomain(A2‚Ä≤)</code><code class="nohighlight hljs ansi" style="display:block;">(‚Ñù^3 ‚äó ‚Ñù^2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; domain(A2‚Ä≤)</code><code class="nohighlight hljs ansi" style="display:block;">ProductSpace(‚Ñù^4)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @tensor A2‚Ä≤‚Ä≤[a b; c] := U[a,c,d]*S[d,e]*Vd[e,b];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A2 ‚âà A2‚Ä≤ == A2‚Ä≤‚Ä≤</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>As illustrated for <code>A2‚Ä≤</code> and <code>A2‚Ä≤‚Ä≤</code>, additional syntax is available that enables one to immediately specify the desired codomain and domain indices.</p><h2 id="Complex-tensors"><a class="docs-heading-anchor" href="#Complex-tensors">Complex tensors</a><a id="Complex-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-tensors" title="Permalink"></a></h2><p>To create a complex tensor, we work with complex vector spaces</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = Tensor(randn, ComplexF64, ‚ÑÇ^3 ‚äó ‚ÑÇ^2 ‚äó ‚ÑÇ^4)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚ÑÇ^3 ‚äó ‚ÑÇ^2 ‚äó ‚ÑÇ^4) ‚Üê ProductSpace{ComplexSpace, 0}()):
[:, :, 1] =
 -0.26003055934888025 - 0.42338613181213464im  ‚Ä¶   -0.4467744982058867 - 0.6186422686658988im
  -0.7666950866112917 - 2.1715297724894738im      -0.27893889740414907 + 0.6780246129300481im
 -0.29719175078617455 + 0.13083266482148792im       0.4843014825425582 + 0.7305793958042782im

[:, :, 2] =
  -0.5878658484816165 - 0.9537168860667642im   ‚Ä¶   0.5969240032604766 - 0.00483001323445098im
 -0.09468261663028991 - 0.38784015524476845im      1.3246186521339254 + 0.8420823595989222im
  0.01413938962094997 - 0.24602071743623696im     -0.6929704277230689 + 0.40447484471533457im

[:, :, 3] =
 0.45725427426307264 - 0.6997553505924163im  ‚Ä¶  -0.7691127573231513 - 0.0456184031352536im
  0.2786781283620502 + 0.2829018967427671im      0.2037121192718347 - 0.12130982071172647im
 0.09778358558161745 - 0.2489282416508323im       0.623480023788256 + 0.9446469192629317im

[:, :, 4] =
  0.2893583769622802 + 0.5824978967156309im   ‚Ä¶   -0.458151477714238 - 0.6604578605565155im
  1.0229904419414517 + 0.14438653031928972im      1.1841599823813618 + 0.5597452596816652im
 -0.8635567815871915 + 0.02655746503828266im     0.04515964938774197 + 0.06950586776398489im</code></pre><p>where <code>‚ÑÇ</code> is obtained as <code>\bbC+TAB</code> and we also have the non-Unicode alternative <code>‚ÑÇ^n == ComplexSpace(n)</code>. Most functionality works exactly the same with real tensors</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = Tensor(randn, ‚ÑÇ^3 * ‚ÑÇ^2 * ‚ÑÇ^4);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; C = im*A + (2.5-0.8im)*B</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚ÑÇ^3 ‚äó ‚ÑÇ^2 ‚äó ‚ÑÇ^4) ‚Üê ProductSpace{ComplexSpace, 0}()):
[:, :, 1] =
  1.002649940163997 - 0.4453949780214762im   ‚Ä¶  -0.8631976746389332 + 0.027414283651659488im
  -1.09056826163497 + 0.27717628430853025im      1.5403646094725683 - 0.9888234485729865im
 3.7205427192739933 - 1.5296318736967287im        -5.76958433203211 + 2.0967830621354646im

[:, :, 2] =
 2.3919821310330436 - 1.048110726870826im     ‚Ä¶   1.7559612477949291 + 0.03656200820112354im
 -1.716895525169377 + 0.5788328011022366im        0.6065805496153227 + 0.861046521185367im
 0.3478327093495707 - 0.018440447791316834im     -4.2432950600208414 + 0.5354520411746934im

[:, :, 3] =
 -0.6837860304624581 + 0.8999875162006324im   ‚Ä¶   3.3416074365887822 - 1.8238292480282805im
 -2.1128109780665523 + 0.8642490343856615im      -0.9497959837768146 + 0.5464659767081679im
  1.8441074095183878 - 0.41267374813600033im     -2.3886472725322667 + 1.0855601368344432im

[:, :, 4] =
  1.6742886077895858 - 0.43281330447938926im  ‚Ä¶    4.041574517309087 - 1.5401088078750609im
  3.7597064886327414 - 0.22631932412319844im     -0.4364372063627339 + 1.1447014053193039im
 -0.3717434222210583 - 0.7530972752887033im       -5.266215565755622 + 1.708106752745066im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; scalarBA = dot(B,A)</code><code class="nohighlight hljs ansi" style="display:block;">0.9821695901842169 + 1.2691343790642904im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; scalarAA = dot(A,A)</code><code class="nohighlight hljs ansi" style="display:block;">19.947187006846846 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; normA¬≤ = norm(A)^2</code><code class="nohighlight hljs ansi" style="display:block;">19.947187006846846</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U,S,Vd = tsvd(A,(1,3),(2,));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @tensor A‚Ä≤[a,b,c] := U[a,c,d]*S[d,e]*Vd[e,b];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A‚Ä≤ ‚âà A</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; permute(A,(1,3),(2,)) ‚âà U*S*Vd</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>However, trying the following</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @tensor D[a,b,c,d] := A[a,b,e]*B[d,c,e]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @tensor d = A[a,b,c]*A[a,b,c]</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch()</code></pre><p>we obtain <code>SpaceMismatch</code> errors. The reason for this is that, with <code>ComplexSpace</code>, an index in a space <code>‚ÑÇ^n</code> can only be contracted with an index in the dual space <code>dual(‚ÑÇ^n) == (‚ÑÇ^n)&#39;</code>. Because of the complex Euclidean inner product, the dual space is equivalent to the complex conjugate space, but not the the space itself.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(‚ÑÇ^3) == conj(‚ÑÇ^3) == (‚ÑÇ^3)&#39;</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚ÑÇ^3)&#39; == ‚ÑÇ^3</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @tensor d = conj(A[a,b,c])*A[a,b,c]</code><code class="nohighlight hljs ansi" style="display:block;">19.947187006846843 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d ‚âà normA¬≤</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>This might seem overly strict or puristic, but we believe that it can help to catch errors, e.g. unintended contractions. In particular, contracting two indices both living in <code>‚ÑÇ^n</code> would represent an operation that is not invariant under arbitrary unitary basis changes.</p><p>It also makes clear the isomorphism between linear maps <code>‚ÑÇ^n ‚Üí ‚ÑÇ^m</code> and tensors in <code>‚ÑÇ^m ‚äó (‚ÑÇ^n)&#39;</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; m = TensorMap(randn, ComplexF64, ‚ÑÇ^3, ‚ÑÇ^4)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(ProductSpace(‚ÑÇ^3) ‚Üê ProductSpace(‚ÑÇ^4)):
 -0.5238012061443754 + 0.5096780965016849im   ‚Ä¶  -0.28568453608062366 + 0.05620432640134694im
   0.433356986959504 + 0.31462606878044463im      -0.9211212320778002 + 0.5309644484241678im
 -0.1409230564218193 + 0.7134398671178557im         1.443374690573585 + 0.832106852755087im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; m2 = permute(m, (1,2), ())</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;) ‚Üê ProductSpace{ComplexSpace, 0}()):
 -0.5238012061443754 + 0.5096780965016849im   ‚Ä¶  -0.28568453608062366 + 0.05620432640134694im
   0.433356986959504 + 0.31462606878044463im      -0.9211212320778002 + 0.5309644484241678im
 -0.1409230564218193 + 0.7134398671178557im         1.443374690573585 + 0.832106852755087im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; codomain(m2)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; space(m, 1)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; space(m, 2)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^4)&#39;</code></pre><p>Hence, spaces become their corresponding dual space if they are &#39;permuted&#39; from the domain to the codomain or vice versa. Also, spaces in the domain are reported as their dual when probing them with <code>space(A, i)</code>. Generalizing matrix vector and matrix matrix multiplication to arbitrary tensor contractions require that the two indices to be contracted have spaces which are each others dual. Knowing this, all the other functionality of tensors with <code>CartesianSpace</code> indices remains the same for tensors with <code>ComplexSpace</code> indices.</p><h2 id="Symmetries"><a class="docs-heading-anchor" href="#Symmetries">Symmetries</a><a id="Symmetries-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetries" title="Permalink"></a></h2><p>So far, the functionality that we have illustrated seems to be just a wrapper around dense multidimensional arrays, e.g. Julia&#39;s Base <code>Array</code>. More power becomes visible when involving symmetries. With symmetries, we imply that there is some symmetry action defined on every vector space associated with each of the indices of a <code>TensorMap</code>, and the <code>TensorMap</code> is then required to be equivariant, i.e. it acts as an intertwiner between the tensor product representation on the domain and that on the codomain. By Schur&#39;s lemma, this means that the tensor is block diagonal in some basis corresponding to the irreducible representations that can be coupled to by combining the different representations on the different spaces in the domain or codomain. For Abelian symmetries, this does not require a basis change and it just imposes that the tensor has some block sparsity. Let&#39;s clarify all of this with some examples.</p><p>We start with a simple <span>$‚Ñ§‚ÇÇ$</span> symmetry:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = ‚Ñ§‚ÇÇSpace(0=&gt;3,1=&gt;2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1)</code><code class="nohighlight hljs ansi" style="display:block;">5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = ‚Ñ§‚ÇÇSpace(0=&gt;1,1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[‚Ñ§‚ÇÇ](0=&gt;1, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V2)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = Tensor(randn, V1*V1*V2&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2) ‚äó Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2) ‚äó Rep[‚Ñ§‚ÇÇ](0=&gt;1, 1=&gt;1)&#39;) ‚Üê ProductSpace{GradedSpace{ZNIrrep{2},Tuple{Int64,Int64}}, 0}()):
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](0)) ‚Üê ():
[:, :, 1] =
 0.7406902635069376  -0.9187848503597226
 0.6848773381313454   0.6921837992666654
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](1)) ‚Üê ():
[:, :, 1] =
 -1.4730919675411631   1.3981204839687933
 -0.16397685872277837  0.2921422851047478
  1.3362429597698047   0.7961073375395328
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](0)) ‚Üê ():
[:, :, 1] =
  0.08408682538414247  -0.24300230228753536  0.5466833538173322
 -0.07270748668311595  -0.42807715637372673  0.24213333419740227
  0.6964751240109035    0.7645776570326063   0.47375075127718647
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](1)) ‚Üê ():
[:, :, 1] =
 -1.0768307050907477   -1.1914172998681325   0.3131667084166762
 -0.10190419636604671  -0.7363148610816725  -1.930030055629099</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, A)</code><code class="nohighlight hljs ansi" style="display:block;">5√ó5√ó2 Array{Float64,3}:
[:, :, 1] =
  0.0840868  -0.243002  0.546683  0.0        0.0
 -0.0727075  -0.428077  0.242133  0.0        0.0
  0.696475    0.764578  0.473751  0.0        0.0
  0.0         0.0       0.0       0.74069   -0.918785
  0.0         0.0       0.0       0.684877   0.692184

[:, :, 2] =
  0.0        0.0        0.0       -1.47309   1.39812
  0.0        0.0        0.0       -0.163977  0.292142
  0.0        0.0        0.0        1.33624   0.796107
 -1.07683   -1.19142    0.313167   0.0       0.0
 -0.101904  -0.736315  -1.93003    0.0       0.0</code></pre><p>Here, we create a space 5-dimensional space <code>V1</code>, which has a three-dimensional subspace associated with charge 0 (the trivial irrep of <span>$‚Ñ§‚ÇÇ$</span>) and a two-dimensional subspace with charge 1 (the non-trivial irrep). Similar for <code>V2</code>, where both subspaces are one- dimensional. Representing the tensor as a dense <code>Array</code>, we see that it is zero in those regions where the charges don&#39;t add to zero (modulo 2). The <code>Tensor(Map)</code> type in TensorLabXD.jl won&#39;t store these zero blocks, and only stores the non-zero information, which we can recognize in the full <code>Array</code> representation.</p><p>From there on, the resulting tensors support all of the same operations as the ones we encountered in the previous examples.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = Tensor(randn, V1&#39;*V1*V2);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @tensor C[a,b] := A[a,c,d]*B[c,b,d]</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2) ‚äó Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2)) ‚Üê ProductSpace{GradedSpace{ZNIrrep{2},Tuple{Int64,Int64}}, 0}()):
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](1)) ‚Üê ():
 -2.141596185503181   3.2525251631368013
  1.1775787647508302  1.5622422366599773
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](0)) ‚Üê ():
 -2.4317923406602957  -1.7999586904642277   0.48350271240861187
 -0.3598503900550038  -0.3787601511728721   0.011411965405304704
  2.2577081489172     -0.9639726888203399  -0.23823209741880547</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U,S,V = tsvd(A,(1,3),(2,));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U&#39;*U # should be the identity on the corresponding domain = codomain</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap(ProductSpace(Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2)&#39;) ‚Üê ProductSpace(Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2)&#39;)):
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0),) ‚Üê (Irrep[‚Ñ§‚ÇÇ](0),):
  1.0000000000000002      -2.0548429047470864e-17  -1.837085638734275e-16
 -2.0548429047470864e-17   1.0000000000000002      -3.3359400853035138e-16
 -1.837085638734275e-16   -3.3359400853035138e-16   1.0000000000000009
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1),) ‚Üê (Irrep[‚Ñ§‚ÇÇ](1),):
  1.0                     -1.2751381777441348e-16
 -1.2751381777441348e-16   1.0000000000000004</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U&#39;*U ‚âà one(U&#39;*U)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P = U*U&#39; # should be a projector</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2) ‚äó Rep[‚Ñ§‚ÇÇ](0=&gt;1, 1=&gt;1)&#39;) ‚Üê (Rep[‚Ñ§‚ÇÇ](0=&gt;3, 1=&gt;2) ‚äó Rep[‚Ñ§‚ÇÇ](0=&gt;1, 1=&gt;1)&#39;)):
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](0)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](0)):
[:, :, 1, 1] =
 0.5507833645711075
 0.4509062575291877
 0.1995186788369389

[:, :, 2, 1] =
 0.4509062575291877
 0.39101412693892473
 0.09520072636138947

[:, :, 3, 1] =
 0.1995186788369389
 0.09520072636138947
 0.3531260868602445
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](1)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](0)):
[:, :, 1, 1] =
  0.0645835592954493
 -0.011218621472976207

[:, :, 2, 1] =
 0.12885634408378155
 0.0955954532588412

[:, :, 3, 1] =
 -0.3946272461126371
 -0.15435837767998883
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](0)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](1)):
[:, :, 1, 1] =
  0.0645835592954493
  0.12885634408378155
 -0.3946272461126371

[:, :, 2, 1] =
 -0.011218621472976207
  0.0955954532588412
 -0.15435837767998883
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](1)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](1)):
[:, :, 1, 1] =
  0.7508366110979521
 -0.10283646054072586

[:, :, 2, 1] =
 -0.10283646054072586
  0.9542398105317723
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](0)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](0)):
[:, :, 1, 1] =
  0.25577916113174254
 -0.0704508773742349

[:, :, 2, 1] =
 -0.0704508773742349
  0.2961363181226204
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](1)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](0)):
[:, :, 1, 1] =
 -0.42324966591230523
 -0.07429295882334593
 -0.02707641619712329

[:, :, 2, 1] =
 0.03954551780671069
 0.03639090574288801
 0.44787065888402483
* Data for sector (Irrep[‚Ñ§‚ÇÇ](1), Irrep[‚Ñ§‚ÇÇ](0)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](1)):
[:, :, 1, 1] =
 -0.42324966591230523
  0.03954551780671069

[:, :, 2, 1] =
 -0.07429295882334593
  0.03639090574288801

[:, :, 3, 1] =
 -0.02707641619712329
  0.44787065888402483
* Data for sector (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](1)) ‚Üê (Irrep[‚Ñ§‚ÇÇ](0), Irrep[‚Ñ§‚ÇÇ](1)):
[:, :, 1, 1] =
  0.7218142568827821
  0.11850221010383083
 -0.07779160604183447

[:, :, 2, 1] =
 0.11850221010383083
 0.022495710627530877
 0.03321352254557894

[:, :, 3, 1] =
 -0.07779160604183447
  0.03321352254557894
  0.7037745532353246</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; P*P ‚âà P</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>We also support other abelian symmetries, e.g.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V = U‚ÇÅSpace(0=&gt;2,1=&gt;1,-1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U‚ÇÅ](0=&gt;2, 1=&gt;1, -1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = TensorMap(randn, V*V, V)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((Rep[U‚ÇÅ](0=&gt;2, 1=&gt;1, -1=&gt;1) ‚äó Rep[U‚ÇÅ](0=&gt;2, 1=&gt;1, -1=&gt;1)) ‚Üê ProductSpace(Rep[U‚ÇÅ](0=&gt;2, 1=&gt;1, -1=&gt;1))):
* Data for sector (Irrep[U‚ÇÅ](1), Irrep[U‚ÇÅ](-1)) ‚Üê (Irrep[U‚ÇÅ](0),):
[:, :, 1] =
 1.04794795297725

[:, :, 2] =
 2.6838290951253736
* Data for sector (Irrep[U‚ÇÅ](-1), Irrep[U‚ÇÅ](1)) ‚Üê (Irrep[U‚ÇÅ](0),):
[:, :, 1] =
 0.19718348666944527

[:, :, 2] =
 -1.0083103152617656
* Data for sector (Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](0)) ‚Üê (Irrep[U‚ÇÅ](0),):
[:, :, 1] =
 -2.1279400826486294  -0.11726206196642641
  0.2957712643181228  -0.42695270586043765

[:, :, 2] =
 -0.8574220341406061  -0.07026403924674833
  1.1376020671533609   0.5046289860695301
* Data for sector (Irrep[U‚ÇÅ](1), Irrep[U‚ÇÅ](0)) ‚Üê (Irrep[U‚ÇÅ](1),):
[:, :, 1] =
 -0.6176868733426516  1.0025536089154898
* Data for sector (Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](1)) ‚Üê (Irrep[U‚ÇÅ](1),):
[:, :, 1] =
 1.2835767753331855
 0.042313008874023644
* Data for sector (Irrep[U‚ÇÅ](-1), Irrep[U‚ÇÅ](0)) ‚Üê (Irrep[U‚ÇÅ](-1),):
[:, :, 1] =
 2.74859199229957  0.009532975501066918
* Data for sector (Irrep[U‚ÇÅ](0), Irrep[U‚ÇÅ](-1)) ‚Üê (Irrep[U‚ÇÅ](-1),):
[:, :, 1] =
 -0.42905045428263
  0.8100546752238597</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(A)</code><code class="nohighlight hljs ansi" style="display:block;">20</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, A)</code><code class="nohighlight hljs ansi" style="display:block;">4√ó4√ó4 Array{Float64,3}:
[:, :, 1] =
 -2.12794   -0.117262  0.0       0.0
  0.295771  -0.426953  0.0       0.0
  0.0        0.0       0.0       1.04795
  0.0        0.0       0.197183  0.0

[:, :, 2] =
 -0.857422  -0.070264   0.0      0.0
  1.1376     0.504629   0.0      0.0
  0.0        0.0        0.0      2.68383
  0.0        0.0       -1.00831  0.0

[:, :, 3] =
  0.0       0.0      1.28358   0.0
  0.0       0.0      0.042313  0.0
 -0.617687  1.00255  0.0       0.0
  0.0       0.0      0.0       0.0

[:, :, 4] =
 0.0      0.0         0.0  -0.42905
 0.0      0.0         0.0   0.810055
 0.0      0.0         0.0   0.0
 2.74859  0.00953298  0.0   0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V = Rep[U‚ÇÅ √ó ‚Ñ§‚ÇÇ]((0, 0)=&gt;2, (-1, 0)=&gt;1, (1, 1)=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U‚ÇÅ √ó ‚Ñ§‚ÇÇ]((0, 0)=&gt;2, (-1, 0)=&gt;1, (1, 1)=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = TensorMap(randn, V*V, V)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((Rep[U‚ÇÅ √ó ‚Ñ§‚ÇÇ]((0, 0)=&gt;2, (-1, 0)=&gt;1, (1, 1)=&gt;1) ‚äó Rep[U‚ÇÅ √ó ‚Ñ§‚ÇÇ]((0, 0)=&gt;2, (-1, 0)=&gt;1, (1, 1)=&gt;1)) ‚Üê ProductSpace(Rep[U‚ÇÅ √ó ‚Ñ§‚ÇÇ]((0, 0)=&gt;2, (-1, 0)=&gt;1, (1, 1)=&gt;1))):
* Data for sector ((Irrep[U‚ÇÅ](0) ‚ä† Irrep[‚Ñ§‚ÇÇ](0)), (Irrep[U‚ÇÅ](0) ‚ä† Irrep[‚Ñ§‚ÇÇ](0))) ‚Üê ((Irrep[U‚ÇÅ](0) ‚ä† Irrep[‚Ñ§‚ÇÇ](0)),):
[:, :, 1] =
 -0.7340897609055997  -0.3081334560602026
 -2.7452063718191595  -0.6472883347988282

[:, :, 2] =
 -0.6225707901893847  -0.9515830001293747
 -1.5606983501885887  -1.599255668307514
* Data for sector ((Irrep[U‚ÇÅ](-1) ‚ä† Irrep[‚Ñ§‚ÇÇ](0)), (Irrep[U‚ÇÅ](0) ‚ä† Irrep[‚Ñ§‚ÇÇ](0))) ‚Üê ((Irrep[U‚ÇÅ](-1) ‚ä† Irrep[‚Ñ§‚ÇÇ](0)),):
[:, :, 1] =
 -1.04904070196412  0.5985811028133334
* Data for sector ((Irrep[U‚ÇÅ](0) ‚ä† Irrep[‚Ñ§‚ÇÇ](0)), (Irrep[U‚ÇÅ](-1) ‚ä† Irrep[‚Ñ§‚ÇÇ](0))) ‚Üê ((Irrep[U‚ÇÅ](-1) ‚ä† Irrep[‚Ñ§‚ÇÇ](0)),):
[:, :, 1] =
 -0.13650965122738407
  1.3417292553567897
* Data for sector ((Irrep[U‚ÇÅ](1) ‚ä† Irrep[‚Ñ§‚ÇÇ](1)), (Irrep[U‚ÇÅ](0) ‚ä† Irrep[‚Ñ§‚ÇÇ](0))) ‚Üê ((Irrep[U‚ÇÅ](1) ‚ä† Irrep[‚Ñ§‚ÇÇ](1)),):
[:, :, 1] =
 -1.406684198100678  0.7521069662899377
* Data for sector ((Irrep[U‚ÇÅ](0) ‚ä† Irrep[‚Ñ§‚ÇÇ](0)), (Irrep[U‚ÇÅ](1) ‚ä† Irrep[‚Ñ§‚ÇÇ](1))) ‚Üê ((Irrep[U‚ÇÅ](1) ‚ä† Irrep[‚Ñ§‚ÇÇ](1)),):
[:, :, 1] =
  2.15904409519481
 -1.646722256353278</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(A)</code><code class="nohighlight hljs ansi" style="display:block;">16</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, A)</code><code class="nohighlight hljs ansi" style="display:block;">4√ó4√ó4 Array{Float64,3}:
[:, :, 1] =
 -0.73409  -0.308133  0.0  0.0
 -2.74521  -0.647288  0.0  0.0
  0.0       0.0       0.0  0.0
  0.0       0.0       0.0  0.0

[:, :, 2] =
 -0.622571  -0.951583  0.0  0.0
 -1.5607    -1.59926   0.0  0.0
  0.0        0.0       0.0  0.0
  0.0        0.0       0.0  0.0

[:, :, 3] =
  0.0      0.0       -0.13651  0.0
  0.0      0.0        1.34173  0.0
 -1.04904  0.598581   0.0      0.0
  0.0      0.0        0.0      0.0

[:, :, 4] =
  0.0      0.0       0.0   2.15904
  0.0      0.0       0.0  -1.64672
  0.0      0.0       0.0   0.0
 -1.40668  0.752107  0.0   0.0</code></pre><p>Here, the <code>dim</code> of a <code>TensorMap</code> returns the number of linearly independent components, i.e. the number of non-zero entries in the case of an abelian symmetry. Note that we can use <code>√ó</code> (obtained as <code>\times+TAB</code>) to combine different symmetries.</p><p>The general space associated with symmetries is a <code>GradedSpace</code>. The concrete type of <code>GradedSpace</code> can be obtained as <code>Vect[I]</code>, or if <code>I == Irrep[G]</code> for some <code>G&lt;:Group</code>, as <code>Rep[G]</code>. The <code>‚Ñ§‚ÇÇSpace</code> (or <code>Z2Space</code>) and <code>U‚ÇÅSpace</code> (or <code>U1Space</code>) are just convenient synonyms, e.g.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rep[U‚ÇÅ](0=&gt;3,1=&gt;2,-1=&gt;1) == U1Space(-1=&gt;1,1=&gt;2,0=&gt;3)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V = U‚ÇÅSpace(1=&gt;2,0=&gt;3,-1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U‚ÇÅ](0=&gt;3, 1=&gt;2, -1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for s in sectors(V)
         @show s, dim(V, s)
       end</code><code class="nohighlight hljs ansi" style="display:block;">(s, dim(V, s)) = (Irrep[U‚ÇÅ](0), 3)
(s, dim(V, s)) = (Irrep[U‚ÇÅ](1), 2)
(s, dim(V, s)) = (Irrep[U‚ÇÅ](-1), 1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U‚ÇÅSpace(-1=&gt;1,0=&gt;3,1=&gt;2) == GradedSpace(Irrep[U‚ÇÅ](1)=&gt;2, Irrep[U‚ÇÅ](0)=&gt;3, Irrep[U‚ÇÅ](-1)=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supertype(GradedSpace)</code><code class="nohighlight hljs ansi" style="display:block;">EuclideanSpace{‚ÑÇ}</code></pre><p>Generally, <code>GradedSpace</code> supports a grading that is derived from the fusion ring of a (unitary) pre-fusion category. The order in which the charges and their corresponding subspace dimensionality are specified is irrelevant. We can probe the subspace dimension of a certain sector <code>s</code> in a space <code>V</code> with <code>dim(V, s)</code>.</p><p>The <code>GradedSpace</code> is a subtype of <code>EuclideanSpace{‚ÑÇ}</code>, i.e., it has the standard Euclidean inner product and we assume all representations to be unitary.</p><p>TensorLabXD.jl also allows for non-abelian symmetries such as <code>SU‚ÇÇ</code>. In this case, the vector space is characterized via the spin quantum number (i.e. the irrep label of <code>SU‚ÇÇ</code>) for each of its subspaces, and is created using <code>SU‚ÇÇSpace</code> (or <code>SU2Space</code> or <code>Rep[SU‚ÇÇ]</code>)</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V = SU‚ÇÇSpace(0=&gt;2,1/2=&gt;1,1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V)</code><code class="nohighlight hljs ansi" style="display:block;">7</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V == Rep[SU‚ÇÇ](0=&gt;2, 1=&gt;1, 1//2=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p><code>V</code> has a two-dimensional subspace with spin zero, and two one-dimensional subspaces with spin 1/2 and spin 1. A subspace with spin <code>j</code> has an additional <code>2j+1</code> dimensional degeneracy on which the irreducible representation acts. This brings the total dimension to <code>2*1 + 1*2 + 1*3</code>. Creating a tensor with <code>SU‚ÇÇ</code> symmetry yields</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = TensorMap(randn, V*V, V)</code><code class="nohighlight hljs ansi" style="display:block;">TensorMap((Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1, 1=&gt;1) ‚äó Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1, 1=&gt;1)) ‚Üê ProductSpace(Rep[SU‚ÇÇ](0=&gt;2, 1/2=&gt;1, 1=&gt;1))):
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2), 0, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0,), 0, (false,), ()):
[:, :, 1] =
 -1.23057205393469

[:, :, 2] =
 0.1788300639830282
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 0, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0,), 0, (false,), ()):
[:, :, 1] =
 -0.5170056425029936

[:, :, 2] =
 0.8857294968610061
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 0), 0, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((0,), 0, (false,), ()):
[:, :, 1] =
 0.271861454469082   -0.7261023892185442
 0.6644609048527416   0.09446452139605914

[:, :, 2] =
  2.4516866832175683  1.162135139270764
 -1.5719365810686357  0.23222518944095114
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1/2, 0), 1/2, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1/2,), 1/2, (false,), ()):
[:, :, 1] =
 1.3917401171134502  -0.8251258161820079
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1), 1/2, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1/2,), 1/2, (false,), ()):
[:, :, 1] =
 -0.3751857094019641
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 1/2), 1/2, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1/2,), 1/2, (false,), ()):
[:, :, 1] =
 -0.13347120315775537
  0.35770267616640056
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1/2), 1/2, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1/2,), 1/2, (false,), ()):
[:, :, 1] =
 0.2581542902097891
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 0), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1,), 1, (false,), ()):
[:, :, 1] =
 -0.7343887958395467  -0.6880344304024922
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((0, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1,), 1, (false,), ()):
[:, :, 1] =
 -0.47211600631856776
  1.0144555607571977
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1, 1), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1,), 1, (false,), ()):
[:, :, 1] =
 -0.34926790186062173
* Data for fusiontree FusionTree{Irrep[SU‚ÇÇ]}((1/2, 1/2), 1, (false, false), ()) ‚Üê FusionTree{Irrep[SU‚ÇÇ]}((1,), 1, (false,), ()):
[:, :, 1] =
 -1.6635356624947994</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(A)</code><code class="nohighlight hljs ansi" style="display:block;">24</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, A)</code><code class="nohighlight hljs ansi" style="display:block;">7√ó7√ó7 Array{Float64,3}:
[:, :, 1] =
 0.271861  -0.726102   0.0        0.0        0.0       0.0        0.0
 0.664461   0.0944645  0.0        0.0        0.0       0.0        0.0
 0.0        0.0        0.0       -0.870146   0.0       0.0        0.0
 0.0        0.0        0.870146   0.0        0.0       0.0        0.0
 0.0        0.0        0.0        0.0        0.0       0.0       -0.298493
 0.0        0.0        0.0        0.0        0.0       0.298493   0.0
 0.0        0.0        0.0        0.0       -0.298493  0.0        0.0

[:, :, 2] =
  2.45169  1.16214    0.0       0.0       0.0        0.0       0.0
 -1.57194  0.232225   0.0       0.0       0.0        0.0       0.0
  0.0      0.0        0.0       0.126452  0.0        0.0       0.0
  0.0      0.0       -0.126452  0.0       0.0        0.0       0.0
  0.0      0.0        0.0       0.0       0.0        0.0       0.511376
  0.0      0.0        0.0       0.0       0.0       -0.511376  0.0
  0.0      0.0        0.0       0.0       0.511376   0.0       0.0

[:, :, 3] =
 0.0       0.0       -0.133471  0.0       0.0        0.0       0.0
 0.0       0.0        0.357703  0.0       0.0        0.0       0.0
 1.39174  -0.825126   0.0       0.0       0.0       -0.216614  0.0
 0.0       0.0        0.0       0.0       0.306338   0.0       0.0
 0.0       0.0        0.0       0.210782  0.0        0.0       0.0
 0.0       0.0       -0.149045  0.0       0.0        0.0       0.0
 0.0       0.0        0.0       0.0       0.0        0.0       0.0

[:, :, 4] =
 0.0       0.0        0.0       -0.133471  0.0  0.0        0.0
 0.0       0.0        0.0        0.357703  0.0  0.0        0.0
 0.0       0.0        0.0        0.0       0.0  0.0       -0.306338
 1.39174  -0.825126   0.0        0.0       0.0  0.216614   0.0
 0.0       0.0        0.0        0.0       0.0  0.0        0.0
 0.0       0.0        0.0        0.149045  0.0  0.0        0.0
 0.0       0.0       -0.210782   0.0       0.0  0.0        0.0

[:, :, 5] =
  0.0        0.0        0.0      0.0  -0.472116   0.0      0.0
  0.0        0.0        0.0      0.0   1.01446    0.0      0.0
  0.0        0.0       -1.66354  0.0   0.0        0.0      0.0
  0.0        0.0        0.0      0.0   0.0        0.0      0.0
 -0.734389  -0.688034   0.0      0.0   0.0       -0.24697  0.0
  0.0        0.0        0.0      0.0   0.24697    0.0      0.0
  0.0        0.0        0.0      0.0   0.0        0.0      0.0

[:, :, 6] =
  0.0        0.0        0.0      0.0     0.0      -0.472116   0.0
  0.0        0.0        0.0      0.0     0.0       1.01446    0.0
  0.0        0.0        0.0     -1.1763  0.0       0.0        0.0
  0.0        0.0       -1.1763   0.0     0.0       0.0        0.0
  0.0        0.0        0.0      0.0     0.0       0.0       -0.24697
 -0.734389  -0.688034   0.0      0.0     0.0       0.0        0.0
  0.0        0.0        0.0      0.0     0.24697   0.0        0.0

[:, :, 7] =
  0.0        0.0       0.0   0.0      0.0  0.0      -0.472116
  0.0        0.0       0.0   0.0      0.0  0.0       1.01446
  0.0        0.0       0.0   0.0      0.0  0.0       0.0
  0.0        0.0       0.0  -1.66354  0.0  0.0       0.0
  0.0        0.0       0.0   0.0      0.0  0.0       0.0
  0.0        0.0       0.0   0.0      0.0  0.0      -0.24697
 -0.734389  -0.688034  0.0   0.0      0.0  0.24697   0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; norm(A) ‚âà norm(convert(Array, A))</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>In this case, the full <code>Array</code> representation of the tensor has again many zeros, but it is less obvious to recognize the dense blocks, as there are additional zeros and the numbers in the original tensor data do not match with those in the <code>Array</code>. The reason is of course that the original tensor data now needs to be transformed with a construction known as fusion trees, which are made up out of the Clebsch-Gordan coefficients of the group. Indeed, note that the non-zero blocks are also no longer labeled by a list of sectors, but by pair of fusion trees. This will be explained further in the manual. However, the Clebsch-Gordan coefficients of the group are only needed to actually convert a tensor to an <code>Array</code>. For working with tensors with <code>SU‚ÇÇSpace</code> indices, e.g. contracting or factorizing them, the Clebsch-Gordan coefficients are never needed explicitly. Instead, recoupling relations are used to symbolically manipulate the basis of fusion trees, and this only requires what is known as the topological data of the group (or its representation theory).</p><p>In fact, this formalism extends beyond the case of group representations on vector spaces, and can also deal with super vector spaces (to describe fermions) and more general (unitary) fusion categories. Preliminary support for these generalizations is present in TensorLabXD.jl and will be extended in the near future.</p><p>All of these concepts will be explained throughout the remainder of this manual, including several details regarding their implementation. However, to just use tensors and their manipulations (contractions, factorizations, ...) in higher level algorithms (e.g. tensoer network algorithms), one does not need to know or understand most of these details, and one can immediately refer to the general interface of the <code>TensorMap</code> type, discussed on the <a href="../tensors/#s_tensors">last page</a>. Adhering to this interface should yield code and algorithms that are oblivious to the underlying symmetries and can thus work with arbitrary symmetric tensors.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">¬´ Introduction</a><a class="docs-footer-nextpage" href="../categories/">Optional introduction to category theory ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 14 November 2021 00:42">Sunday 14 November 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
