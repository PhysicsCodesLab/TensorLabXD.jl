<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sectors, representation spaces and fusion trees · TensorLabXD.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorLabXD.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../categories/">Optional introduction to category theory</a></li><li><a class="tocitem" href="../spaces/">Vector spaces</a></li><li class="is-active"><a class="tocitem" href>Sectors, representation spaces and fusion trees</a><ul class="internal"><li><a class="tocitem" href="#ss_general"><span>General arguments</span></a></li><li><a class="tocitem" href="#ss_representationtheory"><span>Representation theory and unitary fusion categories</span></a></li><li><a class="tocitem" href="#ss_sectors"><span>Sectors</span></a></li><li><a class="tocitem" href="#ss_rep"><span>Graded spaces</span></a></li><li><a class="tocitem" href="#ss_fusiontrees"><span>Fusion trees</span></a></li><li><a class="tocitem" href="#Fermions"><span>Fermions</span></a></li><li><a class="tocitem" href="#Anyons"><span>Anyons</span></a></li></ul></li><li><a class="tocitem" href="../tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Sectors, representation spaces and fusion trees</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sectors, representation spaces and fusion trees</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PhysicsCodesLab/TensorLabXD.jl/blob/master/docs/src/man/sectors.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="s_sectorsrepfusion"><a class="docs-heading-anchor" href="#s_sectorsrepfusion">Sectors, representation spaces and fusion trees</a><a id="s_sectorsrepfusion-1"></a><a class="docs-heading-anchor-permalink" href="#s_sectorsrepfusion" title="Permalink"></a></h1><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><pre><code class="language-julia hljs"># General Sector
abstract type Sector end
struct SectorValues{I&lt;:Sector} end  # Singleton type to represent an iterator over the possible values of type `I`, whose instance is obtained as `values(I)`.
const SectorDict{K, V} = SortedVectorDict{K, V}

abstract type FusionStyle end
struct UniqueFusion &lt;: FusionStyle end # unique fusion output when fusion two sectors
abstract type MultipleFusion &lt;: FusionStyle end
struct SimpleFusion &lt;: MultipleFusion end # multiple fusion but multiplicity free
struct GenericFusion &lt;: MultipleFusion end # multiple fusion with multiplicities
const MultiplicityFreeFusion = Union{UniqueFusion, SimpleFusion}

abstract type BraidingStyle end # generic braiding
abstract type HasBraiding &lt;: BraidingStyle end
struct NoBraiding &lt;: BraidingStyle end
abstract type SymmetricBraiding &lt;: HasBraiding end # symmetric braiding =&gt; actions of permutation group are well defined
struct Bosonic &lt;: SymmetricBraiding end # all twists are one
struct Fermionic &lt;: SymmetricBraiding end # twists one and minus one
struct Anyonic &lt;: HasBraiding end

struct Trivial &lt;: Sector end

# Anyon category
struct FibonacciAnyon &lt;: Sector
    isone::Bool
    function FibonacciAnyon(s::Symbol)
        s in (:I, :τ, :tau) || throw(ArgumentError(&quot;Unknown FibonacciAnyon $s.&quot;))
        new(s === :I)
    end
end
const _goldenratio = Float64(MathConstants.golden)

struct IsingAnyon &lt;: Sector
    s::Symbol
    function IsingAnyon(s::Symbol)
        s == :sigma &amp;&amp; (s = :σ)
        s == :psi &amp;&amp; (s = :ψ)
        if !(s in (:I, :σ, :ψ))
            throw(ValueError(&quot;Unknown IsingAnyon $s.&quot;))
        end
        new(s)
    end
end
const all_isinganyons = (IsingAnyon(:I), IsingAnyon(:σ), IsingAnyon(:ψ))

# Group
abstract type Group end
abstract type AbelianGroup &lt;: Group end

abstract type ℤ{N} &lt;: AbelianGroup end
abstract type U₁ &lt;: AbelianGroup end
abstract type SU{N} &lt;: Group end
abstract type CU₁ &lt;: Group end

const ℤ₂ = ℤ{2}
const ℤ₃ = ℤ{3}
const ℤ₄ = ℤ{4}
const SU₂ = SU{2}

const GroupTuple = Tuple{Vararg{Group}}
abstract type ProductGroup{T&lt;:GroupTuple} &lt;: Group end

# Rep_G category
abstract type AbstractIrrep{G&lt;:Group} &lt;: Sector end # irreps have integer quantum dimensions
struct IrrepTable end
const Irrep = IrrepTable()

const AbelianIrrep{G} = AbstractIrrep{G} where {G&lt;:AbelianGroup}

struct ZNIrrep{N} &lt;: AbstractIrrep{ℤ{N}}
    n::Int8
    function ZNIrrep{N}(n::Integer) where {N}
        @assert N &lt; 64
        new{N}(mod(n, N))
    end
end
Base.getindex(::IrrepTable, ::Type{ℤ{N}}) where N = ZNIrrep{N} # Irrep[Z{N}] = ZNIrrep{N}
const Z2Irrep = ZNIrrep{2}
const Z3Irrep = ZNIrrep{3}
const Z4Irrep = ZNIrrep{4}

struct U1Irrep &lt;: AbstractIrrep{U₁}
    charge::HalfInt
end

struct SU2IrrepException &lt;: Exception end
struct SU2Irrep &lt;: AbstractIrrep{SU₂}
    j::HalfInt
    function SU2Irrep(j)
        j &gt;= zero(j) || error(&quot;Not a valid SU₂ irrep&quot;)
        new(j)
    end
end
const _su2one = SU2Irrep(zero(HalfInt))

struct CU1Irrep &lt;: AbstractIrrep{CU₁}
    j::HalfInt # value of the U1 charge
    s::Int # rep of charge conjugation:
    # if j == 0, s = 0 (trivial) or s = 1 (non-trivial),
    # else s = 2 (two-dimensional representation)
    # Let constructor take the actual half integer value j
    function CU1Irrep(j::Real, s::Integer = ifelse(j&gt;zero(j), 2, 0))
        if ((j &gt; zero(j) &amp;&amp; s == 2) || (j == zero(j) &amp;&amp; (s == 0 || s == 1)))
            new(j, s)
        else
            error(&quot;Not a valid CU₁ irrep&quot;)
        end
    end
end

# Fusion Trees
struct FusionTree{I&lt;:Sector, N, M, L, T} # a splitting tree of simple objects
    uncoupled::NTuple{N, I} # objects coming out of the splitting trees, before the possible ``Z`` isomorphism.
    coupled::I
    isdual::NTuple{N, Bool}
    innerlines::NTuple{M, I} # M = N-2
    vertices::NTuple{L, T} # L = N-1
    function FusionTree{I, N, M, L, T}(uncoupled::NTuple{N, I},
                                            coupled::I,
                                            isdual::NTuple{N, Bool},
                                            innerlines::NTuple{M, I},
                                            vertices::NTuple{L, T}) where
                                            {I&lt;:Sector, N, M, L, T}
        new{I, N, M, L, T}(uncoupled, coupled, isdual, innerlines, vertices)
    end
end

struct FusionTreeIterator{I&lt;:Sector, N}
    uncoupled::NTuple{N, I}
    coupled::I
    isdual::NTuple{N, Bool}
end # iterate over fusion trees for fixed coupled and uncoupled sector labels

fusiontreedict(I) = FusionStyle(I) isa UniqueFusion ? SingletonDict : FusionTreeDict
const FusionTreeDict{K, V} = Dict{K, V}

const transposecache = LRU{Any, Any}(; maxsize = 10^5)
const usetransposecache = Ref{Bool}(true)
const TransposeKey{I&lt;:Sector, N₁, N₂} = Tuple{&lt;:FusionTree{I}, &lt;:FusionTree{I},
                                                IndexTuple{N₁}, IndexTuple{N₂}}

const braidcache = LRU{Any, Any}(; maxsize = 10^5)
const usebraidcache_abelian = Ref{Bool}(false)
const usebraidcache_nonabelian = Ref{Bool}(true)    

const BraidKey{I&lt;:Sector, N₁, N₂} = Tuple{&lt;:FusionTree{I}, &lt;:FusionTree{I},
                                        IndexTuple, IndexTuple,
                                        IndexTuple{N₁}, IndexTuple{N₂}}                                            </code></pre><h3 id="Properties"><a class="docs-heading-anchor" href="#Properties">Properties</a><a id="Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Properties" title="Permalink"></a></h3><h4 id="Sectors"><a class="docs-heading-anchor" href="#Sectors">Sectors</a><a id="Sectors-1"></a><a class="docs-heading-anchor-permalink" href="#Sectors" title="Permalink"></a></h4><pre><code class="language-julia hljs">Base.values(::Type{I}) where {I&lt;:Sector} # Return the iterator that generate all simple objects of sector `I`.
Base.one(a::Sector) = one(typeof(a)) # Return the unit object of the sector.
dual(a::Sector) = conj(a)
Base.conj # Return `a̅`; this should be implemented
Base.isless # give a canonical order for the simple objects in a sector
FusionStyle(a::Sector) = FusionStyle(typeof(a))
fusiontensor(a::I, b::I, c::I) where {I&lt;:AbstractIrrep{G&lt;:Group}} # Return the fusiontensor ``X^{ab}_{c,μ}: c → a ⊗ b`` as a rank-4 tensor with size `(dim(a),dim(b),dim(c),Int(Nsymbol(a,b,c)))`.
⊗(a::I, b::I) where {I&lt;:Sector}  # Return an iterator of elements of `c::I` that appear in the fusion product `a ⊗ b`.
Nsymbol(a::I, b::I, c::I) where {I&lt;:Sector} -&gt; Integer # Return an `Integer` representing the number of times `c` appears in the fusion product `a ⊗ b`. Could be a `Bool` if `FusionStyle(I) == UniqueFusion()` or `SimpleFusion()`.
Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I&lt;:Sector} # Fsymbol(a,b,c,d,e,f)[μ,ν,κ,λ]
vertex_ind2label(k::Int, a::I, b::I, c::I) where {I&lt;:Sector} # Convert the index `k` of the fusion vertex (a,b)-&gt;c into a label.
vertex_labeltype(I::Type{&lt;:Sector}) -&gt; Type # Return the type of labels for the fusion vertices of sectors of type `I`.
dim(a::Sector) # Return the (quantum) dimension of the sector `a`.
sqrtdim(a::Sector) # the square root of the quantum dimension of the sector `a`.
isqrtdim(a::Sector) # inverse of `sqrtdim(a::Sector)`
frobeniusschur(a::Sector) # Return the Frobenius-Schur indicator of a sector `a`.
Bsymbol(a::I, b::I, c::I) where {I&lt;:Sector}
Asymbol(a::I, b::I, c::I) where {I&lt;:Sector}
BraidingStyle(a::Sector) = BraidingStyle(typeof(a))
Rsymbol(a::I, b::I, c::I) where {I&lt;:Sector}
twist(a::Sector)
Base.isreal(I::Type{&lt;:Sector}) # whether topological data real
×(a::Type{&lt;:Group}, b::Type{&lt;:Group}, c::Type{&lt;:Group}...) = ×(×(a, b), c...) # Product of Groups</code></pre><h4 id="Fusion-trees"><a class="docs-heading-anchor" href="#Fusion-trees">Fusion trees</a><a id="Fusion-trees-1"></a><a class="docs-heading-anchor-permalink" href="#Fusion-trees" title="Permalink"></a></h4><pre><code class="language-julia hljs">fusiontreetype(::Type{I}, N::Int) where {I&lt;:Sector}  # Return the correct fusiontree type `FusionTree{I&lt;:Sector, N, M, L, T}` based on `I` and `N`.
sectortype(::Type{&lt;:FusionTree{I}}) # also for instance
FusionStyle(::Type{&lt;:FusionTree{I}}) where {I&lt;:Sector} # also for instance
BraidingStyle(::Type{&lt;:FusionTree{I}}) where {I&lt;:Sector} # also for instance
Base.length(::Type{&lt;:FusionTree{&lt;:Sector, N}}) where {N} # Return the number of the uncoupled objects in a fusion tree; also for instance
Base.isequal(f1::FusionTree{I, N}, f2::FusionTree{I, N}) where {I&lt;:Sector, N}
fusiontrees(uncoupled::NTuple{N, I}, coupled::I = one(I), isdual::NTuple{N, Bool} = ntuple(n-&gt;false, Val(N))) where {N, I&lt;:Sector} # return the FusionTreeIterator over all possible fusion trees from a set of N uncoupled sectors to a given coupled sector
Base.length(iter::FusionTreeIterator) # number of fusiontrees with fixed uncoupled objects and coupled object

 # Planar manipulations on a splitting tree
split(f::FusionTree{I, N}, M::Int) # Split a fusion tree into two. The first tree has as uncoupled sectors the first `M` uncoupled sectors of the input tree `f`
insertat(f::FusionTree{I, N₁}, i::Int, f2::FusionTree{I, N₂}) # Attach a fusion tree `f2` to the uncoupled leg `i` of the fusion tree `f1` and bring it into a linear combination of fusion trees in standard form.
merge(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}, c::I, μ = nothing) # Merge two fusion trees together to a linear combination of fusion trees whose uncoupled sectors are those of `f1` followed by those of `f2`, and where the two coupled sectors of `f1` and `f2` are further fused to `c`.
elementary_trace(f::FusionTree{I, N}, i) where {I&lt;:Sector, N} # Trace the ``i``th and ``i+1``th uncoupled sectors of splitting tree `f`.
planar_trace(f::FusionTree{I,N}, q1::IndexTuple{N₃}, q2::IndexTuple{N₃}) where {I&lt;:Sector, N, N₃} # Take the traces between `q1[k]`th and `q2[k]`th sector of the splitting tree `f`, where `1&lt;=k&lt;=N₃`.

# Planar manipulations on a fusion-splitting tree
bendright(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}) where {I&lt;:Sector, N₁, N₂} # map final splitting vertex (a, b)&lt;-c to fusion vertex a&lt;-(c, dual(b))
bendleft(f1::FusionTree{I}, f2::FusionTree{I}) where I # map final fusion vertex c&lt;-(a, b) to splitting vertex (c, dual(b))&lt;-a
foldright(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}) where {I&lt;:Sector, N₁, N₂} # map first splitting vertex (a, b)&lt;-c to fusion vertex b&lt;-(dual(a), c)
foldleft(f1::FusionTree{I}, f2::FusionTree{I}) where I # map first fusion vertex c&lt;-(a, b) to splitting vertex (dual(a), c)&lt;-b
cycleclockwise(f1::FusionTree{I}, f2::FusionTree{I}) where {I&lt;:Sector} # clockwise cyclic permutation while preserving (N₁, N₂): foldright &amp; bendleft
cycleanticlockwise(f1::FusionTree{I}, f2::FusionTree{I}) where {I&lt;:Sector} # anticlockwise cyclic permutation while preserving (N₁, N₂): foldleft &amp; bendright
repartition(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}, N::Int) where {I, N₁, N₂} # new tree has N outgoing sectors
Base.transpose(f1::FusionTree{I}, f2::FusionTree{I}, p1::IndexTuple{N₁}, p2::IndexTuple{N₂}) where {I&lt;:Sector, N₁, N₂} # Computes new trees and corresponding coefficients obtained from repartitioning and cyclic permutating the fusion-splitting tree such that sectors `p1` become outgoing and sectors `p2` become incoming.
planar_trace(f1::FusionTree{I}, f2::FusionTree{I}, p1::IndexTuple{N₁}, p2::IndexTuple{N₂}, q1::IndexTuple{N₃}, q2::IndexTuple{N₃}) where {I&lt;:Sector, N₁, N₂, N₃} # Take the traces between `q1[k]`th and `q2[k]`th sector of the fusion-splitting tree and the result is transposed according to `p1` and `p2`.

# Braiding manipulations on a splitting tree
artin_braid(f::FusionTree, i; inv::Bool = false) # Perform an elementary braid (Artin generator) of neighbouring uncoupled indices `i` and `i+1` on a fusion tree `f`, and returns the result as a dictionary of output trees and corresponding coefficients.
braid(f::FusionTree{&lt;:Sector, N}, levels::NTuple{N, Int}, p::NTuple{N, Int}) # general braiding according to permutation p and levels
permute(f::FusionTree, p::NTuple{N, Int}) # permutation when braiding is symmetric

# Braiding manipulations on a fusion-splitting tree
braid(f1::FusionTree{I}, f2::FusionTree{I}, levels1::IndexTuple, levels2::IndexTuple, p1::IndexTuple{N₁}, p2::IndexTuple{N₂}) where {I&lt;:Sector, N₁, N₂} # Compute new trees and corresponding coefficients obtained from repartitioning and braiding the tree such that sectors `p1` become outgoing and sectors `p2` become incoming.
permute(f1::FusionTree{I}, f2::FusionTree{I}, p1::NTuple{N₁, Int}, p2::NTuple{N₂, Int}) where {I, N₁, N₂} # permutation when braiding is symmetric</code></pre><h3 id="Others-structures"><a class="docs-heading-anchor" href="#Others-structures">Others structures</a><a id="Others-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Others-structures" title="Permalink"></a></h3><pre><code class="language-julia hljs">struct SectorSet{I&lt;:Sector, F, S} # behaves as an iterator that applies x-&gt;convert(I, f(x)) on the elements of set; if f is not provided it is just taken as the function identity.
    f::F
    set::S
end</code></pre><h2 id="ss_general"><a class="docs-heading-anchor" href="#ss_general">General arguments</a><a id="ss_general-1"></a><a class="docs-heading-anchor-permalink" href="#ss_general" title="Permalink"></a></h2><p>Symmetries in a physical system often result in tensors which are invariant under the action of the symmetry group, where this group acts as a tensor product of group actions on every tensor index separately. The group action on a single index, or thus, on the corresponding vector space, can be decomposed into irreducible representations (irreps). Here, we restrict to unitary representations, such that the corresponding vector spaces also have a natural Euclidean inner product. The Euclidean inner product between two vectors is invariant under the group action and thus transforms according to the trivial representation of the group.</p><p>The corresponding vector spaces will be canonically represented as <span>$V = ⨁_a ℂ^{n_a} ⊗ R_{a}$</span>, where <span>$a$</span> labels the different irreps, <span>$n_a$</span> is the number of times irrep <span>$a$</span> appears and <span>$R_a$</span> is the vector space associated with irrep <span>$a$</span>. Irreps are also known as spin sectors (in the case of <span>$\mathsf{SU}_2$</span>) or charge sectors (in the case of <span>$\mathsf{U}_1$</span>), and we henceforth refer to <span>$a$</span> as a sector. For practical reasons, we assume that there is a canonical order of the sectors, so that the vector space <span>$V$</span> is completely specified by the values of <span>$n_a$</span>.</p><p>As discussed in the section on <a href="../categories/#s_categories">categories</a>, the approach we follow does go beyond the case of irreps of groups, and sectors would more generally correspond to simple objects in a unitary ribbon fusion category. Nonetheless, every step can be appreciated by using the representation theory of <span>$\mathsf{SU}_2$</span> or <span>$\mathsf{SU}_3$</span> as example.</p><p>The gain in efficiency (both in memory occupation and computation time) obtained from using equivariant tensor maps is that, by Schur&#39;s lemma, they are block diagonal in the basis of coupled sectors. To exploit this block diagonal form, it is essential that we know the basis transform from the individual uncoupled sectors appearing in the tensor product form of the domain and codomain, to the coupled sectors that label the different blocks. We refer to the coupled sectors as block sectors. The transformation from the uncoupled sectors to the block sector is encoded in a fusion tree (or splitting tree). Essentially, it is a sequential application of pairwise fusion as described by the group&#39;s Clebsch–Gordan (CG) coefficients. However, it turns out that we do not need the actual CG coefficients, but only how they transform under transformations such as interchanging the order of the incoming irreps or interchanging incoming and outgoing irreps. This information is known as the topological data of the group, i.e. mainly the F-symbols, which are also known as recoupling coefficients or 6j-symbols. The F-symbol is actually Racah&#39;s W-coefficients in the case of <span>$\mathsf{SU}_2$</span>.</p><p>Below, we describe how to specify a certain type of sector and what information about them needs to be implemented. Then, we describe how to build a space <span>$V$</span> composed of a direct sum of different sectors. Then, we explain the constructions and manipulations of fusion trees. Finally, we elaborate on the case of general fusion categories and the possibility of having fermionic or anyonic twists.</p><h2 id="ss_representationtheory"><a class="docs-heading-anchor" href="#ss_representationtheory">Representation theory and unitary fusion categories</a><a id="ss_representationtheory-1"></a><a class="docs-heading-anchor-permalink" href="#ss_representationtheory" title="Permalink"></a></h2><p>Let us labol the sectors as <span>$a$</span>, <span>$b$</span>, <span>$c$</span>, …. In general, they correspond to the simple objects of a tensor category.</p><p>First, we need to specify the <strong>fusion rules</strong> <span>$a ⊗ b = ⨁ N^{ab}_{c} c$</span> with <span>$N^{ab}_{c}$</span> some non-negative integers.</p><p>There should always exists a unique trivial sector <span>$u$</span> (called the identity object <span>$I$</span> or <span>$1$</span> in the language of categories) such that <span>$a ⊗ u = a = u ⊗ a$</span>.</p><p>We need to specify a unique sector <span>$\bar{a}$</span> such that <span>$N^{a\bar{a}}_{u} = 1$</span>, whereas for all <span>$b \neq \bar{a}$</span>, <span>$N^{ab}_{u} = 0$</span>. For unitary irreps of groups, <span>$\bar{a}$</span> corresponds to the complex conjugate of the representation <span>$a$</span>, or a representation isomorphic to it.</p><p>For example, for <span>$\mathsf{SU}_2$</span>, the trivial sector corresponds to spin zero and all irreps are self-dual (i.e. <span>$a = \bar{a}$</span>), meaning that the conjugate representation is isomorphic to the non-conjugated one (they are not equal but related by a similarity transform).</p><p>The space of transformations <span>$R_c → R_a ⊗ R_b$</span> has dimension <span>$N^{ab}_c$</span>. We assume there exists a set of maps <span>$X^{ab}_{c,μ} : R_c → R_a ⊗ R_b$</span> with <span>$μ = 1, …, N^{ab}_c$</span>, which form the basis of the morphism space from <span>$R_c$</span> to <span>$R_a ⊗ R_b$</span>, and satisfy</p><p><span>$(X^{ab}_{c,μ})^†\circ X^{ab}_{c,ν} = δ_{μ,ν} \mathrm{id}_{R_c}$</span></p><p><span>$\sum_{c} \sum_{μ = 1}^{N^{ab}_c} X^{ab}_{c,μ}\circ (X^{ab}_{c,μ})^\dagger = \mathrm{id}_{R_a ⊗ R_b}$</span></p><p>The tensors <span>$X^{ab}_{c,μ}$</span> are the splitting tensors, and their hermitian conjugate are the fusion tensors. They are only determined up to a unitary basis transform within the space, i.e., acting on the multiplicity label <span>$μ = 1, …, N^{ab}_c$</span>. For <span>$\mathsf{SU}_2$</span>, <span>$N^{ab}_c$</span> is zero or one and the entries of <span>$X^{ab}_{c}$</span> are precisely given by the CG coefficients.</p><p>The topological data of category describes the following transformation:</p><ul><li><p>F-move or recoupling: the transformation from <span>$(R_a ⊗ R_b) ⊗ R_c$</span> to   <span>$R_a ⊗ (R_b ⊗ R_c)$</span>:</p><p><span>$(X^{ab}_{e,μ} ⊗ \mathrm{id}_c) ∘ X^{ec}_{d,ν} = ∑_{f,κ,λ} [F^{abc}_{d}]_{eμν}^{fκλ} (\mathrm{id}_a ⊗ X^{bc}_{f,κ}) ∘ X^{af}_{d,λ}$</span></p></li><li><p>Braiding <span>$τ_{a,b}: R_a ⊗ R_b → R_b ⊗ R_a$</span>:</p><p><span>$τ_{a,b} ∘ X^{ab}_{c,μ} = ∑_{ν} [R^{ab}_c]^ν_μ X^{ba}_{c,ν}$</span></p></li></ul><p>The dimensions of the spaces <span>$R_a$</span> on which representation <span>$a$</span> acts are denoted as <span>$d_a$</span> and referred to as quantum dimensions. In particular, <span>$d_u = 1$</span> and <span>$d_a = d_{\bar{a}}$</span>. This information is also encoded in the F-symbol as <span>$d_a = | [F^{a \bar{a} a}_a]^u_u |^{-1}$</span>. Note that there are no multiplicity labels in this particular F-symbol as <span>$N^{a\bar{a}}_u = 1$</span>.</p><p>Graphically:</p><p><img src="../img/tree-summary.svg" alt="summary"/></p><p>For the implementation, it will be useful to distinguish between the number of different possibilities regarding the fusion rules. If, for every <span>$a$</span> and <span>$b$</span>, there is a <strong>unique</strong> <span>$c$</span> such that <span>$a ⊗ b = c$</span> (i.e. <span>$N^{ab}_{c} = 1$</span> and <span>$N^{ab}_{c′} = 0$</span> for all other <span>$c′$</span>), the category is abelian. The representations of a group have this property if and only if the group multiplication law is commutative. In this case, all spaces <span>$R_{a}$</span> associated with the representation are one-dimensional and thus trivial. In all other cases, the category is non-abelian. We find it useful to further distinguish between categories which have all <span>$N^{ab}_c$</span> equal to zero or one (such that no multiplicity labels are needed), e.g. the representations of <span>$\mathsf{SU}_2$</span>, and those where some <span>$N^{ab}_c$</span> are larger than one, e.g. the representations of <span>$\mathsf{SU}_3$</span>.</p><h2 id="ss_sectors"><a class="docs-heading-anchor" href="#ss_sectors">Sectors</a><a id="ss_sectors-1"></a><a class="docs-heading-anchor-permalink" href="#ss_sectors" title="Permalink"></a></h2><p>We introduce an abstract type to represent sectors</p><pre><code class="language-julia hljs">abstract type Sector end</code></pre><p>Any concrete subtype of <code>Sector</code> should be such that its instances represent a consistent set of sectors, corresponding to the irreps of a group, or, more generally, the simple objects of an unitary fusion category.</p><p>Throughout TensorLabXD.jl, the method <code>sectortype</code> can be used to query the subtype of <code>Sector</code> associated with an object, e.g., a vector space, fusion tree, tensor map, or a sector. It works on both instances and types.</p><p>The data that needed to specify a sector type are:</p><ul><li>the fusion rules <span>$a ⊗ b = ⨁ N^{ab}_{c} c$</span>: <a href="man/@ref"><code>Nsymbol(a,b,c)</code></a></li><li>the list of fusion outputs from <span>$a ⊗ b$</span>: while this information is contained in   <span>$N^{ab}_c$</span>, it might be costly or impossible to iterate over all possible values of   <code>c</code> and test <code>Nsymbol(a,b,c)</code>; instead we implement for <code>a ⊗ b</code> to return an iterable   object which generates all <code>c</code> with <span>$N^{ab}_c ≠ 0$</span> (just once even if <span>$N^{ab}_c&gt;1$</span>)</li><li>the identity object <code>u</code>, such that <span>$a ⊗ u = a = u ⊗ a$</span>: <code>one(a)</code></li><li>the dual or conjugate representation <span>$\overline{a}$</span> for which   <span>$N^{a\bar{a}}_{u} = 1$</span>: <code>conj(a)</code>; <code>dual(a)</code> also works as alias, but <code>conj(a)</code> is the   method that should be defined</li><li>the F-symbol: <a href="man/@ref"><code>Fsymbol(a,b,c,d,e,f)</code></a></li><li>the R-symbol: <a href="man/@ref"><code>Rsymbol(a,b,c)</code></a></li></ul><p>For practical reasons, we also require some additional methods to be defined:</p><ul><li><code>isreal(::Type{&lt;:Sector})</code> returns whether the topological data of this type of sector   is real-valued or not. Note that this does not necessarily require that the   representation itself, or the Clebsch-Gordan coefficients, are real. There is a fallback   implementation that checks whether the F-symbol and R-symbol evaluated with all sectors   equal to the identity sector have real <code>eltype</code>.</li><li><code>hash(a, h)</code> creates a hash of sectors, because sectors and objects created from them   are used as keys in dictionaries.</li><li><code>isless(a,b)</code> associates a canonical order to sectors of the same type, in order to   unambiguously represent representation spaces <span>$V = ⨁_a ℂ^{n_a} ⊗ R_{a}$</span>.</li></ul><p>The quantum dimensions <span>$d_a$</span> and Frobenius-Schur indicator <span>$χ_a$</span> are encoded in the F-symbol. These functions have default definitions, and should be overloaded if the value can be computed more efficiently.</p><p>We define a parametric type to represent an indexable iterator over the instances of a sector type as</p><pre><code class="language-julia hljs">struct SectorValues{I&lt;:Sector} end
Base.IteratorEltype(::Type{&lt;:SectorValues}) = HasEltype()
Base.eltype(::Type{SectorValues{I}}) where {I&lt;:Sector} = I
Base.values(::Type{I}) where {I&lt;:Sector} = SectorValues{I}()</code></pre><p>An instance of the singleton type <code>SectorValues{I&lt;:Sector}</code> is obtained as <code>values(I)</code>. A new sector <code>I&lt;:Sector</code> should implement</p><pre><code class="language-julia hljs">Base.iterate(::SectorValues{I}[, state]) = ...
Base.IteratorSize(::Type{SectorValues{I}}) = # HasLenght() or IsInfinite()
# if previous function returns HasLength():
Base.length(::SectorValues{I}) = ...
Base.getindex(::SectorValues{I}, i::Int) = ...
findindex(::SectorValues{I}, c::I) = ...</code></pre><p>If the number of values in a sector <code>I</code> is finite (i.e. <code>IteratorSize(values(I)) == HasLength()</code>), the methods <code>getindex</code> and <code>findindex</code> provide a way to map the different sector instances from and to the standard range 1, 2, …, <code>length(values(I))</code>. This will be used to efficiently represent <code>GradedSpace</code> objects for this type of sector.</p><p>It is useful to distinguish between three cases with respect to the fusion rules:</p><pre><code class="language-julia hljs">abstract type FusionStyle end
struct UniqueFusion &lt;: FusionStyle # unique fusion output when fusion two sectors
end
abstract type MultipleFusion &lt;: FusionStyle end
struct SimpleFusion &lt;: MultipleFusion # multiple fusion output but multiplicity free
end
struct GenericFusion &lt;: MultipleFusion # multiple fusion output with multiplicities
end
const MultiplicityFreeFusion = Union{UniqueFusion, SimpleFusion}</code></pre><p>New sector types <code>I&lt;:Sector</code> should then indicate which fusion style they have by defining <code>FusionStyle(::Type{I})</code>.</p><p>In a similar manner, it is useful to distinguish between different styles of braiding:</p><pre><code class="language-julia hljs">abstract type BraidingStyle end
struct NoBraiding &lt;: BraidingStyle end
abstract type HasBraiding &lt;: BraidingStyle end
struct Anyonic &lt;: HasBraiding end
abstract type SymmetricBraiding &lt;: HasBraiding end
struct Bosonic &lt;: SymmetricBraiding end # all twists are one
struct Fermionic &lt;: SymmetricBraiding end # twists one and minus one</code></pre><p>New sector types <code>I&lt;:Sector</code> should then indicate which braiding style they have by defining <code>BraidingStyle(::Type{})</code>. Note that <code>Bosonic()</code> braiding does not mean that all permutations are trivial and <span>$R^{ab}_c = 1$</span>, but that <span>$R^{ab}_c R^{ba}_c = 1$</span>. For example, for the irreps of <span>$\mathsf{SU}_2$</span>, the R-symbol associated with the fusion of two spin-1/2 particles to spin zero is <span>$-1$</span>, i.e. the singlet of two spin-1/2 particles is antisymmetric. For a <code>Bosonic()</code> braiding style, all twists are <span>$+1$</span>.</p><h3 id="sss_groups"><a class="docs-heading-anchor" href="#sss_groups">Existing group representations</a><a id="sss_groups-1"></a><a class="docs-heading-anchor-permalink" href="#sss_groups" title="Permalink"></a></h3><p>The first sector type is called <code>Trivial</code>, and corresponds to the case where there is actually no symmetry. Thus, the trivial symmetry group has only an identity operation and a trivial representation:</p><pre><code class="language-julia hljs">struct Trivial &lt;: Sector
end
Base.one(a::Sector) = one(typeof(a))
Base.one(::Type{Trivial}) = Trivial()
Base.conj(::Trivial) = Trivial()
⊗(::Trivial, ::Trivial) = (Trivial(),)
Nsymbol(::Trivial, ::Trivial, ::Trivial) = true
Fsymbol(::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial, ::Trivial) = 1
Rsymbol(::Trivial, ::Trivial, ::Trivial) = 1
Base.isreal(::Type{Trivial}) = true
FusionStyle(::Type{Trivial}) = UniqueFusion()
BraidingStyle(::Type{Trivial}) = Bosonic()</code></pre><p>The <code>Trivial</code> sector type is special cased in the construction of tensors, so that most of these definitions are not actually used.</p><p>The most important class of sectors are irreducible representations of groups, for which we have an abstract supertype <code>AbstractIrrep{G}</code> that is parameterized on the type of group <code>G</code>. One can obtain a concrete type as <code>Irrep[G]</code> without of knowing its name.</p><pre><code class="language-julia hljs">abstract type AbstractIrrep{G&lt;:Group} &lt;: Sector end</code></pre><p>A number of groups have been defined:</p><pre><code class="language-julia hljs">abstract type Group end
abstract type SU{N} &lt;: Group end
const SU₂ = SU{2}
abstract type CU₁ &lt;: Group end

abstract type AbelianGroup &lt;: Group end
abstract type ℤ{N} &lt;: AbelianGroup end
const ℤ₂ = ℤ{2}
const ℤ₃ = ℤ{3}
const ℤ₄ = ℤ{4}
abstract type U₁ &lt;: AbelianGroup end</code></pre><p>Groups themselves are abstract types without any functionality (at least for now). We also provide a number of convenient Unicode aliases.</p><p>For all group irreps, the braiding style is bosonic</p><pre><code class="language-julia hljs">BraidingStyle(::Type{&lt;:AbstractIrrep}) = Bosonic()</code></pre><p>We gather some more common functionality for irreps of abelian groups (which exhaust all possibilities of fusion categories with abelian fusion):</p><pre><code class="language-julia hljs">const AbelianIrrep{G} = AbstractIrrep{G} where {G&lt;:AbelianGroup}

FusionStyle(::Type{&lt;:AbelianIrrep}) = UniqueFusion()
Base.isreal(::Type{&lt;:AbelianIrrep}) = true

Nsymbol(a::I, b::I, c::I) where {I&lt;:AbelianIrrep} = c == first(a ⊗ b)
Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I) where {I&lt;:AbelianIrrep} =
    Int(Nsymbol(a, b, e)*Nsymbol(e, c, d)*Nsymbol(b, c, f)*Nsymbol(a, f, d))
frobeniusschur(a::AbelianIrrep) = 1
Bsymbol(a::I, b::I, c::I) where {I&lt;:AbelianIrrep} = Int(Nsymbol(a, b, c))
Rsymbol(a::I, b::I, c::I) where {I&lt;:AbelianIrrep} = Int(Nsymbol(a, b, c))</code></pre><p>With these common definition, we implement the representation theory of the two most common Abelian groups <span>$ℤ_N$</span> and <span>$\mathsf{U}_1$</span>.</p><pre><code class="language-julia hljs">struct ZNIrrep{N} &lt;: AbstractIrrep{ℤ{N}}
    n::Int8
    function ZNIrrep{N}(n::Integer) where {N}
        @assert N &lt; 64
        new{N}(mod(n, N))
    end
end
Base.getindex(::IrrepTable, ::Type{ℤ{N}}) where N = ZNIrrep{N}
Base.convert(Z::Type{&lt;:ZNIrrep}, n::Real) = Z(n)

Base.one(::Type{ZNIrrep{N}}) where {N} =ZNIrrep{N}(0)
Base.conj(c::ZNIrrep{N}) where {N} = ZNIrrep{N}(-c.n)
⊗(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = (ZNIrrep{N}(c1.n+c2.n),)
Base.hash(c::ZNIrrep{N}, h::UInt) where {N} = hash(c.n, h)
Base.isless(c1::ZNIrrep{N}, c2::ZNIrrep{N}) where {N} = isless(c1.n, c2.n)

Base.IteratorSize(::Type{SectorValues{ZNIrrep{N}}}) where N = HasLength()
Base.iterate(::SectorValues{ZNIrrep{N}}, i = 0) where N =
    return i == N ? nothing : (ZNIrrep{N}(i), i+1)
Base.length(::SectorValues{ZNIrrep{N}}) where N = N
Base.getindex(::SectorValues{ZNIrrep{N}}, i::Int) where N =
    1 &lt;= i &lt;= N ? ZNIrrep{N}(i-1) : throw(BoundsError(values(ZNIrrep{N}), i))
findindex(::SectorValues{ZNIrrep{N}}, c::ZNIrrep{N}) where N = c.n + 1</code></pre><p>The <code>getindex</code> definition just below the type definition provides the mechanism to get the concrete type as <code>Irrep[G]</code> for a given group <code>G</code>. Here, <code>IrrepTable</code> is the singleton type of which the constant <code>Irrep</code> is the only instance. The <code>Base.convert</code> definition allows to convert real numbers to the instance of corresponding sector, and thus to omit the type information of the sector whenever this is clear from the context.</p><p>Since sectors or objects made out of tuples of sectors (see the section on <a href="#ss_fusiontrees">Fusion Trees</a> below) are often used as keys in look-up tables (i.e. subtypes of <code>AbstractDictionary</code> in Julia), it is important that they can be hashed efficiently. We just hash the sectors above based on their numerical value.</p><p>For <code>ZNIrrep{N}</code>, we use an <code>Int8</code> for compact storage, assuming that this type will not be used with <code>N&gt;64</code> (we need <code>2*(N-1) &lt;= 127</code> in order for <code>a ⊗ b</code> to work correctly). We also define some aliases for the first (and most commonly used <code>ℤ{N}</code> irreps)</p><pre><code class="language-julia hljs">const Z2Irrep = ZNIrrep{2}
const Z3Irrep = ZNIrrep{3}
const Z4Irrep = ZNIrrep{4}</code></pre><p>so that we can do</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; z = Z3Irrep(1)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃](1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ZNIrrep{3}(1) ⊗ Irrep[ℤ₃](1)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[ℤ₃](2),)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conj(z)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃](2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; one(z)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[ℤ₃](0)</code></pre><pre><code class="language-julia hljs">struct U1Irrep &lt;: AbstractIrrep{U₁}
    charge::HalfInt
end
Base.getindex(::IrrepTable, ::Type{U₁}) = U1Irrep
Base.convert(::Type{U1Irrep}, c::Real) = U1Irrep(c)

Base.one(::Type{U1Irrep}) = U1Irrep(0)
Base.conj(c::U1Irrep) = U1Irrep(-c.charge)
⊗(c1::U1Irrep, c2::U1Irrep) = (U1Irrep(c1.charge+c2.charge),)
Base.hash(c::U1Irrep, h::UInt) = hash(c.charge, h)
Base.isless(c1::U1Irrep, c2::U1Irrep) where {N} =
    isless(abs(c1.charge), abs(c2.charge)) || zero(HalfInt) &lt; c1.charge == -c2.charge

Base.IteratorSize(::Type{SectorValues{U1Irrep}}) = IsInfinite()
Base.iterate(::SectorValues{U1Irrep}, i = 0) =
    return i &lt;= 0 ? (U1Irrep(half(i)), (-i + 1)) : (U1Irrep(half(i)), -i)</code></pre><p>In the definition of <code>U1Irrep</code>, <code>HalfInt&lt;:Number</code> is a Julia type defined in <a href="https://github.com/sostock/HalfIntegers.jl">HalfIntegers.jl</a>, which is also used for <code>SU2Irrep</code> below, that stores integer or half integer numbers using twice their value. Strictly speaking, the linear representations of <code>U₁</code> can only have integer charges, and fractional charges lead to a projective representation. It can be useful to allow half integers in order to describe spin 1/2 systems with an axis rotation symmetry. As a user, you should not worry about the details of <code>HalfInt</code>, and additional methods for automatic conversion and pretty printing are provided, as illustrated by the following example</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Irrep[U₁](0.5)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[U₁](1/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U1Irrep(0.4)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: InexactError: Int64(0.8)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; U1Irrep(1) ⊗ Irrep[U₁](1//2)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[U₁](3/2),)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; u = first(U1Irrep(1) ⊗ Irrep[U₁](1//2))</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[U₁](3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Nsymbol(u, conj(u), one(u))</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>A non-abelian representation category is that of <span>$\mathsf{SU}_2$</span>:</p><pre><code class="language-julia hljs">struct SU2Irrep &lt;: AbstractIrrep{SU{2}}
    j::HalfInt
end

Base.one(::Type{SU2Irrep}) = SU2Irrep(zero(HalfInt))
Base.conj(s::SU2Irrep) = s
⊗(s1::SU2Irrep, s2::SU2Irrep) = SectorSet{SU2Irrep}(abs(s1.j-s2.j):(s1.j+s2.j))
dim(s::SU2Irrep) = twice(s.j)+1
FusionStyle(::Type{SU2Irrep}) = SimpleFusion()
Base.isreal(::Type{SU2Irrep}) = true
Nsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep) = WignerSymbols.δ(sa.j, sb.j, sc.j)
Fsymbol(s1::SU2Irrep, s2::SU2Irrep, s3::SU2Irrep,
        s4::SU2Irrep, s5::SU2Irrep, s6::SU2Irrep) =
    WignerSymbols.racahW(s1.j, s2.j, s4.j, s3.j, s5.j, s6.j)*sqrt(dim(s5)*dim(s6))
function Rsymbol(sa::SU2Irrep, sb::SU2Irrep, sc::SU2Irrep)
    Nsymbol(sa, sb, sc) || return 0.
    iseven(convert(Int, sa.j+sb.j-sc.j)) ? 1.0 : -1.0
end

Base.IteratorSize(::Type{SectorValues{SU2Irrep}}) = IsInfinite()
Base.iterate(::SectorValues{SU2Irrep}, i = 0) = (SU2Irrep(half(i)), i+1)</code></pre><p>The topological data (<code>Nsymbol</code> and <code>Fsymbol</code>) are provided by the package <a href="https://github.com/Jutho/WignerSymbols.jl">WignerSymbols.jl</a>.</p><p>Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = SU2Irrep(3//2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU₂](3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conj(s)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU₂](3/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(s)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(s ⊗ s)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Array{SU2Irrep,1}:
 0
 1
 2
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; for s2 in s ⊗ s
           @show s2
           @show Nsymbol(s, s, s2)
           @show Rsymbol(s, s, s2)
       end</code><code class="nohighlight hljs ansi" style="display:block;">s2 = Irrep[SU₂](0)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = -1.0
s2 = Irrep[SU₂](1)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = 1.0
s2 = Irrep[SU₂](2)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = -1.0
s2 = Irrep[SU₂](3)
Nsymbol(s, s, s2) = true
Rsymbol(s, s, s2) = 1.0</code></pre><p>Another non-abelian representation theory is that of the semidirect product <span>$\mathsf{U}₁ ⋉ ℤ_2$</span>, where in the context of quantum systems, this occurs in the case of systems with particle hole symmetry and the non-trivial element of <span>$ℤ_2$</span> acts as charge conjugation <span>$C$</span>. It has the effect of interchanging <span>$\mathsf{U}_1$</span> irreps <span>$n$</span> and <span>$-n$</span>, and turns them together in a joint 2-dimensional index, except for the case <span>$n=0$</span>. Irreps are therefore labeled by integers <span>$n ≧ 0$</span>, however for <span>$n=0$</span> the <span>$ℤ₂$</span> symmetry can be realized trivially or non-trivially, resulting in an even and odd one- dimensional irrep with <span>$\mathsf{U}_1$</span> charge <span>$0$</span>. Given <span>$\mathsf{U}_1 ≂ \mathsf{SO}_2$</span>, this group is also simply known as <span>$\mathsf{O}_2$</span>, and the two representations with <span>$n = 0$</span> are the scalar and pseudo-scalar, respectively. However, because we also allow for half integer representations, we refer to it as <code>Irrep[CU₁]</code> or <code>CU1Irrep</code> in full.</p><pre><code class="language-julia hljs">struct CU1Irrep &lt;: AbstractIrrep{CU₁}
    j::HalfInt # value of the U1 charge
    s::Int # rep of charge conjugation:
    # if j == 0, s = 0 (trivial) or s = 1 (non-trivial),
    # else s = 2 (two-dimensional representation)
    # Let constructor take the actual half integer value j
    function CU1Irrep(j::Real, s::Int = ifelse(j&gt;zero(j), 2, 0))
        if ((j &gt; zero(j) &amp;&amp; s == 2) || (j == zero(j) &amp;&amp; (s == 0 || s == 1)))
            new(j, s)
        else
            error(&quot;Not a valid CU₁ irrep&quot;)
        end
    end
end

Base.one(::Type{CU1Irrep}) = CU1Irrep(zero(HalfInt), 0)
Base.conj(c::CU1Irrep) = c
dim(c::CU1Irrep) = ifelse(c.j == zero(HalfInt), 1, 2)

FusionStyle(::Type{CU1Irrep}) = SimpleFusion()
...</code></pre><p>The rest of the implementation can be read in the source code, but is rather long due to all the different cases for the arguments of <code>Fsymbol</code>.</p><p>So far, no sectors have been implemented with <code>FusionStyle(G) == GenericFusion()</code>, though an example would be the representation theory of <span>$\mathsf{SU}_N$</span> for <code>N&gt;2</code>. Such sectors are not yet fully supported; certain operations remain to be implemented. The topological data of the representation theory of such groups is not readily available and needs to be computed.</p><h3 id="sss_productsectors"><a class="docs-heading-anchor" href="#sss_productsectors">Combining different sectors</a><a id="sss_productsectors-1"></a><a class="docs-heading-anchor-permalink" href="#sss_productsectors" title="Permalink"></a></h3><p>It is also possible to define two or more different types of symmetries, e.g. when the total symmetry group is a direct product of individual simple groups. Such sectors are obtained using the binary operator <code>⊠</code>, which can be entered as <code>\boxtimes</code>+TAB.</p><p>Some examples</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = Z3Irrep(1) ⊠ Irrep[U₁](1)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[ℤ₃](1) ⊠ Irrep[U₁](1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">TensorLabXD.ProductSector{Tuple{ZNIrrep{3},U1Irrep}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conj(a)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[ℤ₃](2) ⊠ Irrep[U₁](-1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; one(a)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[ℤ₃](0) ⊠ Irrep[U₁](0))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(a)</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(a ⊗ a)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Array{TensorLabXD.ProductSector{Tuple{ZNIrrep{3},U1Irrep}},1}:
 (2, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(a)</code><code class="nohighlight hljs ansi" style="display:block;">UniqueFusion()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; b = Irrep[ℤ₃](1) ⊠ Irrep[SU₂](3//2)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[ℤ₃](1) ⊠ Irrep[SU₂](3/2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(b)</code><code class="nohighlight hljs ansi" style="display:block;">TensorLabXD.ProductSector{Tuple{ZNIrrep{3},SU2Irrep}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conj(b)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[ℤ₃](2) ⊠ Irrep[SU₂](3/2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; one(b)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[ℤ₃](0) ⊠ Irrep[SU₂](0))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(b)</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(b ⊗ b)</code><code class="nohighlight hljs ansi" style="display:block;">1×4 Array{TensorLabXD.ProductSector{Tuple{ZNIrrep{3},SU2Irrep}},2}:
 (2, 0)  (2, 1)  (2, 2)  (2, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(b)</code><code class="nohighlight hljs ansi" style="display:block;">SimpleFusion()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; c = Irrep[SU₂](1) ⊠ SU2Irrep(3//2)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[SU₂](1) ⊠ Irrep[SU₂](3/2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(c)</code><code class="nohighlight hljs ansi" style="display:block;">TensorLabXD.ProductSector{Tuple{SU2Irrep,SU2Irrep}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; conj(c)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[SU₂](1) ⊠ Irrep[SU₂](3/2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; one(c)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[SU₂](0) ⊠ Irrep[SU₂](0))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(c)</code><code class="nohighlight hljs ansi" style="display:block;">12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(c ⊗ c)</code><code class="nohighlight hljs ansi" style="display:block;">3×4 Array{TensorLabXD.ProductSector{Tuple{SU2Irrep,SU2Irrep}},2}:
 (0, 0)  (0, 1)  (0, 2)  (0, 3)
 (1, 0)  (1, 1)  (1, 2)  (1, 3)
 (2, 0)  (2, 1)  (2, 2)  (2, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(c)</code><code class="nohighlight hljs ansi" style="display:block;">SimpleFusion()</code></pre><p>We refer to the source file of <a href="man/@ref"><code>ProductSector</code></a> for implementation details.</p><p>The symbol <code>⊠</code> refers to the <a href="https://ncatlab.org/nlab/show/Deligne+tensor+product+of+abelian+categories">Deligne tensor product</a> within the literature on category theory. The category of representation of a product group <code>G₁ × G₂</code> corresponds the Deligne tensor product of the categories of representations of the two groups separately. This definition also extends to general 𝕜-linear categories. Note that <code>⊠</code> also works in the type domain, i.e. <code>Irrep[ℤ₃] ⊠ Irrep[CU₁]</code> can be used to create <code>ProductSector{Tuple{Irrep[ℤ₃], Irrep[CU₁]}}</code>. Instances of this type can be constructed by giving a number of arguments, where the first argument is used to construct the first sector, and so forth. For representations of groups, we also enabled the notation <code>Irrep[ℤ₃ × CU₁]</code>, with <code>×</code> obtained using <code>\times+TAB</code>. However, this is merely for convience; as <code>Irrep[ℤ₃] ⊠ Irrep[CU₁]</code> is not a subtype of the abstract type <code>AbstractIrrep{ℤ₃ × CU₁}</code>.  </p><p>Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = Z3Irrep(1) ⊠ Irrep[CU₁](1.5)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[ℤ₃](1) ⊠ Irrep[CU₁](3/2, 2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a isa Irrep[ℤ₃] ⊠ CU1Irrep</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a isa Irrep[ℤ₃ × CU₁]</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a isa Irrep{ℤ₃ × CU₁}</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: TypeError: in Type{...} expression, expected UnionAll, got a value of type TensorLabXD.IrrepTable</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a == Irrep[ℤ₃ × CU₁](1, 1.5)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h3 id="sss_newsectors"><a class="docs-heading-anchor" href="#sss_newsectors">Defining a new type of sector</a><a id="sss_newsectors-1"></a><a class="docs-heading-anchor-permalink" href="#sss_newsectors" title="Permalink"></a></h3><p>By now, it should be clear how to implement a new <code>Sector</code> subtype. Ideally, a new <code>I&lt;:Sector</code> type is a <code>struct I ... end</code> (immutable) that has <code>isbitstype(I) == true</code>, and implements the following minimal set of methods</p><pre><code class="language-julia hljs">Base.one(::Type{I}) = I(...)
Base.conj(a::I) = I(...)
Base.isreal(::Type{I}) = ... # true or false
TensorLabXD.FusionStyle(::Type{I}) = ... # UniqueFusion(), SimpleFusion(), GenericFusion()
TensorLabXD.BraidingStyle(::Type{I}) = ... # Bosonic(), Fermionic(), Anyonic()
TensorLabXD.Nsymbol(a::I, b::I, c::I) = ... # Bool or Integer
Base.:⊗(a::I, b::I) = ... # some iterable object that generates all possible fusion outputs
TensorLabXD.Fsymbol(a::I, b::I, c::I, d::I, e::I, f::I)
TensorLabXD.Rsymbol(a::I, b::I, c::I)
Base.hash(a::I, h::UInt)
Base.isless(a::I, b::I)
Base.iterate(::TensorLabXD.SectorValues{I}[, state]) = ...
Base.IteratorSize(::Type{TensorLabXD.SectorValues{I}}) = ... # HasLenght() or IsInfinite()
# if previous function returns HasLength():
Base.length(::TensorLabXD.SectorValues{I}) = ...
Base.getindex(::TensorLabXD.SectorValues{I}, i::Int) = ...
TensorLabXD.findindex(::TensorLabXD.SectorValues{I}, c::I) = ...</code></pre><p>Additionally, suitable definitions can be given for</p><pre><code class="language-julia hljs">TensorLabXD.dim(a::I) = ...
TensorLabXD.frobeniusschur(a::I) = ...
TensorLabXD.Bsymbol(a::I, b::I, c::I) = ...</code></pre><p>There is a default implementation for these three functions that just relies on <code>Fsymbol</code>, and alternative definitions need to be given only if a more efficient version is available.</p><p>If <code>FusionStyle(I) == GenericFusion()</code>, then the multiple outputs <code>c</code> in the tensor product of <code>a</code> and <code>b</code> will be labeled as <code>i=1</code>, <code>2</code>, …, <code>Nsymbol(a,b,c)</code>. Optionally, a different label can be provided by defining</p><pre><code class="language-julia hljs">TensorLabXD.vertex_ind2label(i::Int, a::I, b::I, c::I) = ...
# some label, e.g. a `Char` or `Symbol`</code></pre><p>The following function will then automatically determine the corresponding label type (which should not vary, i.e. <code>vertex_ind2label</code> should be type stable)</p><pre><code class="language-julia hljs">vertex_labeltype(I::Type{&lt;:Sector}) =
    typeof(vertex_ind2label(1, one(I), one(I), one(I)))</code></pre><p>The following type, which already appeared in the implementation of <code>SU2Irrep</code> above, can be useful for providing the return type of <code>a ⊗ b</code></p><pre><code class="language-julia hljs">struct SectorSet{I&lt;:Sector,F,S}
    f::F
    set::S
end
...
function Base.iterate(s::SectorSet{I}, args...) where {I&lt;:Sector}
    next = iterate(s.set, args...)
    next === nothing &amp;&amp; return nothing
    val, state = next
    return convert(I, s.f(val)), state
end</code></pre><p>That is, <code>SectorSet(f, set)</code> behaves as an iterator that applies <code>x-&gt;convert(I, f(x))</code> on the elements of <code>set</code>; if <code>f</code> is not provided it is just taken as the function <code>identity</code>.</p><h3 id="sss_generalsectors"><a class="docs-heading-anchor" href="#sss_generalsectors">Generalizations</a><a id="sss_generalsectors-1"></a><a class="docs-heading-anchor-permalink" href="#sss_generalsectors" title="Permalink"></a></h3><p>The framework for sectors outlined above depends is in one-to-one correspondence to the topological data for specifying a unitary (spherical and braided, and hence ribbon) fusion category. For such general categories, the objects are not necessarily vector spaces and the fusion and splitting tensors <span>$X^{ab}_{c,μ}$</span> do not necessarily exist as actual tensors. The morphism spaces <span>$c → a ⊗ b$</span> still behave as vector spaces, and the <span>$X^{ab}_{c,μ}$</span> acts as generic basis for that space. As TensorLabXD.jl does not rely on the <span>$X^{ab}_{c,μ}$</span> themselves it can also deal with such general fusion categories. When <span>$X^{ab}_{c,μ}$</span> does exist, it is available as <code>fusiontensor(a,b,c[,μ])</code> and can be useful for checking purposes.</p><h2 id="ss_rep"><a class="docs-heading-anchor" href="#ss_rep">Graded spaces</a><a id="ss_rep-1"></a><a class="docs-heading-anchor-permalink" href="#ss_rep" title="Permalink"></a></h2><p>We introduce a type <code>GradedSpace</code> to represent general objects of a fusion category, which can be decomposed as a direct sum of simple objects represented by <code>Sector</code>:</p><pre><code class="language-julia hljs">struct GradedSpace{I&lt;:Sector, D} &lt;: EuclideanSpace{ℂ}
    dims::D
    dual::Bool
end</code></pre><p>Here, <code>D</code> is a type parameter to denote the data structure used to store the degeneracy or multiplicity dimensions <span>$n_a$</span> of the different sectors.</p><h3 id="Implementation-details"><a class="docs-heading-anchor" href="#Implementation-details">Implementation details</a><a id="Implementation-details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-details" title="Permalink"></a></h3><p>The way in which the degeneracy dimensions <span>$n_a$</span> are stored depends on the <code>IteratorSize</code> of <code>values(I)</code>. If it is <code>Union{IsInfinite, SizeUnknown}</code>, the sectors <span>$a$</span>and their corresponding degeneracy <span>$n_a$</span> are stored as key value pairs in a dictionary <code>dims::SectorDict</code>. Only sectors <span>$a$</span> for which <span>$n_a\neq 0$</span> are stored. Here, <code>SectorDict</code> is a constant type alias for a specific dictionary implementation, which currently resorts to <code>SortedVectorDict</code> implemented in TensorLabXD.jl. Hence, the sectors and their corresponding dimensions are stored as two matching lists (<code>Vector</code> instances), which are ordered based on the property <code>isless(a::I, b::I)</code>. This ensures that the space <span>$V = ⨁_a ℂ^{n_a} ⊗ R_{a}$</span> has some unique canonical order in the direct sum decomposition.</p><p>If <code>IteratorSize(values(I)) isa Union{HasLength, HasShape}</code>, the degeneracy dimensions <span>$n_a$</span> are stored for all sectors <code>a ∈ values(I)</code> in a tuple <code>NTuple{N, Int}</code> with <code>N = length(values(I))</code>. The methods <code>getindex(values(I), i)</code> and <code>findindex(values(I), a)</code> are used to map between a sector <code>a ∈ values(I)</code> and a corresponding index <code>i ∈ 1:N</code>. As <code>N</code> is a compile time constant, these types can be created in a type stable manner.</p><h3 id="Constructing-instances"><a class="docs-heading-anchor" href="#Constructing-instances">Constructing instances</a><a id="Constructing-instances-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-instances" title="Permalink"></a></h3><p>The method <code>Vect[I]</code> will return the concrete type <code>GradedSpace{I,D}</code> with the matching value of <code>D</code>. For consistency, <code>Vect[Trivial]</code> will just return a <code>ComplexSpace</code>, which is not even a type of <code>GradedSpace</code>. There is also the Unicode alias <code>ℂ[I]</code>, and for the case of group irreps as sectors, one can use <code>Rep[G]</code> with <code>G</code> the group, as inspired by the categorical name <span>$\mathbf{Rep}_{\mathsf{G}}$</span>.</p><p>Some illustrations:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℂ[]</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℂ[Trivial]</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[Trivial]</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[U1Irrep]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{U1Irrep,TensorLabXD.SortedVectorDict{U1Irrep,Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ℂ[Irrep[U₁]]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{U1Irrep,TensorLabXD.SortedVectorDict{U1Irrep,Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rep[U₁]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{U1Irrep,TensorLabXD.SortedVectorDict{U1Irrep,Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rep[ℤ₂ × SU₂]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{TensorLabXD.ProductSector{Tuple{ZNIrrep{2},SU2Irrep}},TensorLabXD.SortedVectorDict{TensorLabXD.ProductSector{Tuple{ZNIrrep{2},SU2Irrep}},Int64}}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[Irrep[ℤ₂ × SU₂]]</code><code class="nohighlight hljs ansi" style="display:block;">GradedSpace{TensorLabXD.ProductSector{Tuple{ZNIrrep{2},SU2Irrep}},TensorLabXD.SortedVectorDict{TensorLabXD.ProductSector{Tuple{ZNIrrep{2},SU2Irrep}},Int64}}</code></pre><p>For some groups we have a number of alias, both in ASCII and using Unicode:</p><pre><code class="language-julia hljs"># ASCII type aliases
const ZNSpace{N} = GradedSpace{ZNIrrep{N}, NTuple{N,Int}}
const Z2Space = ZNSpace{2}
const Z3Space = ZNSpace{3}
const Z4Space = ZNSpace{4}
const U1Space = Rep[U₁]
const CU1Space = Rep[CU₁]
const SU2Space = Rep[SU₂]

# Unicode alternatives
const ℤ₂Space = Z2Space
const ℤ₃Space = Z3Space
const ℤ₄Space = Z4Space
const U₁Space = U1Space
const CU₁Space = CU1Space
const SU₂Space = SU2Space</code></pre><p>To create specific instances of those types, one can e.g. use <code>V = GradedSpace(a=&gt;n_a, b=&gt;n_b, c=&gt;n_c)</code> or <code>V = GradedSpace(iterator)</code> where <code>iterator</code> is any iterator (e.g. a dictionary or a generator) that yields <code>Pair{I,Int}</code> instances. With those constructions, <code>I</code> is inferred from the type of sectors. It is often more convenient to specify the sector type explicitly (using one of the many alias provided), since then the sectors are automatically converted to the correct type; compare</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Vect[Irrep[U₁]](0=&gt;3, 1=&gt;2, -1=&gt;1) ==
           GradedSpace(U1Irrep(0)=&gt;3, U1Irrep(1)=&gt;2, U1Irrep(-1)=&gt;1) == U1Space(0=&gt;3, 1=&gt;2, -1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>The <code>Rep[G]</code> also works with product groups:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rep[ℤ₂ × SU₂]((0,0) =&gt; 3, (1,1/2) =&gt; 2, (0,1) =&gt; 1) == GradedSpace((Z2Irrep(0) ⊠ SU2Irrep(0)) =&gt; 3, (Z2Irrep(1) ⊠ SU2Irrep(1/2)) =&gt; 2, (Z2Irrep(0) ⊠ SU2Irrep(1)) =&gt; 1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h3 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h3><p>There are a number of methods to work with instances <code>V</code> of <code>GradedSpace</code>.</p><p>The function <a href="man/@ref"><code>sectors</code></a> returns an iterator over the different sectors <code>a</code> with non-zero <code>n_a</code>, and for other <code>ElementarySpace</code> types it returns <code>(Trivial(),)</code>.</p><p>The degeneracy dimensions <code>n_a</code> can be extracted as <code>dim(V, a)</code>, it properly returns <code>0</code> if sector <code>a</code> is not present in the decomposition of <code>V</code>.</p><p>With <a href="man/@ref"><code>hassector(V, a)</code></a> one can check if <code>V</code> contains a sector <code>a</code> with <code>dim(V,a)&gt;0</code>.</p><p>The <code>dim(V)</code> returns the total dimension of the space <code>V</code>, i.e. <span>$∑_a n_a d_a$</span>.</p><p>If a representation space <code>V</code> has certain sectors <code>a</code> with dimensions <code>n_a</code>, then its dual <code>V&#39;</code> will have sectors <code>dual(a)</code>, and <code>dim(V&#39;, dual(a)) == n_a</code>.</p><p>Other methods for <code>ElementarySpace</code>, such as <a href="man/@ref"><code>dual</code></a>, <a href="man/@ref"><code>fuse</code></a> and <a href="man/@ref"><code>flip</code></a> also work. In fact, <code>GradedSpace</code> is the reason <code>flip</code> exists. The existence of flip originates from the non-trivial isomorphism between <span>$R_{\overline{a}}$</span> and <span>$R_{a}^*$</span>, i.e. the representation space of the dual <span>$\overline{a}$</span> of sector <span>$a$</span> and the dual of the representation space of sector <span>$a$</span>. If <code>V = GradedSpace(a=&gt;n_a,...)</code>, then <code>flip(V) = dual(GradedSpace(dual(a)=&gt;n_a,....))</code>. Hence, <code>flip(V)</code> to be isomorphic to <code>V</code>.</p><p>For two spaces <code>V1 = GradedSpace(a=&gt;n1_a, ...)</code> and <code>V2 = GradedSpace(a=&gt;n2_a, ...)</code>, we have <code>infimum(V1,V2) = GradedSpace(a=&gt;min(n1_a,n2_a), ....)</code> and similarly for <code>supremum</code>. They act on the degeneracy dimensions of every sector separately. Therefore, it can be that the return value of <code>infimum(V1,V2)</code> or <code>supremum(V1,V2)</code> is neither equal to <code>V1</code> or <code>V2</code>.</p><p>For <code>W</code> a <code>ProductSpace{Vect[I], N}</code>, <a href="man/@ref"><code>sectors(W)</code></a> returns an iterator that generates all possible combinations of sectors <code>as</code> represented as <code>NTuple{I,N}</code>. The function <a href="man/@ref"><code>dims(W, as)</code></a> returns the corresponding tuple with degeneracy dimensions, while <a href="man/@ref"><code>dim(W, as)</code></a> returns the product of these dimensions. <a href="man/@ref"><code>hassector(W, as)</code></a> is equivalent to <code>dim(W, as)&gt;0</code>. The function <a href="man/@ref"><code>blocksectors(W)</code></a> which returns a list (of type <code>Vector</code>) with all possible &quot;block sectors&quot; that can result from fusing the individual uncoupled sectors in <code>W</code>. Correspondingly, <a href="man/@ref"><code>blockdim(W, a)</code></a> counts the total degeneracy dimension of the coupled sector <code>a</code> in <code>W</code>.</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>Let&#39;s start with an example involving <span>$\mathsf{U}_1$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = Rep[U₁](0=&gt;3, 1=&gt;2, -1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](0=&gt;3, 1=&gt;2, -1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 == U1Space(0=&gt;3, 1=&gt;2, -1=&gt;1) == U₁Space(-1=&gt;1, 1=&gt;2,0=&gt;3) # order doesn&#39;t matter</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (sectors(V1)...,)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[U₁](0), Irrep[U₁](1), Irrep[U₁](-1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1, U1Irrep(1))</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1&#39;, Irrep[U₁](1)) == dim(V1, conj(U1Irrep(1))) == dim(V1, U1Irrep(-1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(V1, Irrep[U₁](1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(V1, Irrep[U₁](2))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(V1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](0=&gt;3, 1=&gt;2, -1=&gt;1)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(V1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](0=&gt;3, 1=&gt;1, -1=&gt;2)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(V1) ≅ V1</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(V1) ≅ V1</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = U1Space(0=&gt;2, 1=&gt;1, -1=&gt;1, 2=&gt;1, -2=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](0=&gt;2, 1=&gt;1, -1=&gt;1, 2=&gt;1, -2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; infimum(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](0=&gt;2, 1=&gt;1, -1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](0=&gt;3, 1=&gt;2, -1=&gt;1, 2=&gt;1, -2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ⊕(V1,V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](0=&gt;5, 1=&gt;3, -1=&gt;2, 2=&gt;1, -2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W = ⊗(V1,V2)</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[U₁](0=&gt;3, 1=&gt;2, -1=&gt;1) ⊗ Rep[U₁](0=&gt;2, 1=&gt;1, -1=&gt;1, 2=&gt;1, -2=&gt;1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(sectors(W))</code><code class="nohighlight hljs ansi" style="display:block;">3×5 Array{Tuple{Any,Any},2}:
 (Irrep[U₁](0), Irrep[U₁](0))   …  (Irrep[U₁](0), Irrep[U₁](-2))
 (Irrep[U₁](1), Irrep[U₁](0))      (Irrep[U₁](1), Irrep[U₁](-2))
 (Irrep[U₁](-1), Irrep[U₁](0))     (Irrep[U₁](-1), Irrep[U₁](-2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dims(W, (Irrep[U₁](0), Irrep[U₁](0)))</code><code class="nohighlight hljs ansi" style="display:block;">(3, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(W, (Irrep[U₁](0), Irrep[U₁](0)))</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(W, (Irrep[U₁](0), Irrep[U₁](0)))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(W, (Irrep[U₁](2), Irrep[U₁](0)))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fuse(W)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[U₁](0=&gt;9, 1=&gt;8, -1=&gt;7, 2=&gt;5, -2=&gt;4, 3=&gt;2, -3=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (blocksectors(W)...,)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[U₁](0), Irrep[U₁](1), Irrep[U₁](-1), Irrep[U₁](2), Irrep[U₁](-2), Irrep[U₁](3), Irrep[U₁](-3))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; blockdim(W, Irrep[U₁](0))</code><code class="nohighlight hljs ansi" style="display:block;">9</code></pre><p>and then with <span>$\mathsf{SU}_2$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = ℂ[Irrep[SU₂]](0=&gt;3, 1//2=&gt;2, 1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](0=&gt;3, 1/2=&gt;2, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 == SU2Space(0=&gt;3, 1/2=&gt;2, 1=&gt;1) == SU₂Space(0=&gt;3, 0.5=&gt;2, 1=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (sectors(V1)...,)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[SU₂](0), Irrep[SU₂](1/2), Irrep[SU₂](1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1, SU2Irrep(1))</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1&#39;, SU2Irrep(1)) == dim(V1, conj(SU2Irrep(1))) == dim(V1, Irrep[SU₂](1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1)</code><code class="nohighlight hljs ansi" style="display:block;">10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(V1, Irrep[SU₂](1))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(V1, Irrep[SU₂](2))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(V1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](0=&gt;3, 1/2=&gt;2, 1=&gt;1)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(V1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](0=&gt;3, 1/2=&gt;2, 1=&gt;1)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = SU2Space(0=&gt;2, 1//2=&gt;1, 1=&gt;1, 3//2=&gt;1, 2=&gt;1)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](0=&gt;2, 1/2=&gt;1, 1=&gt;1, 3/2=&gt;1, 2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; infimum(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](0=&gt;2, 1/2=&gt;1, 1=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum(V1, V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](0=&gt;3, 1/2=&gt;2, 1=&gt;1, 3/2=&gt;1, 2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ⊕(V1,V2)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](0=&gt;5, 1/2=&gt;3, 1=&gt;2, 3/2=&gt;1, 2=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W = ⊗(V1,V2)</code><code class="nohighlight hljs ansi" style="display:block;">(Rep[SU₂](0=&gt;3, 1/2=&gt;2, 1=&gt;1) ⊗ Rep[SU₂](0=&gt;2, 1/2=&gt;1, 1=&gt;1, 3/2=&gt;1, 2=&gt;1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(sectors(W))</code><code class="nohighlight hljs ansi" style="display:block;">3×5 Array{Tuple{Any,Any},2}:
 (Irrep[SU₂](0), Irrep[SU₂](0))    …  (Irrep[SU₂](0), Irrep[SU₂](2))
 (Irrep[SU₂](1/2), Irrep[SU₂](0))     (Irrep[SU₂](1/2), Irrep[SU₂](2))
 (Irrep[SU₂](1), Irrep[SU₂](0))       (Irrep[SU₂](1), Irrep[SU₂](2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dims(W, (Irrep[SU₂](0), Irrep[SU₂](0)))</code><code class="nohighlight hljs ansi" style="display:block;">(3, 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(W, (Irrep[SU₂](0), Irrep[SU₂](0)))</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(W, (SU2Irrep(0), SU2Irrep(0)))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; hassector(W, (SU2Irrep(2), SU2Irrep(0)))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fuse(W)</code><code class="nohighlight hljs ansi" style="display:block;">Rep[SU₂](0=&gt;9, 1/2=&gt;11, 1=&gt;11, 3/2=&gt;9, 2=&gt;7, 5/2=&gt;3, 3=&gt;1)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (blocksectors(W)...,)</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[SU₂](0), Irrep[SU₂](1/2), Irrep[SU₂](1), Irrep[SU₂](3/2), Irrep[SU₂](2), Irrep[SU₂](5/2), Irrep[SU₂](3))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; blockdim(W, SU2Irrep(0))</code><code class="nohighlight hljs ansi" style="display:block;">9</code></pre><h2 id="ss_fusiontrees"><a class="docs-heading-anchor" href="#ss_fusiontrees">Fusion trees</a><a id="ss_fusiontrees-1"></a><a class="docs-heading-anchor-permalink" href="#ss_fusiontrees" title="Permalink"></a></h2><p>The gain in efficiency obtained from using symmetric equivariant tensor maps is that, by Schur&#39;s lemma, they are block diagonal in the basis of coupled sectors. To exploit this block diagonal form, it is essential that we know the basis transform from the individual uncoupled sectors appearing in the tensor product form of the domain and codomain, to the totally coupled sectors that label the different blocks.</p><p>The basis of the map from <span>$R_c$</span> to <span>$R_{a_1} ⊗ R_{a_2} ⊗ … ⊗ R_{a_N}$</span> are written as <span>$X^{a_1a_2…a_N}_{c,α}: R_c → R_{a_1} ⊗ R_{a_2} ⊗ … ⊗ R_{a_N}$</span>, which satisfy</p><p><span>$(X^{a_1a_2…a_N}_{c,α})^† ∘ X^{a_1a_2…a_N}_{c′,α′} = δ_{c,c′} δ_{α,α′} \mathrm{id}_c$</span></p><p>and</p><p><span>$∑_{c,α} X^{a_1a_2…a_N}_{c,α} ∘ (X^{a_1a_2…a_N}_{c,α})^†  = \mathrm{id}_{a_1 ⊗ a_2 ⊗ … ⊗ a_N} = \mathrm{id}_{a_1} ⊗ \mathrm{id}_{a_2} ⊗ … ⊗ \mathrm{id}_{a_N}$</span></p><p>Fusion-splitting trees provide a particular way to construct such a basis. The following subsections discuss the canonical representation of fusion-splitting trees and possible manipulations that can be performed.</p><h3 id="Canonical-representation"><a class="docs-heading-anchor" href="#Canonical-representation">Canonical representation</a><a id="Canonical-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Canonical-representation" title="Permalink"></a></h3><p>In the canonical representation of a tensor map, the domain takes the form <span>$(((W_1 ⊗ W_2) ⊗ W_3) ⊗ … )⊗ W_{N_2})$</span>, and the codomain takes the form <span>$(((V_1 ⊗ V_2) ⊗ V_3) ⊗ … )⊗ V_{N_1})$</span>.</p><p>Graphically, a fusion-splitting tree representation of a tensor map with <span>$N_1=4$</span> and <span>$N_2=3$</span> is</p><p><img src="../img/tree-simple.svg" alt="double fusion tree"/></p><p>We can separate this tree into the fusion part <span>$((b_1⊗b_2)⊗b_3) → c$</span> and the splitting part <span>$c→(((a_1⊗a_2)⊗a_3)⊗a_4)$</span>. The fusion tree can be considered to be the adjoint of a splitting tree <span>$c→((b_1⊗b_2)⊗b_3)$</span>.</p><p>A splitting tree which goes from one coupled sector <span>$c$</span> to <span>$N$</span> uncoupled sectors <span>$a_1$</span>, <span>$a_2$</span>, …,<span>$a_N$</span> needs <span>$N-2$</span> additional labels <span>$e_1$</span>, …, <span>$e_{N-2}$</span> to represent the sectors of the internal lines. If <code>FusionStyle(I) isa UniqueFusion</code>, the internal sectors are completely fixed by the coupled and uncoupled sectors. If <code>FusionStyle(I) isa MultipleFusion</code>, they can take different values that satisfy the fusion rules.</p><p>If <code>FusionStyle(I) isa GenericFusion</code>, we also need <span>$N-1$</span> additional labels <span>$μ_1$</span>, …, <span>$μ_{N-1}$</span> on vertices of the splitting tree to represent the multiplicity of the fusion rule.</p><p>In our notation of the splitting basis <span>$X^{a_1a_2…a_N}_{c,α}$</span> used above, <span>$α$</span> is a collective label, i.e. <span>$α = (e_1, …, e_{N-2}; μ₁, … ,μ_{N-1})$</span>. The orthogonality condition <span>$(X^{a_1a_2…a_N}_{c,α})^† ∘ X^{a_1a_2…a_N}_{c′,α′} = δ_{c,c′} δ_{α,α′} \mathrm{id}_c$</span>, forces all internal lines <span>$e_k$</span> and vertex labels <span>$μ_l$</span> to be the same.</p><p>We represent splitting trees by a specific immutable type called <code>FusionTree</code>, defined as</p><pre><code class="language-julia hljs">struct FusionTree{I&lt;:Sector,N,M,L,T}
    uncoupled::NTuple{N,I}
    coupled::I
    isdual::NTuple{N,Bool}
    innerlines::NTuple{M,I} # M = N-2
    vertices::NTuple{L,T} # L = N-1
end</code></pre><p>The <code>uncoupled</code> field is a list of <span>$N$</span> outgoing uncoupled sectors of the splitting tree in sequence <span>$a_1,a_2,...,a_N$</span>.</p><p>The <code>coupled</code> field is the single input sector of the splitting tree.</p><p>The <code>isdual</code> field indicates whether an isomorphism <span>$Z$</span> is present or not for each uncoupled sectors. The presence of these isomorphisms will be important when we start to bend lines, e.g., to move uncoupled sectors from the incoming to the outgoing part of the fusion-splitting tree. In category language, <span>$a^*$</span> is the dual space of <span>$a$</span> on which the conjugated irrep acts, while <span>$\bar{a}$</span> is the space in the chosen set of simple objects and the corresponding irrep on it is isomorphic to the complex conjugate of irrep on <span>$a$</span>. In our package, we define <code>dual(a)</code> as <span>$\bar{a}$</span>. To obtain <span>$a^*$</span>, we need use the isomorphisms <span>$Z_a: a^* → \bar{a}$</span> and its adjoint <span>$Z_a^†:\bar{a}→a^*$</span>.</p><p>Note that the field <code>uncoupled</code> contains the sectors coming out of the splitting trees <strong>before</strong> the possible <span>$Z$</span> isomorphism. For example, the splitting tree in the following graph has <code>uncoupled = (a₁, a₂, a₃, a₄)</code>:</p><p><img src="../img/tree-extended.svg" alt="extended double fusion tree"/></p><p>Note that we can still represent a fusion tree as the adjoint of its corresponding splitting tree, since we use the <span>$Z$</span> isomorphism in the fusion part, and the <span>$Z^{\dagger}$</span> isomorphisms in the splitting part. The presence of the <span>$Z$</span> isomorphisms do not affect the orthonormality since <span>$Z_a^{\dagger} \circ Z_a = \mathrm{id}_{a^*}$</span> and <span>$Z_a\circ Z_a^{\dagger} = \mathrm{id}_{\bar{a}}$</span>.</p><p>The <code>innerlines</code> is a list of sectors on the inner lines of the splitting tree in the order that follows the sequence of the fusion. For example, the first inner line is the fusion of the first two uncoupled sector, and the second inner line is the fusion of the first inner line and the third uncoupled sector.</p><p>The <code>vertices</code> is a list of labels on the vertices of the splitting tree in the order that follows the sequence of the fusion. For example, the first vertex label is the label for the fusion of the first two uncoupled sector, and the second vertex label is the label for fusion of the first inner line and the third uncoupled sector.</p><p>The type <code>T</code> of the vertex labels is defined by the function <code>vertex_ind2label</code> for the sector <code>I</code>, and can be <code>Nothing</code> when <code>FusionStyle(I) isa MultiplicityFreeFusion</code>.</p><p>The <code>FusionTree</code> type has a number of basic properties and capabilities, such as checking for equality with <code>==</code> and support for <code>hash(f::FusionTree, h::UInt)</code>, as splitting and fusion trees are used as keys in <code>AbstractDictionary</code> instances to look up certain parts of the data of a tensor map.</p><p>The <code>FusionTree</code> instances are not checked for consistency (i.e. valid fusion rules etc) upon creation, hence, they are assumed to be created correctly. They can be created by the method</p><pre><code class="language-julia hljs">fusiontrees(uncoupled::NTuple{N, I}, coupled::I = one(I),
    isdual::NTuple{N, Bool} = ntuple(n-&gt;false, Val(N))) where {N, I&lt;:Sector}</code></pre><p>which returns an iterator <code>FusionTreeIterator</code> over all possible splitting trees with fixed uncoupled and coupled sectors. The <code>FusionTreeIterator</code> conforms to the complete interface of an iterator, and has a custom <code>length</code> function that computes the number of possible fusion trees without iterating over all of them explicitly. For example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = Irrep[SU₂](1/2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU₂](1/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(fusiontrees((s,s,s,s)))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Array{FusionTree{SU2Irrep,4,2,3,Nothing},1}:
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 0, (false, false, false, false), (0, 1/2))
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 0, (false, false, false, false), (1, 1/2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(fusiontrees((s,s,s,s,s), s, (true, false, false, true, false)))</code><code class="nohighlight hljs ansi" style="display:block;">5-element Array{FusionTree{SU2Irrep,5,3,4,Nothing},1}:
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (0, 1/2, 0))
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (0, 1/2, 1))
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (1, 1/2, 0))
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (1, 1/2, 1))
 FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2, 1/2), 1/2, (true, false, false, true, false), (1, 3/2, 1))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iter = fusiontrees(ntuple(n-&gt;s, 16))</code><code class="nohighlight hljs ansi" style="display:block;">TensorLabXD.FusionTreeIterator{SU2Irrep,16}((Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2)), Irrep[SU₂](0), (false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sum(n-&gt;1, iter)</code><code class="nohighlight hljs ansi" style="display:block;">1430</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; length(iter)</code><code class="nohighlight hljs ansi" style="display:block;">1430</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @elapsed sum(n-&gt;1, iter)</code><code class="nohighlight hljs ansi" style="display:block;">0.041119798</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @elapsed length(iter)</code><code class="nohighlight hljs ansi" style="display:block;">8.7101e-5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; s2 = s ⊠ s</code><code class="nohighlight hljs ansi" style="display:block;">(Irrep[SU₂](1/2) ⊠ Irrep[SU₂](1/2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(fusiontrees((s2,s2,s2,s2)))</code><code class="nohighlight hljs ansi" style="display:block;">4-element Array{FusionTree{TensorLabXD.ProductSector{Tuple{SU2Irrep,SU2Irrep}},4,2,3,Nothing},1}:
 FusionTree{Irrep[SU₂ × SU₂]}(((1/2, 1/2), (1/2, 1/2), (1/2, 1/2), (1/2, 1/2)), (0, 0), (false, false, false, false), ((0, 0), (1/2, 1/2)))
 FusionTree{Irrep[SU₂ × SU₂]}(((1/2, 1/2), (1/2, 1/2), (1/2, 1/2), (1/2, 1/2)), (0, 0), (false, false, false, false), ((1, 0), (1/2, 1/2)))
 FusionTree{Irrep[SU₂ × SU₂]}(((1/2, 1/2), (1/2, 1/2), (1/2, 1/2), (1/2, 1/2)), (0, 0), (false, false, false, false), ((0, 1), (1/2, 1/2)))
 FusionTree{Irrep[SU₂ × SU₂]}(((1/2, 1/2), (1/2, 1/2), (1/2, 1/2), (1/2, 1/2)), (0, 0), (false, false, false, false), ((1, 1), (1/2, 1/2)))</code></pre><p>Note that <code>FusionTree</code> instances are shown in a way that can be copy pasted as valid code. We use contact to determine how to print a sector. In isolation, <code>s2</code> is printed as <code>(Irrep[SU₂](1/2) ⊠ Irrep[SU₂](1/2))</code>. Within the fusion tree, it is printed as <code>(1/2, 1/2)</code>, because it will be converted back into a <code>ProductSector</code>, namely <code>Irrep[SU₂] ⊠ Irrep[SU₂]</code> by the constructor of <code>FusionTree{Irrep[SU₂] ⊠ Irrep[SU₂]}</code>.</p><h3 id="Planar-manipulations-on-a-splitting-tree"><a class="docs-heading-anchor" href="#Planar-manipulations-on-a-splitting-tree">Planar manipulations on a splitting tree</a><a id="Planar-manipulations-on-a-splitting-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Planar-manipulations-on-a-splitting-tree" title="Permalink"></a></h3><p>We now discuss elementary planar manipulations (without braiding) on splitting trees. These manipulations are used as low-level methods by the <code>TensorMap</code> methods. As such, they are not exported by <code>TensorLabXD.jl</code>, nor do they overload similarly named methods from <code>Base</code>.</p><pre><code class="language-julia hljs">split(f::FusionTree{I,N}, M::Int)</code></pre><p>Split a fusion tree <code>f</code> into two trees <code>f1</code> and <code>f2</code> such that <code>f1</code> has the first <code>M</code> uncoupled sectors of <code>f</code> and <code>f2</code> has the remaining <code>N-M</code> uncoupled sectors of <code>f</code>. This function is type stable if <code>M</code> is a compile time constant. Diagrammatically, for example, <code>M=4</code>:</p><p><img src="../img/tree-split.svg" alt="split"/></p><pre><code class="language-julia hljs">insertat(f1::FusionTree{I,N₁}, i::Int, f2::FusionTree{I,N₂})</code></pre><p>Insert a fusion tree <code>f2</code> at the <code>i</code>th uncoupled sector of fusion tree <code>f1</code> and recouple this into a linear combination of trees in canonical form with <code>N₁+N₂-1</code> uncoupled sectors. This requires that the coupled sector <code>f2</code> matches with the <code>i</code>th uncoupled sector of <code>f1</code>, and that <code>f1.isdual[i] == false</code>, i.e. that there is no <span>$Z$</span>-isomorphism on the <code>i</code>th uncoupled sector of <code>f1</code>. Diagrammatically, for example, <code>i=3</code>:</p><p><img src="../img/tree-insertat.svg" alt="insertat"/></p><pre><code class="language-julia hljs">merge(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, c::I, μ=nothing)</code></pre><p>Merge two fusion trees <code>f1</code> and <code>f2</code> by fusing the coupled sectors of <code>f1</code> and <code>f2</code> into a sector <code>c</code> with vertex label <code>μ</code> and reexpressing the result as a linear combination of fusion trees with <code>N₁+N₂</code> uncoupled sectors in canonical form. Diagrammatically, it is:</p><p><img src="../img/tree-merge.svg" alt="merge"/></p><pre><code class="language-julia hljs">elementary_trace(f::FusionTree{I, N}, i) where {I&lt;:Sector, N}</code></pre><p>Take the trace of the <span>$i$</span>th and <span>$(i+1~\mathrm{mod}~N)$</span>th outgoing sectors of the splitting tree <code>f</code> by an evaluation map. Diagrammatically, it is:</p><p><img src="../img/tree-elementary-trace.svg" alt="elementary-trace"/></p><pre><code class="language-julia hljs">planar_trace(f::FusionTree{I,N},q1::IndexTuple{N₃},
                q2::IndexTuple{N₃}) where {I&lt;:Sector, N, N₃}</code></pre><p>Take the traces between <code>q1[k]</code>th and <code>q2[k]</code>th sector of the splitting tree <code>f</code>, where <code>1&lt;=k&lt;=N₃</code>. All the traces must be planar, i.e., no tracing lines cross with the outgoing lines nor cross with each other. Diagrammatically, for example, <code>q1 = (1,4,5)</code> and <code>q2 = (2,7,6)</code>:</p><p><img src="../img/tree-planar-trace-splitting.svg" alt="planar-trace-splitting"/></p><h3 id="Planar-manipulations-on-a-fusion-splitting-tree"><a class="docs-heading-anchor" href="#Planar-manipulations-on-a-fusion-splitting-tree">Planar manipulations on a fusion-splitting tree</a><a id="Planar-manipulations-on-a-fusion-splitting-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Planar-manipulations-on-a-fusion-splitting-tree" title="Permalink"></a></h3><p>A fusion-splitting tree can be represented by two separate splitting trees <code>f1</code> and <code>f2</code>, where <code>f1</code> represents the splitting part and <code>f2</code> represents the fusion part. Note the <code>f2</code> is still a splitting tree, i.e., an instance of the <code>FusionTree</code> type, and the true fusion tree is the adjoint of it. We should always have <code>f1.coupled == f2.coupled</code>.</p><p>The order of the sectors in a fusion-splitting trees is <code>(f1.uncoupled..., f2.uncoupled...)</code>. In other words, we label the uncoupled sectors of <code>f1</code> from <code>1</code> to <code>N₁</code>, followed by the uncoupled sectors of <code>f2</code> from <code>N₁+1</code> to <code>N₁+N₂</code>.</p><p>By successively applying the left coevaluation maps, we can establish isomorphisms between</p><p><span>$\mathrm{Hom}((((b_1 ⊗ b_2) ⊗ …) ⊗ b_{N_2}), (((a_1 ⊗ a_2) ⊗ …) ⊗ a_{N_1}))$</span></p><p><span>$≂ \mathrm{Hom}((((b_1 ⊗ b_2) ⊗ ...) ⊗ b_{N_2-1}), ((((a_1 ⊗ a_2) ⊗ ...) ⊗ a_{N_1}) ⊗ b_{N_2}^*))$</span></p><p><span>$≂ \mathrm{Hom}(1, (((((((a_1 ⊗ a_2) ⊗ ...) ⊗ a_{N_1}) ⊗ b_{N_2}^*) ⊗ …) ⊗ b_2^*) ⊗ b_1^*) )$</span></p><p>where the last morphism space is labeled by the basis of only splitting trees. We can then use the manipulations from the previous subsection on the splitting trees, and then again use the left evaluation maps to bring this back to a fusion-splitting tree with <code>N₂′</code> incoming and <code>N₁′</code> outgoing sectors (with <code>N₁′ + N₂′ == N₁ + N₂</code>).</p><p>To realize this process using this package, we first need to fix the relations between the between the (co)evaluation maps and the fusion tensors.</p><p><img src="../img/tree-coevaluation-to-fusion.svg" alt="coevaluation to fusion"/></p><p>Then, applying the right evaluation on the second uncoupled sector of a splitting tensor thus yields a linear combination of fusion tensors with corresponding <span>$Z$</span> ismorphism:</p><p><img src="../img/tree-linebending.svg" alt="line bending"/></p><p>If we bend a line on which a <span>$Z$</span> isomorphism is already present, we obtain the relation</p><p><img src="../img/tree-linebending2.svg" alt="dual line bending"/></p><p>Hence, bending an <code>isdual</code> sector from the splitting tree to the fusion tree yields an additional Frobenius-Schur factor, and leads to a normal sector on the fusion side.</p><p>On a general fusion-splitting tree, we have some functions to bend the lines:</p><pre><code class="language-julia hljs">bendright(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}) where {I&lt;:Sector, N₁, N₂}</code></pre><p>which bends the last uncoupled space of the splitting tress <code>f1</code> upward from right hand side to be the last uncoupled space of new fusion tree constructed from <code>f2</code>. That is, map final splitting vertex <code>c → (a, b)</code> of <code>f1</code> to fusion vertex <code>(c, dual(b)) → a</code>. Graphically:</p><p><img src="../img/tree-bendright.svg" alt="line bendright"/></p><p>Taking the adjoint we get a related function:</p><pre><code class="language-julia hljs">bendleft(f1::FusionTree{I}, f2::FusionTree{I}) where I</code></pre><p>which bends the last uncoupled space of fusion tree <code>f2</code> downward from right hand side to be the last uncoupled space of the splitting tree constructed from <code>f1</code>. That is, map final fusion vertex <code>(a, b) → c</code> of <code>f2</code> to splitting vertex <code>a → (c, dual(b))</code>.</p><p>We could also bend the lines from the left hand side:</p><pre><code class="language-julia hljs">foldright(f1::FusionTree{I, N₁}, f2::FusionTree{I, N₂}) where {I&lt;:Sector, N₁, N₂}</code></pre><p>which bends the first uncoupled space of the splitting tree <code>f1</code> upward from left hand side to be the first uncoupled space of new fusion tree constructed from <code>f2</code>. That is, map first splitting vertex <code>c → (a, b)</code> of <code>f1</code> to fusion vertex <code>(dual(a), c) → b</code>. Graphically:</p><p><img src="../img/tree-foldright.svg" alt="line foldright"/></p><p>Taking the adjoint we get a related function</p><pre><code class="language-julia hljs">foldleft(f1::FusionTree{I}, f2::FusionTree{I}) where I</code></pre><p>which bends the first uncoupled space of the fusion tree <code>f2</code> downward from left hand side to be the first uncoupled space of new splitting tree constructed from <code>f1</code>. That is, map first fusion vertex <code>(a, b) → c</code> of <code>f2</code> to splitting vertex <code>b → (dual(a), c)</code>.</p><p>The cyclic permutations of all lines of a fusion-splitting tree can be realized through the bending of lines:</p><pre><code class="language-julia hljs">cycleclockwise(f1::FusionTree{I}, f2::FusionTree{I}) where {I&lt;:Sector}</code></pre><p>which is clockwise cyclic permutation with one <code>foldright</code> and one <code>bendleft</code>.</p><pre><code class="language-julia hljs">cycleanticlockwise(f1::FusionTree{I}, f2::FusionTree{I}) where {I&lt;:Sector}</code></pre><p>which is anticlockwise cyclic permutation with one <code>foldleft</code> and one <code>bendright</code>.</p><p>A more general function for repartition of incoming and outgoing sectors is given by</p><pre><code class="language-julia hljs">repartition(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, N::Int)</code></pre><p>which takes a splitting tree <code>f1</code> with <code>N₁</code> outgoing sectors, a fusion tree <code>f2</code> with <code>N₂</code> incoming sectors, and applies line bending such that the resulting fusion-splitting trees have <code>N</code> outgoing sectors, corresponding to the first <code>N</code> sectors out of the list <span>$(a_1, a_2, …, a_{N_1}, b_{N_2}^*, …, b_{1}^*)$</span> and <code>N₁+N₂-N</code> incoming sectors, corresponding to the dual of the last <code>N₁+N₂-N</code> sectors from the previous list in reverse order. This return values are correctly inferred if <code>N</code> is a compile time constant.</p><p>Graphically, for <code>N₁ = 4</code>, <code>N₂ = 3</code>, <code>N = 2</code> and some particular choice of <code>isdual</code> in both the fusion and splitting tree:</p><p><img src="../img/tree-repartition.svg" alt="repartition"/></p><p>The result is returned as a dictionary with keys <code>(f1′, f2′)</code> and the corresponding <code>coeff</code> as value. Note that the summation is only over the <span>$κ_j$</span> labels, such that, in the case of <code>FusionStyle(I) isa MultiplicityFreeFusion</code>, the linear combination simplifies to a single term with a scalar coefficient.</p><p>The transpose of the fusion-splitting tree that can be realized by repartition and cyclic permutations without braiding is given by</p><pre><code class="language-julia hljs">transpose(f1::FusionTree{I}, f2::FusionTree{I},
        p1::NTuple{N₁, Int}, p2::NTuple{N₂, Int}) where {I, N₁, N₂}</code></pre><p>which computes new trees and corresponding coefficients obtained from repartitioning and permuting the tree such that sectors <code>p1</code> become outgoing and sectors <code>p2</code> become incoming. It is required that the linearized permutation is cyclic to avoid braiding.</p><p>The general planar trace of a fusion-splitting tree is given by</p><pre><code class="language-julia hljs">planar_trace(f1::FusionTree{I}, f2::FusionTree{I},
            p1::IndexTuple{N₁}, p2::IndexTuple{N₂},
            q1::IndexTuple{N₃}, q2::IndexTuple{N₃}) where {I&lt;:Sector, N₁, N₂, N₃}</code></pre><p>which takes the traces between <code>q1[k]</code>th and <code>q2[k]</code>th sector of the fusion-splitting tree and then transposes according to <code>p1</code> and <code>p2</code>. We need to make sure that the traces are planar without any crossings between lines.</p><h3 id="Braiding-manipulations-on-a-splitting-tree"><a class="docs-heading-anchor" href="#Braiding-manipulations-on-a-splitting-tree">Braiding manipulations on a splitting tree</a><a id="Braiding-manipulations-on-a-splitting-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Braiding-manipulations-on-a-splitting-tree" title="Permalink"></a></h3><p>An elementary braid of two neighbouring sectors of a splitting tree, which is called Artin braid or Artin generator of the braid group, can be computed in two different ways:</p><p><img src="../img/tree-artinbraid.svg" alt="artin braid"/></p><p>While the upper path is the most intuitive, it requires two F-moves (one forward and one reverse) and one R-move. The lower path requires only one (reverse) F-move, and two R-moves. The R-move is less expensive to compute than F-move, thus the lower path is computationally more efficient. The final result should be the same, provided the pentagon and hexagon equations are satisfied. We always assume that these are satisfied for any subtype of <code>Sector</code>, and it is up to the user to verify that they are when implementing new custom <code>Sector</code> types.</p><p>This Artin braid of a splitting tree is implemented by</p><pre><code class="language-julia hljs">artin_braid(f::FusionTree, i; inv = false)</code></pre><p>where <code>i</code> denotes the position of the first sector (labeled <code>b</code> in the above graph) which is braided with the sector at position <code>i+1</code> in the splitting tree <code>f</code>. The keyword argument <code>inv</code> allows to select the inverse braiding operation. The result is returned as a dictionary with possible output fusion trees as keys and corresponding coefficients as values.</p><p>With the elementary <code>artin_braid</code>, we can then compute a more general braid by</p><pre><code class="language-julia hljs">braid(f::FusionTree{I,N}, levels::NTuple{N,Int}, p::NTuple{N,Int})</code></pre><p>The braid is specified by a permutation <code>p</code>, such that the new sector at position <code>i</code> was originally at position <code>p[i]</code>. Every uncoupled sector is assigned a level which can be thought as the depth in the third dimension. The permutation is decomposed into swaps between neighbouring sectors, and when two sectors are swapped, their respective level will determine whether the left sector is braided over or under its right neighbor (shallower level goes over deeper level). This interface does not allow to specify the most general braid, and will never wind one line around another, but can be used as a building block for arbitrary braids than the elementary Artin generators. For example, a braid with <code>levels=(1,2,3,4,5)</code> and <code>permutation=(5,3,1,4,2)</code> is shown in the following:</p><p><img src="../img/tree-braidinterface.svg" alt="braid interface"/></p><p>The first sector or space goes to position 3, and crosses over all other lines, and so forth. We sketch this operation both as a general braid on the left hand side, and as a composition of Artin braids on the right hand side.</p><p>When <code>BraidingStyle(I) == SymmetricBraiding()</code>, there is no distinction between applying the braiding or its inverse, and we can use the simplified <code>permute</code> method without <code>levels</code> parameter:</p><pre><code class="language-julia hljs">permute(f::FusionTree{I,N}, p::NTuple{N,Int})</code></pre><h3 id="Braiding-manipulations-on-a-fusion-splitting-tree"><a class="docs-heading-anchor" href="#Braiding-manipulations-on-a-fusion-splitting-tree">Braiding manipulations on a fusion-splitting tree</a><a id="Braiding-manipulations-on-a-fusion-splitting-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Braiding-manipulations-on-a-fusion-splitting-tree" title="Permalink"></a></h3><p>We can now perform arbitrary combinations of braids or permutations with line bendings, to completely reshuffle where sectors appear in a fusion-splitting tree.</p><pre><code class="language-julia hljs">braid(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, levels1::NTuple{N₁,Int},
    levels2::NTuple{N₂,Int}, p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int})</code></pre><p>where we have splitting tree <code>f1</code> with <code>N₁</code> outgoing sectors, a fusion tree <code>f2</code> with <code>N₂</code> incoming sectors, <code>levels1</code> and <code>levels2</code> assign a level or depth to the corresponding uncoupled sectors in <code>f1</code> and <code>f2</code>, and we represent the new configuration as a pair <code>p1</code> and <code>p2</code>. Together, <code>(p1..., p2...)</code> represents a permutation of length <code>N₁+N₂ = N₁′+N₂′</code>, where <code>p1</code> indicates which of the original sectors should appear as outgoing sectors in the new splitting tree and <code>p2</code> indicates which appear as incoming sectors in the new fusion tree.</p><p>This routine is implemented by first making all sectors outgoing using the <code>repartition</code> function, such that only splitting trees remain. Then, braiding the uncoupling sectors of this splitting tree such that the new outgoing sectors appear first, followed by the new incoming sectors in reverse order. Then, bring everything to final form by <code>repartition</code>. The result is returned as a dictionary where the keys are <code>(f1′,f2′)</code> and the values are the corresponding coefficients.</p><p>When <code>BraidingStyle(I) isa SymmetricBraiding</code>, the levels are not needed and we can use the simplified <code>permute</code> method:</p><pre><code class="language-julia hljs">permute(f1::FusionTree{I,N₁}, f2::FusionTree{I,N₂}, p1::NTuple{N₁′,Int}, p2::NTuple{N₂′,Int})</code></pre><p>The <code>braid</code> and <code>permute</code> routines for fusion-splitting trees will be the main access point for corresponding manipulations on tensors. As a consequence, results from this routine are memorized, i.e. they are stored in some package wide &#39;least-recently used&#39; cache (from <a href="https://github.com/JuliaCollections/LRUCache.jl">LRUCache.jl</a>) that can be accessed as <code>TensorLabXD.braidcache</code>. By default, this cache stores up to <code>10^5</code> different <code>braid</code> or <code>permute</code> results, where each result corresponds to one particular combination of <code>(f1, f2, p1, p2, levels1, levels2)</code>. This should be sufficient for most algorithms. While there are currently no (official) access methods to change the default settings of this cache (one can always resort to <code>resize!(TensorLabXD.permutecache)</code> and other methods from LRUCache.jl), this might change in the future. The use of this cache is however controlled by two constants of type <code>RefValue{Bool}</code>, namely <code>usebraidcache_abelian</code> and <code>usebraidcache_nonabelian</code>. The default values are given by <code>TensorLabXD.usebraidcache_abelian[] = false</code> and <code>TensorLabXD.usebraidcache_nonabelian[] = true</code>, and respectively reflect that the cache is likely not going to help (or even slow down) fusion trees with <code>FusionStyle(f) isa UniqueFusion</code>, but is probably useful for fusion trees with <code>FusionStyle(f) isa MultipleFusion</code>. One can change these values and test the effect on their application.</p><p>The existence of <code>braidcache</code> also implies that potential inefficiencies in the fusion tree manipulations (which we nonetheless try to avoid) will not seriously affect performance of tensor manipulations.</p><h3 id="Inspecting-fusion-trees-as-tensors"><a class="docs-heading-anchor" href="#Inspecting-fusion-trees-as-tensors">Inspecting fusion trees as tensors</a><a id="Inspecting-fusion-trees-as-tensors-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-fusion-trees-as-tensors" title="Permalink"></a></h3><p>For those cases where the fusion and splitting tensors have an explicit representation as a tensor, this explicit representation can be created, which can be useful for checking purposes. The splitting tensor <span>$X^{ab}_{c,μ}$</span>, i.e. the Clebsch-Gordan coefficients of the group, are encoded via the routine <code>fusiontensor(a,b,c[,μ = nothing])</code>, where the last argument is only necessary if <code>FusionStyle(I) == GenericFusion()</code>. We can then convert a <code>FusionTree{I,N}</code> into an <code>Array</code>, which will yield a rank <code>N+1</code> array where the first <code>N</code> dimensions correspond to the uncoupled sectors, and the last dimension to the coupled sector.</p><p>Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; s = Irrep[SU₂](1/2)</code><code class="nohighlight hljs ansi" style="display:block;">Irrep[SU₂](1/2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iter = fusiontrees((s, s, s, s), SU2Irrep(1))</code><code class="nohighlight hljs ansi" style="display:block;">TensorLabXD.FusionTreeIterator{SU2Irrep,4}((Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2), Irrep[SU₂](1/2)), Irrep[SU₂](1), (false, false, false, false))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; f = first(iter)</code><code class="nohighlight hljs ansi" style="display:block;">FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; convert(Array, f)</code><code class="nohighlight hljs ansi" style="display:block;">2×2×2×2×3 Array{Float64,5}:
[:, :, 1, 1, 1] =
  0.0       0.707107
 -0.707107  0.0

[:, :, 2, 1, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 2, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 2, 1] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 1, 2] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 1, 2] =
  0.0  0.5
 -0.5  0.0

[:, :, 1, 2, 2] =
  0.0  0.5
 -0.5  0.0

[:, :, 2, 2, 2] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 1, 3] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 1, 3] =
 0.0  0.0
 0.0  0.0

[:, :, 1, 2, 3] =
 0.0  0.0
 0.0  0.0

[:, :, 2, 2, 3] =
  0.0       0.707107
 -0.707107  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; I ≈ convert(Array, FusionTree((SU₂(1/2),), SU₂(1/2), (false,), ()))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Z = adjoint(convert(Array, FusionTree((SU2Irrep(1/2),), SU2Irrep(1/2), (true,), ())))</code><code class="nohighlight hljs ansi" style="display:block;">2×2 LinearAlgebra.Adjoint{Float64,Array{Float64,2}}:
 0.0  -1.0
 1.0   0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(Z) ≈ frobeniusschur(SU2Irrep(1/2)) * Z</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; I ≈ convert(Array, FusionTree((Irrep[SU₂](1),), Irrep[SU₂](1), (false,), ()))</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Z = adjoint(convert(Array, FusionTree((Irrep[SU₂](1),), Irrep[SU₂](1), (true,), ())))</code><code class="nohighlight hljs ansi" style="display:block;">3×3 LinearAlgebra.Adjoint{Float64,Array{Float64,2}}:
 0.0   0.0  1.0
 0.0  -1.0  0.0
 1.0   0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; transpose(Z) ≈ frobeniusschur(Irrep[SU₂](1)) * Z</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; #check orthogonality
       for f1 in iter
         for f2 in iter
           dotproduct  = dot(convert(Array, f1), convert(Array, f2))
           println(&quot;&lt; $f1, $f2&gt; = $dotproduct&quot;)
         end
       end</code><code class="nohighlight hljs ansi" style="display:block;">&lt; FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))&gt; = 3.000000000000001
&lt; FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2))&gt; = 0.0
&lt; FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2))&gt; = 0.0
&lt; FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))&gt; = 0.0
&lt; FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2))&gt; = 3.0
&lt; FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2))&gt; = 0.0
&lt; FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (0, 1/2))&gt; = 0.0
&lt; FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 1/2))&gt; = 0.0
&lt; FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2)), FusionTree{Irrep[SU₂]}((1/2, 1/2, 1/2, 1/2), 1, (false, false, false, false), (1, 3/2))&gt; = 3.0</code></pre><p>Note that we take the adjoint when computing <code>Z</code>, because <code>convert(Array, f)</code> assumes <code>f</code> to be splitting tree, which is built using <span>$Z^†$</span>. Further note that the normalization (squared) of a fusion tree is given by the dimension of the coupled sector, as we are also tracing over the <span>$\mathrm{id}_c$</span> when checking the orthogonality by computing <code>dot</code> of the corresponding tensors.</p><h2 id="Fermions"><a class="docs-heading-anchor" href="#Fermions">Fermions</a><a id="Fermions-1"></a><a class="docs-heading-anchor-permalink" href="#Fermions" title="Permalink"></a></h2><p>TODO</p><p>(Support for fermionic sectors and corresponding super vector spaces is on its way. This section will be completed when the implementation is finished.)</p><h2 id="Anyons"><a class="docs-heading-anchor" href="#Anyons">Anyons</a><a id="Anyons-1"></a><a class="docs-heading-anchor-permalink" href="#Anyons" title="Permalink"></a></h2><p>One example of a <code>Sector</code> subtype that has anyonic braiding style is the Fibonacci fusion category. It has two (isomorphism classes of) simple objects, namely the identity <code>𝟙</code> and a non-trivial object known as <code>τ</code>, with fusion rules <code>τ ⊗ τ = 𝟙 ⊕ τ</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 𝟙 = FibonacciAnyon(:I)</code><code class="nohighlight hljs ansi" style="display:block;">FibonacciAnyon(:I)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; τ = FibonacciAnyon(:τ)</code><code class="nohighlight hljs ansi" style="display:block;">FibonacciAnyon(:τ)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(τ ⊗ τ)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Array{FibonacciAnyon,1}:
 :I
 :τ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; FusionStyle(τ)</code><code class="nohighlight hljs ansi" style="display:block;">SimpleFusion()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; BraidingStyle(τ)</code><code class="nohighlight hljs ansi" style="display:block;">Anyonic()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(𝟙)</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(τ)</code><code class="nohighlight hljs ansi" style="display:block;">1.618033988749895</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; F𝟙 = Fsymbol(τ,τ,τ,𝟙,τ,τ)</code><code class="nohighlight hljs ansi" style="display:block;">1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fτ = [Fsymbol(τ,τ,τ,τ,𝟙,𝟙) Fsymbol(τ,τ,τ,τ,𝟙,τ); Fsymbol(τ,τ,τ,τ,τ,𝟙) Fsymbol(τ,τ,τ,τ,τ,τ)]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Array{Float64,2}:
 0.618034   0.786151
 0.786151  -0.618034</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Fτ&#39;*Fτ</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; polar(x) = rationalize.((abs(x), angle(x)/(2pi)))</code><code class="nohighlight hljs ansi" style="display:block;">polar (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rsymbol(τ,τ,𝟙) |&gt; polar</code><code class="nohighlight hljs ansi" style="display:block;">(1//1, 2//5)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rsymbol(τ,τ,τ) |&gt; polar</code><code class="nohighlight hljs ansi" style="display:block;">(1//1, -3//10)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; twist(τ) |&gt; polar</code><code class="nohighlight hljs ansi" style="display:block;">(1//1, -2//5)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../spaces/">« Vector spaces</a><a class="docs-footer-nextpage" href="../tensors/">Tensors and the <code>TensorMap</code> type »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 28 November 2021 06:24">Sunday 28 November 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
