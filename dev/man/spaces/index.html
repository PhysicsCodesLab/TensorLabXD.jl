<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vector spaces ¬∑ TensorLabXD.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TensorLabXD.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../categories/">Optional introduction to category theory</a></li><li class="is-active"><a class="tocitem" href>Vector spaces</a><ul class="internal"><li><a class="tocitem" href="#ss_vectorspace_type"><span>VectorSpace type</span></a></li><li><a class="tocitem" href="#ss_fields"><span>Fields</span></a></li><li><a class="tocitem" href="#ss_elementaryspaces"><span>Elementary spaces</span></a></li><li><a class="tocitem" href="#ss_compositespaces"><span>Composite spaces</span></a></li><li><a class="tocitem" href="#ss_homspaces"><span>Space of morphisms</span></a></li><li><a class="tocitem" href="#Partial-order-among-vector-spaces"><span>Partial order among vector spaces</span></a></li></ul></li><li><a class="tocitem" href="../sectors/">Sectors, representation spaces and fusion trees</a></li><li><a class="tocitem" href="../tensors/">Tensors and the <code>TensorMap</code> type</a></li></ul></li><li><span class="tocitem">Library</span></li><li><span class="tocitem">Index</span><ul><li><a class="tocitem" href="../../index/">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Vector spaces</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Vector spaces</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PhysicsCodesLab/TensorLabXD.jl/blob/master/docs/src/man/spaces.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="s_spaces"><a class="docs-heading-anchor" href="#s_spaces">Vector spaces</a><a id="s_spaces-1"></a><a class="docs-heading-anchor-permalink" href="#s_spaces" title="Permalink"></a></h1><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Field
abstract type Field end
struct RealNumbers &lt;: Field end
struct ComplexNumbers &lt;: Field end
const ‚Ñù = RealNumbers()
const ‚ÑÇ = ComplexNumbers()

# Vector Space
abstract type VectorSpace end

## Elementary Space
abstract type ElementarySpace{ùïú} &lt;: VectorSpace end
const IndexSpace = ElementarySpace
struct GeneralSpace{ùïú} &lt;: ElementarySpace{ùïú}
    d::Int
    dual::Bool
    conj::Bool
end

abstract type InnerProductSpace{ùïú} &lt;: ElementarySpace{ùïú} end
abstract type EuclideanSpace{ùïú} &lt;: InnerProductSpace{ùïú} end
struct CartesianSpace &lt;: EuclideanSpace{‚Ñù}
    d::Int
end
struct ComplexSpace &lt;: EuclideanSpace{‚ÑÇ}
  d::Int
  dual::Bool
end
struct GradedSpace{I&lt;:Sector, D} &lt;: EuclideanSpace{‚ÑÇ}
    dims::D
    dual::Bool
end

# Composite Space
abstract type CompositeSpace{S&lt;:ElementarySpace} &lt;: VectorSpace end
struct ProductSpace{S&lt;:ElementarySpace, N} &lt;: CompositeSpace{S}
    spaces::NTuple{N, S}
end
const TensorSpace{S&lt;:ElementarySpace} = Union{S, ProductSpace{S}}

# Space of Morphisms
struct HomSpace{S&lt;:ElementarySpace, P1&lt;:CompositeSpace{S}, P2&lt;:CompositeSpace{S}}
    codomain::P1
    domain::P2
end
const TensorMapSpace{S&lt;:ElementarySpace, N‚ÇÅ, N‚ÇÇ} = HomSpace{S, ProductSpace{S, N‚ÇÅ}, ProductSpace{S, N‚ÇÇ}}</code></pre><h3 id="Properties"><a class="docs-heading-anchor" href="#Properties">Properties</a><a id="Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Properties" title="Permalink"></a></h3><p>On both <code>VectorSpace</code> instances and types:</p><pre><code class="language-julia hljs">spacetype # type of ElementarySpace associated with a composite space or a tensor or a HomSpace
field # field of a vector space or a tensor map or a HomSpace
Base.oneunit # the corresponding vector space that represents the trivial 1D space isomorphic to the corresponding field
sectortype # sector type of a space or a tensor or a HomSpace
one(::S) where {S&lt;:ElementarySpace} -&gt; ProductSpace{S, 0}
one(::ProductSpace{S}) where {S&lt;:ElementarySpace} -&gt; ProductSpace{S, 0}  # Return a tensor product of zero spaces of type `S`, i.e. this is the unit object under the tensor product operation, such that `V ‚äó one(V) == V`.</code></pre><p>On <code>VectorSpace</code> instances:</p><pre><code class="language-julia hljs">sectors # an iterator over the different sectors of an ElementarySpace
sectors(P::ProductSpace{S, N}) # Return an iterator over all possible combinations of sectors (represented as an `NTuple{N, sectortype(S)}`) that can appear within the tensor product space `P`.
blocksectors(V::ElementarySpace) = sectors(V) # make ElementarySpace instances behave similar to ProductSpace instances
blocksectors(P::ProductSpace) # Return an iterator over the different unique coupled sector labels
blocksectors(W::HomSpace) # Return an iterator over the different unique coupled sector labels, i.e. the intersection of the different fusion outputs that can be obtained by fusing the sectors present in the domain, as well as from the codomain.
blocksectors(t::TensorMap) # Return an iterator over the different unique coupled sector labels
dim # total dimension of a vector space or a product space
dim(V::ElementarySpace, ::Trivial) # return dim(V)
dim(V::GradedSpace, c::I) # the degeneracy or multiplicity of sector c in a Graded Space
dim(W::HomSpace) # Return the total dimension of a `HomSpace`, i.e. the number of linearly independent morphisms that can be constructed within this space.
dim(P::ProductSpace, n::Int) # dim for the `n`th vector space of the product space
dim(P::ProductSpace{S, N}, s::NTuple{N, sectortype(S)}) # Return the total degeneracy dimension corresponding to a tuple of sectors for each of the spaces in the tensor product, obtained as `prod(dims(P, s))``.
dim(t::AbstractTensorMap) # total dim for corresponding HomSpace
dim(t::TensorMap) # Return the total dimension of the tensor map, i.e., the number of elements in all DenseMatrix of the data.
dims(P::ProductSpace) # Return the dimensions of the spaces in the tensor product space as a tuple of integers.
dims(P::ProductSpace{S, N}, s::NTuple{N, sectortype(S)}) # Return the degeneracy dimensions corresponding to a tuple of sectors `s` for each of the spaces in the tensor product `P`.
blockdim(V::ElementarySpace, c::Sector) = dim(V, c) # make ElementarySpace instances behave similar to ProductSpace instances
blockdim(P::ProductSpace, c::Sector) # Return the total dimension of a coupled sector `c` in the product space
hassector(V::ElementarySpace, a::Sector) # whether a vector space `V` has a subspace corresponding to sector `a` with non-zero multiplicity
hassector(P::ProductSpace{S, N}, s::NTuple{N, sectortype(S)}) # Query whether `P` has a non-zero degeneracy of sector `s`, representing a combination of sectors on the individual tensor indices.
Base.axes(V::ElementarySpace) # the axes of an elementary space as `1:dim(V)`
Base.axes(V::ElementarySpace, a::Sector) # axes corresponding to the sector `a` in an elementary space as a UnitRange.
Base.axes(P::ProductSpace) # the axes for all index spaces in product space `P`
Base.axes(P::ProductSpace, n::Int) # the axes for `n`th index space of product space `P`
Base.axes(P::ProductSpace{&lt;:ElementarySpace, N}, sectors::NTuple{N, &lt;:Sector}) where {N} # the axes of `sectors[i]` in `P.spaces[i]` for all `i ‚àà 1:N`.
Base.conj(V::ElementarySpace) # returns the complex conjugate space (conj(V)==VÃÖ)
dual(V::EuclideanSpace) = conj(V) # returns the dual space (dual(V)==V^*); for product space the sequence of the vector spaces are reversed.
dual(P::ProductSpace) # Return a new product space with reversed order of index spaces of the input product space and take the dual of each index space.
dual(W::HomSpace) # Return the dual of a HomSpace which contains the dual of morphisms in this space. It corresponds to 180 degree rotation in the graphical representation.
Base.adjoint(V::VectorSpace) = dual(V) # make V&#39; as the dual of V
Base.adjoint(W::HomSpace{&lt;:EuclideanSpace}) # Return the adjoint of a HomSpace which contains the dagger of morphisms in this space. It corresponds to mirror operation and then reversing all arrows in the graphical
representation.
isdual(V::ElementarySpace) # wether an ElementarySpace `V` is normal or rather a dual space
flip(V::ElementarySpace) # flip(V)==VÃÖ^*
‚äï # direct sum of the elementary spaces `V1`, `V2`, ...
‚äó # representing the tensor product of several elementary vector spaces
Base.:*(V1::VectorSpace, V2::VectorSpace) = ‚äó(V1, V2)
fuse(V1::S, V2::S, V3::S...) where {S&lt;:ElementarySpace} # returns a single vector space that is isomorphic to the fusion product of the individual spaces
fuse(P::ProductSpace{S}) where {S&lt;:ElementarySpace}
ismonomorphic # Return whether there exist monomorphisms from `V1` to `V2`, i.e. &#39;injective&#39; morphisms with left inverses.
isepimorphic # Return whether there exist epimorphisms from `V1` to `V2`, i.e. &#39;surjective&#39; morphisms with right inverses.
isisomorphic # Return if `V1` and `V2` are isomorphic, meaning that there exists isomorphisms from `V1` to `V2`, i.e. morphisms with left and right inverses.
const ‚âæ = ismonomorphic
const ‚âø = isepimorphic
const ‚âÖ = isisomorphic
‚â∫(V1::VectorSpace, V2::VectorSpace) = V1 ‚âæ V2 &amp;&amp; !(V1 ‚âø V2)
‚âª(V1::VectorSpace, V2::VectorSpace) = V1 ‚âø V2 &amp;&amp; !(V1 ‚âæ V2)
infimum # Return the infimum of a number of elementary spaces
supremum # Return the supremum of a number of elementary spaces
Base.:(==)
Base.hash
Base.length(P::ProductSpace) # number of vector spaces
Base.iterate
Base.indexed_iterate
Base.eltype
Base.IteratorEltype
Base.IteratorSize
Base.convert
codomain(W::HomSpace) # codomain of a HomSpace.
domain(W::HomSpace) # domain of a HomSpace.
</code></pre><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Cartesian and Complex Space
CartesianSpace(d::Integer = 0; dual = false) # Constructed by an integer number which is the dim of the space
ComplexSpace(d::Integer = 0; dual = false)
CartesianSpace(dim::Pair; dual = false) # Constructed by (Trivial(),d)
ComplexSpace(dim::Pair; dual = false)
CartesianSpace(dims::AbstractDict; kwargs...) # Constructed by (Trivial() =&gt; d)
ComplexSpace(dims::AbstractDict; kwargs...)
Base.getindex(::RealNumbers) = CartesianSpace # Make ‚Ñù[] a synonyms for CartesianSpace.
Base.getindex(::ComplexNumbers) = ComplexSpace # make ‚ÑÇ[] a synonyms for ComplexSpace
Base.:^(::RealNumbers, d::Int) # Return a CartesianSpace with dimension `d`.
Base.:^(::ComplexNumbers, d::Int) # Return a ComplexSpace with dimension `d`

# Graded Space
GradedSpace{I, NTuple{N, Int}}(dims; dual::Bool = false) where {I, N} # dims = (c=&gt;dc,...)
GradedSpace{I, NTuple{N, Int}}(dims::Pair; dual::Bool = false) where {I, N}
GradedSpace{I, SectorDict{I, Int}}(dims; dual::Bool = false) where {I&lt;:Sector}
GradedSpace{I, SectorDict{I, Int}}(dims::Pair; dual::Bool = false) where {I&lt;:Sector}
GradedSpace{I,D}(; kwargs...) where {I&lt;:Sector,D}
GradedSpace{I,D}(d1::Pair, d2::Pair, dims::Vararg{Pair}; kwargs...) where {I&lt;:Sector,D}
GradedSpace{I}(args...; kwargs...) where {I&lt;:Sector}
GradedSpace(dims::Tuple{Vararg{Pair{I, &lt;:Integer}}}; dual::Bool = false) where {I&lt;:Sector}
GradedSpace(dims::Vararg{Pair{I, &lt;:Integer}}; dual::Bool = false) where {I&lt;:Sector}
GradedSpace(dims::AbstractDict{I, &lt;:Integer}; dual::Bool = false) where {I&lt;:Sector}

struct SpaceTable end
const Vect = SpaceTable()
Base.getindex(::SpaceTable) = ComplexSpace # Vect[] = ComplexSpace
Base.getindex(::SpaceTable, ::Type{Trivial}) = ComplexSpace
Base.getindex(::SpaceTable, I::Type{&lt;:Sector}) # # Vect[I]; Return `GradedSpace{I, NTuple{N, Int}}` if `HasLength`; return `GradedSpace{I, SectorDict{I, Int}}` if `IsInfinite`.
Base.getindex(::ComplexNumbers, I::Type{&lt;:Sector}) = Vect[I] # Make ‚ÑÇ[I] = Vect[I]

struct RepTable end
const Rep = RepTable()
Base.getindex(::RepTable, G::Type{&lt;:Group}) # Rep[G] = Vect[Irrep[G]]
const ZNSpace{N} = GradedSpace{ZNIrrep{N}, NTuple{N,Int}}
const Z2Space = ZNSpace{2}
const Z3Space = ZNSpace{3}
const Z4Space = ZNSpace{4}
const U1Space = Rep[U‚ÇÅ]
const CU1Space = Rep[CU‚ÇÅ]
const SU2Space = Rep[SU‚ÇÇ]
const ‚Ñ§‚ÇÇSpace = Z2Space
const ‚Ñ§‚ÇÉSpace = Z3Space
const ‚Ñ§‚ÇÑSpace = Z4Space
const U‚ÇÅSpace = U1Space
const CU‚ÇÅSpace = CU1Space
const SU‚ÇÇSpace = SU2Space

# Product Space
ProductSpace(spaces::Vararg{S, N}) where {S&lt;:ElementarySpace, N}
ProductSpace{S, N}(spaces::Vararg{S, N}) where {S&lt;:ElementarySpace, N}
ProductSpace{S}(spaces) where {S&lt;:ElementarySpace}
ProductSpace(P::ProductSpace)
‚äó(V1::S, V2::S) where {S&lt;:ElementarySpace}= ProductSpace((V1, V2))
‚äó(P1::ProductSpace{S}, V2::S) where {S&lt;:ElementarySpace}
‚äó(V1::S, P2::ProductSpace{S}) where {S&lt;:ElementarySpace}
‚äó(P1::ProductSpace{S}, P2::ProductSpace{S}) where {S&lt;:ElementarySpace}
‚äó(P::ProductSpace{S, 0}, ::ProductSpace{S, 0}) where {S&lt;:ElementarySpace} = P
‚äó(P::ProductSpace{S}, ::ProductSpace{S, 0}) where {S&lt;:ElementarySpace} = P
‚äó(::ProductSpace{S, 0}, P::ProductSpace{S}) where {S&lt;:ElementarySpace} = P
‚äó(V::ElementarySpace) = ProductSpace((V,))
‚äó(P::ProductSpace) = P
Base.:^(V::ElementarySpace, N::Int) = ProductSpace{typeof(V), N}(ntuple(n-&gt;V, N))
Base.:^(V::ProductSpace, N::Int) = ‚äó(ntuple(n-&gt;V, N)...)
Base.literal_pow(::typeof(^), V::ElementarySpace, p::Val{N}) where N =
    ProductSpace{typeof(V), N}(ntuple(n-&gt;V, p))
insertunit(P::ProductSpace, i::Int = length(P)+1; dual = false, conj = false) # For `P::ProductSpace{S,N}`, this adds an extra tensor product factor at position `1 &lt;= i &lt;= N+1` (last position by default) which is just a the `S`-equivalent of the underlying field of scalars, i.e. `oneunit(S)`.

# HomSpace
‚Üí(dom::TensorSpace{S}, codom::TensorSpace{S}) where {S&lt;:ElementarySpace} =
    HomSpace(ProductSpace(codom), ProductSpace(dom))
‚Üê(codom::TensorSpace{S}, dom::TensorSpace{S}) where {S&lt;:ElementarySpace} =
    HomSpace(ProductSpace(codom), ProductSpace(dom))    </code></pre><h3 id="Others-structures"><a class="docs-heading-anchor" href="#Others-structures">Others structures</a><a id="Others-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Others-structures" title="Permalink"></a></h3><pre><code class="language-julia hljs">struct TrivialOrEmptyIterator
    isempty::Bool
end # returns nothing is isempty = true, otherwise returns Trivial()</code></pre><h3 id="Details-about-dual,-conj,-flip"><a class="docs-heading-anchor" href="#Details-about-dual,-conj,-flip">Details about <code>dual</code>, <code>conj</code>, <code>flip</code></a><a id="Details-about-dual,-conj,-flip-1"></a><a class="docs-heading-anchor-permalink" href="#Details-about-dual,-conj,-flip" title="Permalink"></a></h3><p>In <code>vectorspaces.jl</code>:</p><pre><code class="language-julia hljs">function dual end
dual(V::EuclideanSpace) = conj(V)
Base.adjoint(V::VectorSpace) = dual(V)
function flip end</code></pre><p>In <code>generalspace.jl</code>:</p><pre><code class="language-julia hljs">dual(V::GeneralSpace{ùïú}) where {ùïú} =
    GeneralSpace{ùïú}(dim(V), !isdual(V), isconj(V))
Base.conj(V::GeneralSpace{ùïú}) where {ùïú} =
    GeneralSpace{ùïú}(dim(V), isdual(V), !isconj(V))</code></pre><p>In <code>cartesianspace.jl</code>:</p><pre><code class="language-julia hljs">flip(V::CartesianSpace) = V</code></pre><p>In <code>complexspace.jl</code>:</p><pre><code class="language-julia hljs">Base.conj(V::ComplexSpace) = ComplexSpace(dim(V), !isdual(V))
flip(V::ComplexSpace) = dual(V)</code></pre><p>In <code>sectors.jl</code>:</p><p><code>Base.conj(a::I)</code>: <span>$\overline{a}$</span>, conjugate or dual label of <span>$a$</span>.</p><pre><code class="language-julia hljs">dual(a::Sector) = conj(a)</code></pre><p>In <code>trivial.jl</code>:</p><pre><code class="language-julia hljs">Base.conj(::Trivial) = Trivial()</code></pre><p>In <code>anyons.jl</code>:</p><pre><code class="language-julia hljs">Base.conj(s::IsingAnyon) = s
Base.conj(s::FibonacciAnyon) = s</code></pre><p>In <code>irreps.jl</code>:</p><pre><code class="language-julia hljs">Base.conj(c::ZNIrrep{N}) where {N} = ZNIrrep{N}(-c.n)
Base.conj(c::U1Irrep) = U1Irrep(-c.charge)
Base.conj(s::SU2Irrep) = s
Base.conj(c::CU1Irrep) = c</code></pre><p>In <code>gradedspace.jl</code>:</p><p>In fact, <code>GradedSpace</code> is the reason <code>flip</code> exists, cause in this case it is different than <code>dual</code>. The existence of flip originates from the non-trivial isomorphism between <span>$R_{\overline{a}}$</span> and <span>$R_{a}^*$</span>, i.e. the representation space of the dual <span>$\overline{a}$</span> of sector <span>$a$</span> and the dual of the representation space of sector <span>$a$</span>. In order for <code>flip(V)</code> to be isomorphic to <code>V</code>, it is such that, if <code>V = GradedSpace(a=&gt;n_a,...)</code> then <code>flip(V) = dual(GradedSpace(dual(a)=&gt;n_a,....))</code>.</p><p>In the structure of <code>TensorLabXD.jl</code>, we only keep the simple objects. It means that we don&#39;t have objects correspond to <span>$a^*$</span> in the language of category. Therefore, <code>dual(a) = conj(a)</code> both correspond to <span>$\overline{a}$</span>. The dual space of a space is denoted in the field named as <code>dual</code> in the type definitions. If <code>dual = true</code>, it means that we represent the space <span>$R_a^*$</span> which is isomorphic to <span>$R_{\overline{a}}$</span>, and in the methods like <code>sectors</code> and <code>dim</code> we get the sectors and corresponding dims in the corresponding <span>$R_{\overline{a}}$</span>.</p><pre><code class="language-julia hljs">sectors(V::GradedSpace{I,&lt;:AbstractDict}) where {I&lt;:Sector} =
    SectorSet{I}(s-&gt;isdual(V) ? dual(s) : s, keys(V.dims))
sectors(V::GradedSpace{I,NTuple{N,Int}}) where {I&lt;:Sector, N} =
    SectorSet{I}(Iterators.filter(n-&gt;V.dims[n]!=0, 1:N)) do n
        isdual(V) ? dual(values(I)[n]) : values(I)[n]
dim(V::GradedSpace{I,&lt;:AbstractDict}, c::I) where {I&lt;:Sector} =
    get(V.dims, isdual(V) ? dual(c) : c, 0)
dim(V::GradedSpace{I,&lt;:Tuple}, c::I) where {I&lt;:Sector} =
    V.dims[findindex(values(I), isdual(V) ? dual(c) : c)]    
Base.conj(V::GradedSpace) = typeof(V)(V.dims, !V.dual)
function flip(V::GradedSpace{I}) where {I&lt;:Sector}
    if isdual(V)
        typeof(V)(c=&gt;dim(V, c) for c in sectors(V))
    else
        typeof(V)(dual(c)=&gt;dim(V, c) for c in sectors(V))&#39;
    end
end        </code></pre><p>In <code>productspace.jl</code>:</p><p>The order of the spaces are reversed before taking the dual of each elementray vecor space:</p><pre><code class="language-julia hljs">dual(P::ProductSpace{&lt;:ElementarySpace, 0}) = P
dual(P::ProductSpace) = ProductSpace(map(dual, reverse(P.spaces)))</code></pre><p>In  <code>homespace.jl</code>:</p><p>For a morphism the dual of the morphism is different with the adjoint of it. In the tensor category language, the dual of a morphism is called the transpose of the morphism, while the adjoint of a morphism is called the dagger of the morphism.</p><pre><code class="language-julia hljs">dual(W::HomSpace) = HomSpace(dual(W.domain), dual(W.codomain))
Base.adjoint(W::HomSpace{&lt;:EuclideanSpace}) = HomSpace(W.domain, W.codomain)</code></pre><p>The sequence of the elementary spaces in a TensorMapSpace is defined as <span>$1:N_1$</span> for codomain vectors, and <span>$N_1+1:N_1+N_2$</span> for domain dual vectors. Note that the sequence of the domain vectors are not reversed, and the dual is taken individually for each elementary space.</p><pre><code class="language-julia hljs">Base.getindex(W::TensorMapSpace{&lt;:IndexSpace, N‚ÇÅ, N‚ÇÇ}, i) where {N‚ÇÅ, N‚ÇÇ} =
    i &lt;= N‚ÇÅ ? codomain(W)[i] : dual(domain(W)[i-N‚ÇÅ])</code></pre><h2 id="ss_vectorspace_type"><a class="docs-heading-anchor" href="#ss_vectorspace_type">VectorSpace type</a><a id="ss_vectorspace_type-1"></a><a class="docs-heading-anchor-permalink" href="#ss_vectorspace_type" title="Permalink"></a></h2><p>From the <a href="../intro/#s_intro">Introduction</a>, it should be clear that an important aspect in the definition of a tensor (map) is specifying the vector spaces and their structure in the domain and codomain of the map. The starting point is an abstract type <code>VectorSpace</code></p><pre><code class="language-julia hljs">abstract type VectorSpace end</code></pre><p>which is actually a too restricted name. Subtypes of <code>VectorSpace</code> will in general represent <span>$ùïú$</span>-linear tensor categories, which can go beyond <span>$\mathbf{Vect}$</span> and <span>$\mathbf{SVect}$</span>. The instances of it represent the objects of the category.</p><p>In order not to make the remaining discussion too abstract or complicated, we will simply refer to subtypes of <code>VectorSpace</code> instead of specific categories, and to spaces instead of objects from these categories.</p><p>We define two abstract subtypes</p><pre><code class="language-julia hljs">abstract type ElementarySpace{ùïú} &lt;: VectorSpace end
const IndexSpace = ElementarySpace

abstract type CompositeSpace{S&lt;:ElementarySpace} &lt;: VectorSpace end</code></pre><p>The <code>ElementarySpace</code> is a super type for all categories that can be associated with the individual indices of a tensor, as hinted to by its alias <code>IndexSpace</code>. The parameter <code>ùïú</code> here could represent the field of vector spaces of Vect, or the field of the morphism space of <code>ùïú</code>-linear tensor categories.</p><p>The <code>CompositeSpace{S}</code> where <code>S&lt;:ElementarySpace</code> is a super type for all vector spaces that are composed of a number of elementary spaces of type <code>S</code>. One concrete subtype of it is the <code>ProductSpace{S,N}</code> which represents a homogeneous tensor product of <code>N</code> vector spaces of type <code>S</code>.</p><p>Throughout TensorLabXD.jl, the function <code>spacetype</code> returns the type of <code>ElementarySpace</code> associated with e.g. a composite space or a tensor. It works both on instances and type.</p><h2 id="ss_fields"><a class="docs-heading-anchor" href="#ss_fields">Fields</a><a id="ss_fields-1"></a><a class="docs-heading-anchor-permalink" href="#ss_fields" title="Permalink"></a></h2><p>Vector spaces (linear categories) are defined over a field of scalars <span>$ùïú$</span>. We define a type hierarchy to specify the scalar field, but so far only support real and complex numbers, via</p><pre><code class="language-julia hljs">abstract type Field end

struct RealNumbers &lt;: Field end
struct ComplexNumbers &lt;: Field end

const ‚Ñù = RealNumbers()
const ‚ÑÇ = ComplexNumbers()</code></pre><p>Note that <code>‚Ñù</code> and <code>‚ÑÇ</code> can be typed as <code>\bbR</code>+TAB and <code>\bbC</code>+TAB. One reason for defining this new type hierarchy instead of recycling the types from Julia&#39;s <code>Number</code> hierarchy is to introduce some syntactic sugar without committing type piracy.</p><p>Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 3 ‚àà ‚Ñù</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 5.0 ‚àà ‚ÑÇ</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; 5.0+1.0*im ‚àà ‚Ñù</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Float64 ‚äÜ ‚Ñù</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ComplexF64 ‚äÜ ‚ÑÇ</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñù ‚äÜ ‚ÑÇ</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ ‚äÜ ‚Ñù</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>The field of a vector space or tensor <code>a</code> can be obtained with <code>field(a)</code>.</p><h2 id="ss_elementaryspaces"><a class="docs-heading-anchor" href="#ss_elementaryspaces">Elementary spaces</a><a id="ss_elementaryspaces-1"></a><a class="docs-heading-anchor-permalink" href="#ss_elementaryspaces" title="Permalink"></a></h2><p>Vector spaces that are associated with the individual indices of a tensor should be implemented as subtypes of <code>ElementarySpace</code>. As the domain and codomain of a tensor map will be the tensor product of such objects which all have the same type, it is important that related vector spaces, e.g. the dual space, are objects of the same concrete type.</p><p>Every <code>ElementarySpace</code> should implement the following methods</p><ul><li><p><code>dim(::ElementarySpace) -&gt; ::Int</code> returns the dimension of the space as an <code>Int</code></p></li><li><p><code>dual(::ElementarySpace)</code> returns the dual space, using an instance of   the same concrete type. The dual of a space <code>V</code> can also be obtained as <code>V&#39;</code>.</p></li><li><p><code>conj(::ElementarySpace)</code> returns the complex conjugate space, using an instance of   the same concrete type</p></li></ul><p>The <code>GeneralSpace</code> is one of the concrete type of the <code>ElementarySpace</code>. It is completely characterized by its field <code>ùïú</code>, its dimension and whether its the dual and/or complex conjugate of <span>$ùïú^d$</span>.</p><pre><code class="language-julia hljs">struct GeneralSpace{ùïú} &lt;: ElementarySpace{ùïú}
    d::Int
    dual::Bool
    conj::Bool
end</code></pre><p>The abstract type</p><pre><code class="language-julia hljs">abstract type InnerProductSpace{ùïú} &lt;: ElementarySpace{ùïú} end</code></pre><p>is defined to contain all vector spaces <code>V</code> which have an inner product and thus a canonical mapping from <code>dual(V)</code> to <code>conj(V)</code>. This mapping is provided by the metric, but no further support for working with metrics is currently implemented.</p><p>The abstract type</p><pre><code class="language-julia hljs">abstract type EuclideanSpace{ùïú} &lt;: InnerProductSpace{ùïú} end</code></pre><p>is defined to contain all spaces <code>V</code> with a standard Euclidean inner product. The canonical mapping from <code>dual(V)</code> to <code>conj(V)</code> is identity. This subtype represents dagger categories.</p><p>We have two concrete types</p><pre><code class="language-julia hljs">struct CartesianSpace &lt;: EuclideanSpace{‚Ñù}
    d::Int
end
struct ComplexSpace &lt;: EuclideanSpace{‚ÑÇ}
  d::Int
  dual::Bool
end</code></pre><p>to represent the Euclidean spaces <span>$‚Ñù^d$</span> and <span>$‚ÑÇ^d$</span>. They can be created using the syntax <code>CartesianSpace(d) == ‚Ñù^d == ‚Ñù[](d)</code> and <code>ComplexSpace(d) == ‚ÑÇ^d == ‚ÑÇ[](d)</code>. The dual space of <span>$\mathbb{C}^d$</span> can be created by <code>ComplexSpace(d, true) == ComplexSpace(d; dual = true) == (‚ÑÇ^d)&#39; == ‚ÑÇ[](d)&#39;</code>. Note that the brackets are required because of the precedence rules, since <code>d&#39; == d</code> for <code>d::Integer</code>.</p><p>Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(‚Ñù^10)</code><code class="nohighlight hljs ansi" style="display:block;">10</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚Ñù^10)&#39; == ‚Ñù^10 == ‚Ñù[](10)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isdual((‚ÑÇ^5))</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isdual((‚ÑÇ^5)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isdual((‚Ñù^5)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(‚ÑÇ^5) == (‚ÑÇ^5)&#39; == conj(‚ÑÇ^5) == ComplexSpace(5; dual = true)</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">CartesianSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">CartesianSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(‚Ñù[])</code><code class="nohighlight hljs ansi" style="display:block;">CartesianSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; field(‚ÑÇ^5)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ</code></pre><p>Note that <code>‚Ñù[]</code> and <code>‚ÑÇ[]</code> are synonyms for <code>CartesianSpace</code> and <code>ComplexSpace</code> respectively. This is not very useful in itself, and is motivated by its generalization to <code>GradedSpace</code>. We refer to the subsection on <a href="man/@ref s_rep">graded spaces</a> on the <a href="../sectors/#s_sectorsrepfusion">next page</a> for further information about <code>GradedSpace</code>, which is another subtype of <code>EuclideanSpace{‚ÑÇ}</code> with an inner structure corresponding to the irreducible representations of a group, or more generally, the simple objects of a fusion category.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For <code>‚ÑÇ^n</code> the dual space is equal (or naturally isomorphic) to the conjugate space, but not to the space itself. This means that even for <code>‚ÑÇ^n</code>, arrows matter in the diagrammatic notation for categories or for tensors, and in particular that a contraction between two tensor indices will check that one is living in the space and the other in the dual space. This is in contrast with several other software packages, especially in the context of tensor networks, where arrows are only introduced when discussing symmetries. We believe that our more purist approach can be useful to detect errors (e.g. unintended contractions). Only with <code>‚Ñù^n</code> will their be no distinction between a space and its dual. When creating tensors with indices in <code>‚Ñù^n</code> that have complex data, a one-time warning will be printed, but most operations should continue to work nonetheless.</p></div></div><h2 id="ss_compositespaces"><a class="docs-heading-anchor" href="#ss_compositespaces">Composite spaces</a><a id="ss_compositespaces-1"></a><a class="docs-heading-anchor-permalink" href="#ss_compositespaces" title="Permalink"></a></h2><p>Composite spaces are vector spaces that are built up out of individual elementary vector spaces of the same type. The most prominent and currently only subtype is a tensor product of <code>N</code> elementary spaces of the same type <code>S</code>:</p><pre><code class="language-julia hljs">struct ProductSpace{S&lt;:ElementarySpace, N} &lt;: CompositeSpace{S}
    spaces::NTuple{N, S}
end</code></pre><p>Given some <code>V1::S</code>, <code>V2::S</code>, <code>V3::S</code> of the same type <code>S&lt;:ElementarySpace</code>, we can easily construct <code>ProductSpace{S,3}((V1,V2,V3))</code> as <code>ProductSpace(V1,V2,V3)</code> or using <code>V1 ‚äó V2 ‚äó V3</code>, where <code>‚äó</code> is simply obtained by typing <code>\otimes</code>+TAB. For convenience, the regular multiplication operator <code>*</code> also acts as tensor product between vector spaces, and as a consequence so does raising a vector space to a positive integer power, i.e.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 = ‚ÑÇ^2</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V2 = ‚ÑÇ^3</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1 ‚äó V2 ‚äó V1&#39; == V1 * V2 * V1&#39; == ProductSpace(V1,V2,V1&#39;) == ProductSpace(V1,V2) ‚äó V1&#39;</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; V1^3</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2 ‚äó ‚ÑÇ^2 ‚äó ‚ÑÇ^2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(V1 ‚äó V2)</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dims(V1 ‚äó V2)</code><code class="nohighlight hljs ansi" style="display:block;">(2, 3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(V1 ‚äó V2)</code><code class="nohighlight hljs ansi" style="display:block;">((‚ÑÇ^3)&#39; ‚äó (‚ÑÇ^2)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(V1 ‚äó V2)</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(ProductSpace{ComplexSpace,3})</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code></pre><p>Here, the new function <code>dims</code> gives the dimension of the individual spaces in a <code>ProductSpace</code> as a tuple.</p><p>The function <code>one</code> applied to a <code>ProductSpace{S,N}</code> or an instance <code>V</code> of <code>S::ElementarySpace</code> returns the multiplicative identity, which is <code>ProductSpace{S,0}(())</code>. Note that <code>V ‚äó one(V)</code> or <code>‚äó(V)</code> will yield a <code>ProductSpace{S,1}(V)</code> and not <code>V</code> itself.</p><p>In the future, other <code>CompositeSpace</code> types could be added. For example, the wave function of an <code>N</code>-particle quantum system in first quantization would require the introduction of a <code>SymmetricSpace{S,N}</code> or a <code>AntiSymmetricSpace{S,N}</code> for bosons or fermions respectively, which correspond to the symmetric (permutation invariant) or antisymmetric subspace of <code>V^N</code>, where <code>V::S</code> represents the Hilbert space of the single particle system. Other domains, like general relativity, might also benefit from tensors living in a subspace with certain symmetries under specific index permutations.</p><h2 id="ss_homspaces"><a class="docs-heading-anchor" href="#ss_homspaces">Space of morphisms</a><a id="ss_homspaces-1"></a><a class="docs-heading-anchor-permalink" href="#ss_homspaces" title="Permalink"></a></h2><p>In a <span>$ùïú$</span>-linear category <span>$C$</span>, the set of morphisms <span>$\mathrm{Hom}(W,V)$</span> for <span>$V,W ‚àà C$</span> form a vector space with field <span>$ùïú$</span>, irrespective of whether or not <span>$C$</span> is a subcategory of <span>$\mathbf{(S)Vect}$</span>, and we define tensor maps as the morphisms.</p><p>The space of morphisms is represented by the type</p><pre><code class="language-julia hljs">struct HomSpace{S&lt;:ElementarySpace, P1&lt;:CompositeSpace{S}, P2&lt;:CompositeSpace{S}}
    codomain::P1
    domain::P2
end</code></pre><p>It can be created by <code>domain ‚Üí codomain</code> or <code>codomain ‚Üê domain</code> (where the arrows are obtained as <code>\to+TAB</code> or <code>\leftarrow+TAB</code>, and as <code>\rightarrow+TAB</code> respectively).</p><p>Note that <code>HomSpace</code> is not a subtype of <code>VectorSpace</code>.</p><p>Some properties of <code>HomSpace</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; W = ‚ÑÇ^2 ‚äó ‚ÑÇ^3 ‚Üí ‚ÑÇ^3 ‚äó dual(‚ÑÇ^4)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;) ‚Üê (‚ÑÇ^2 ‚äó ‚ÑÇ^3)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; field(W)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dual(W)</code><code class="nohighlight hljs ansi" style="display:block;">((‚ÑÇ^3)&#39; ‚äó (‚ÑÇ^2)&#39;) ‚Üê (‚ÑÇ^4 ‚äó (‚ÑÇ^3)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; adjoint(W)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2 ‚äó ‚ÑÇ^3) ‚Üê (‚ÑÇ^3 ‚äó (‚ÑÇ^4)&#39;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(W)</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; spacetype(typeof(W))</code><code class="nohighlight hljs ansi" style="display:block;">ComplexSpace</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W[1]</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W[2]</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^4)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W[3]</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^2)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; W[4]</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^3)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; dim(W)</code><code class="nohighlight hljs ansi" style="display:block;">72</code></pre><p>The indexing <code>W</code> yields first the spaces in the codomain, followed by the dual of the individual spaces in the domain. This convention is useful in combination with the instances of type <a href="man/@ref"><code>TensorMap</code></a>, which represent morphisms living in such a <code>HomSpace</code>. The <code>dim(::HomSpace)</code> represent the number of linearly independent morphisms in this space.</p><h2 id="Partial-order-among-vector-spaces"><a class="docs-heading-anchor" href="#Partial-order-among-vector-spaces">Partial order among vector spaces</a><a id="Partial-order-among-vector-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Partial-order-among-vector-spaces" title="Permalink"></a></h2><p>Vector spaces of the same <code>spacetype</code> can be given a partial order, based on whether there exist injective morphisms (a.k.a <em>monomorphisms</em>) or surjective morphisms (a.k.a. <em>epimorphisms</em>) between them.</p><p>We define <code>ismonomorphic(V1, V2)</code>, with Unicode synonym <code>V1 ‚âæ V2</code> (obtained as <code>\precsim+TAB</code>), to express whether there exist injective morphisms in <code>V1 ‚Üí V2</code>.</p><p>We define <code>isepimorphic(V1, V2)</code>, with Unicode synonym <code>V1 ‚âø V2</code> (obtained as <code>\succsim+TAB</code>), to express whether there exist surjective morphisms in <code>V1 ‚Üí V2</code>.</p><p>We define <code>isisomorphic(V1, V2)</code>, with Unicode alternative <code>V1 ‚âÖ V2</code> (obtained as <code>\cong+TAB</code>), to express whether there exist isomorphism in <code>V1 ‚Üí V2</code>. <code>V1 ‚âÖ V2</code> if and only if <code>V1 ‚âæ V2 &amp;&amp; V1 ‚âø V2</code>.</p><p>The strict comparison operators <code>‚â∫</code> and <code>‚âª</code> (<code>\prec+TAB</code> and <code>\succ+TAB</code>) are defined by</p><pre><code class="language-julia hljs">‚â∫(V1::VectorSpace, V2::VectorSpace) = V1 ‚âæ V2 &amp;&amp; !(V1 ‚âø V2)
‚âª(V1::VectorSpace, V2::VectorSpace) = V1 ‚âø V2 &amp;&amp; !(V1 ‚âæ V2)</code></pre><p>However, as we expect these to be less commonly used, no ASCII alternative is provided.</p><p>In the context of <code>spacetype(V) &lt;: EuclideanSpace</code>, <code>V1 ‚âæ V2</code> implies that there exists isometries <span>$W:V1 ‚Üí V2$</span> such that <span>$W^‚Ä† ‚àò W = \mathrm{id}_{V1}$</span>, while <code>V1 ‚âÖ V2</code> implies that there exist unitaries <span>$U:V1 ‚Üí V2$</span> such that <span>$U^‚Ä† ‚àò U = \mathrm{id}_{V1}$</span> and <span>$U ‚àò U^‚Ä† = \mathrm{id}_{V2}$</span>.</p><p>Note that spaces that are isomorphic are not necessarily equal. One can be a dual space, and the other a normal space, or one can be an instance of <code>ProductSpace</code>, while the other is an <code>ElementarySpace</code>. There will exist (infinitely) many isomorphisms between the corresponding spaces, but in general none of those will be canonical.</p><p>There are a number of convenience functions to create isomorphic spaces. The function <code>fuse(V1, V2, ...)</code> or <code>fuse(V1 ‚äó V2 ‚äó ...)</code> returns an elementary space that is isomorphic to <code>V1 ‚äó V2 ‚äó ...</code>. The function <code>flip(V::ElementarySpace)</code> returns a space that is isomorphic to <code>V</code> but has <code>isdual(flip(V)) == isdual(V&#39;)</code>, i.e. if <code>V</code> is a normal space then <code>flip(V)</code> is a dual space. <code>flip(V)</code> is different from <code>dual(V)</code> in the case of <a href="man/@ref"><code>GradedSpace</code></a>. It is useful to flip a tensor index from a ket to a bra (or vice versa), by contracting that index with a unitary map from <code>V</code> to <code>flip(V)</code>. (<strong>In the language of category, the we have <code>flip(a)==</code> <span>$\overline{a}^*$</span> .</strong>)</p><p>Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñù^3 ‚âæ ‚Ñù^5</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ^3 ‚âæ (‚ÑÇ^5)&#39;</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚ÑÇ^5) ‚âÖ (‚ÑÇ^5)&#39;</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fuse(‚Ñù^5, ‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^15</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fuse(‚ÑÇ^3, (‚ÑÇ^5)&#39; ‚äó ‚ÑÇ^2)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^30</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fuse(‚ÑÇ^3, (‚ÑÇ^5)&#39;) ‚äó ‚ÑÇ^2 ‚âÖ fuse(‚ÑÇ^3, (‚ÑÇ^5)&#39;, ‚ÑÇ^2) ‚âÖ ‚ÑÇ^3 ‚äó (‚ÑÇ^5)&#39; ‚äó ‚ÑÇ^2</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(‚ÑÇ^4)</code><code class="nohighlight hljs ansi" style="display:block;">(‚ÑÇ^4)&#39;</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(‚ÑÇ^4) ‚âÖ ‚ÑÇ^4</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; flip(‚ÑÇ^4) == ‚ÑÇ^4</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>We define the direct sum <code>V1</code> and <code>V2</code> as <code>V1 ‚äï V2</code>, where <code>‚äï</code> is obtained by typing <code>\oplus</code>+TAB. This is possible only if <code>isdual(V1) == isdual(V2)</code>.</p><p>Applying <code>oneunit</code> to an elementary space returns the one-dimensional space, which is isomorphic to the scalar field of the space itself.</p><p>Some examples:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚Ñù^5 ‚äï ‚Ñù^3</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ^5 ‚äï ‚ÑÇ^3</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^8</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ^5 ‚äï (‚ÑÇ^3)&#39;</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch(Direct sum of a vector space and its dual does not exist)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; oneunit(‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ‚ÑÇ^5 ‚äï oneunit(ComplexSpace)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; oneunit((‚ÑÇ^3)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚ÑÇ^5) ‚äï oneunit((‚ÑÇ^5))</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (‚ÑÇ^5)&#39; ‚äï oneunit((‚ÑÇ^5)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch(Direct sum of a vector space and its dual does not exist)</code></pre><p>If <code>V1</code> and <code>V2</code> are two <code>ElementarySpace</code> instances with <code>isdual(V1) == isdual(V2)</code>, we can define a unique infimum <code>V::ElementarySpace</code> with the same value of <code>isdual</code> that satisfies <code>V ‚âæ V1</code> and <code>V ‚âæ V2</code>, as well as a unique supremum <code>W::ElementarySpace</code> that satisfies <code>W ‚âø V1</code> and <code>W ‚âø V2</code>. For <code>CartesianSpace</code> and <code>ComplexSpace</code>, this simply amounts to the space with minimal or maximal dimension, i.e.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; infimum(‚Ñù^5, ‚Ñù^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚Ñù^3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum(‚ÑÇ^5, ‚ÑÇ^3)</code><code class="nohighlight hljs ansi" style="display:block;">‚ÑÇ^5</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supremum(‚ÑÇ^5, (‚ÑÇ^3)&#39;)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: SpaceMismatch(Supremum of space and dual space does not exist)</code></pre><p>The names <code>infimum</code> and <code>supremum</code> are especially suited in the case of <a href="man/@ref"><code>GradedSpace</code></a>, as the infimum of two spaces might be different from either of those two spaces, and similar for the supremum.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../categories/">¬´ Optional introduction to category theory</a><a class="docs-footer-nextpage" href="../sectors/">Sectors, representation spaces and fusion trees ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Saturday 18 September 2021 20:19">Saturday 18 September 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
